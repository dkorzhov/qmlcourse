
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>QMLCourse</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet" />
  <link href="../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/sphinx-book-theme.e8f53015daec13862f6db5e763c41738.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="canonical" href="https://semyonsinchenko.github.io/qmlcourse/_build/html/book/index.html/book/index.html" />
    <link rel="shortcut icon" href="../_static/qmlcourse_favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-2 bd-sidebar site-navigation show single-page" id="site-navigation">
    
</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            
            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/SemyonSinchenko/qmlcourse"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/SemyonSinchenko/qmlcourse/issues/new?title=Issue%20on%20page%20%2Fbook/index.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="id1">
<h1>Приветствие<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>Этот курс позволит вам погрузиться в удивительный мир квантового машинного обучения!</p>
<div class="section" id="id2">
<h2>Почему именно этот курс?<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>Наш курс отличается от других курсов по квантовым вычислениям:</p>
<ul class="simple">
<li><p>он адаптивный и содержит лекции разных уровней сложности и глубины;</p></li>
<li><p>он практический, а все объяснения подкрепляются кодом;</p></li>
<li><p>он про реальные методы, которые будут актуальны ближайшие 10-15 лет.</p></li>
</ul>
</div>
<div class="section" id="id3">
<h2>Как устроен курс?<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>Наш курс разделен на логические блоки, каждый из которых содержит лекции разных уровней сложности:</p>
<ul class="simple">
<li><p><strong>ГОЛУБОЙ</strong> – вводные лекции;</p></li>
<li><p><strong>ЗЕЛЕНЫЙ</strong> – лекции “основного” блока курса;</p></li>
<li><p><strong>ЖЕЛТЫЙ</strong> – лекции, глубже раскрывающие темы блоков;</p></li>
<li><p><strong>КРАСНЫЙ</strong> – лекции про физику и математику, которая стоит за всем этим;</p></li>
<li><p><strong>БЕЛЫЙ</strong> – факультативные лекции.</p></li>
</ul>
<div class="figure align-default" id="course-program">
<img alt="../_images/program.png" src="../_images/program.png" />
<p class="caption"><span class="caption-number">Fig. 1 </span><span class="caption-text">Программа курса</span><a class="headerlink" href="#course-program" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="id4">
<h2>Как будет проходить этот курс?<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>Рекомендуем проходить курс в порядке, обозначенном на схеме.</p>
<p><strong>Желаем успехов!</strong></p>
<div class="toctree-wrapper compound">
<span id="document-book/intro1block/intro1"></span><div class="section" id="intro1">
<span id="id1"></span><h3>О квантовых компьютерах, биткоине и превосходстве<a class="headerlink" href="#intro1" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id2">
<h4>Описание лекции<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>Эта лекция не несет в себе образовательного смысла, а лишь пытается ответить на вопросы, которые обычно возникают у тех, кто впервые сталкивается с темой квантовых вычислений. А именно:</p>
<ul class="simple">
<li><p>что это за вычисления такие?</p></li>
<li><p>зачем вообще это все нужно?</p></li>
<li><p>и когда взломают биткоин?</p></li>
<li><p>что за превосходство, о котором все говорят?</p></li>
</ul>
</div>
<div class="section" id="id3">
<h4>Что это вообще за компьютеры такие?<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<div class="section" id="id4">
<h5>Количественная эволюция компьютеров<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h5>
<p>Сегодня классические компьютеры, построенные на идеях Тьюринга, фон Неймана и Шокли, стали неотъемлемой частью нашей жизни. Все мы привыкли к тому, что с каждым годом наши компьютеры становятся все мощнее и мощнее. И то, что сегодня является бюджетным ноутбуком 15 лет назад было аналогом суперкомпьютера!</p>
<div class="figure align-default" id="moores-law">
<img alt="../_images/Moores_Law.png" src="../_images/Moores_Law.png" />
<p class="caption"><span class="caption-number">Fig. 2 </span><span class="caption-text">Иллюстрация закона Мура — рост числа транзисторов с 1970-х</span><a class="headerlink" href="#moores-law" title="Permalink to this image">¶</a></p>
</div>
<p>Так называемый закон Мура, сформулированный Гордоном Муром еще в конце 60-х годов, говорит нам о том, что число транзисторов на кристалле интегральной схемы будет удваиваться каждые два года. И этот закон стабильно выполняется.</p>
</div>
<div class="section" id="id5">
<h5>Качественная эволюция компьютеров<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h5>
<p>Но, к сожалению, по сугубо физическим причинам, выполнение закона Мура не может длиться вечно — рано или поздно, но прямое увеличение количества транзисторов станет невозможно. Поэтому сегодня все чаще можно услышать слова о том, что современным компьютеры ждет качественная революция. Кто-то говорит о переходе на новые материалы для изготовления транзисторов. Кто-то говорит о создании транзисторов на новых принципах, например, об оптических компьютерах. Но часто можно услышать слова о том, что следующим революционным прорывом станет создание квантовых компьютеров. О них мы и будем говорить.</p>
</div>
<div class="section" id="id6">
<h5>Идея о квантовом компьютере<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h5>
<p>Сегодня существует несколько версий о том, кто же первым высказал идею о квантовом компьютере. Как это часто бывает, сразу несколько ученых одновременно и независимо пришли к одной и той же идее. Одним из таких ученых был Ричард Фейнман.</p>
<div class="figure align-default" id="feinman">
<img alt="../_images/Feinman.jpg" src="../_images/Feinman.jpg" />
<p class="caption"><span class="caption-number">Fig. 3 </span><span class="caption-text">Ричард Фейнман, 1918-1988</span><a class="headerlink" href="#feinman" title="Permalink to this image">¶</a></p>
</div>
<p>В 1981-м году, когда шло очень активное развитие одновременно классических компьютеров и квантовой механики, он высказал идею о том, что для решения задач квантовой физики нам нужен квантовый компьютер.</p>
</div>
<div class="section" id="id7">
<h5>Что это за компьютер такой?<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h5>
<p>Этот вопрос на самом деле крайне сложный и именно ему будет посвящена первая половина нашего курса. Кажется странным, если вопрос, которому будет посвящено несколько полноценных лекций с формулами можно было бы раскрыть в одном абзаце. Было бы ошибкой пытаться сказать, что обычные компьютеры работают на законах классической физики, а квантовые на основе квантовой механики — ведь нормально объяснить работу транзистора можно лишь с привлечением уровня Ферми и прочих квантов. Также неправильно было бы говорить о том, что в отличии от классических компьютеров, где есть лишь <span class="math notranslate nohighlight">\(0\)</span> и <span class="math notranslate nohighlight">\(1\)</span> в квантовых есть все состояния сразу. Ведь ничего не мешает сделать так называемую вероятностную машину Тьюринга, другими словами, классический компьютер, который оперирует многими состояниями сразу. Особенно не хочется сразу сыпать на читателя кучу непонятных терминов, типа квантовой суперпозиции, кубита или запутанности, ведь для тех, кто не знает что такое квантовые компьютеры эти термины, вероятнее всего, тоже ничего не дадут. Для начала, давайте просто условимся, что квантовые компьютеры это, в отличии от фотонных, графеновых, или других перспективных “новых” компьютеров это не только использование новых материалов или технической базы, а еще и использование новой, отличной от заложенной Тьюрингом концепции вычислений, представления и обработки информации.</p>
</div>
</div>
<div class="section" id="id8">
<h4>А зачем это вообще нужно?<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<div class="section" id="id9">
<h5>Факторизация больших чисел<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h5>
<p>Мне кажется, что именно открытие алгоритма Шора для эффективного решения задачи факторизации послужило наибольшим толчком в популяризации квантовых вычислений. Именно после этого большое число специалистов устремилось в эту область, военные и корпорации начали вкладывать деньги, а журналисты стали писать о будущем крахе банковских платежей и вообще всего мира. Вероятно, алгоритм Шора является самым раскрученным квантовым алгоритмом.</p>
<p>Дело в том, что большая часть всей современной криптографии держится на одном простом предположении о невозможности эффективно решать задачу факторизации больших чисел. Ну или по простому, если у нас есть число, которое является произведением двух относительно больших простых чисел, то мы будем до бесконечности искать эти числа и скорее всего так и не найдем их. Но это для классического компьютера. А вот для квантового компьютера в 1994-м Питером Шором был предложен алгоритм, который решает эту задачу эффективно, за относительно короткий промежуток времени.</p>
<div class="figure align-default" id="shor">
<img alt="../_images/Shor.png" src="../_images/Shor.png" />
<p class="caption"><span class="caption-number">Fig. 4 </span><span class="caption-text">Питер Шор, тот, кто переполошил весь мир своим алгоритмом</span><a class="headerlink" href="#shor" title="Permalink to this image">¶</a></p>
</div>
<p>Данному алгоритму будет посвящена отдельная лекция нашего курса и именно этот алгоритм в будущем взломает биткоин и обрушит банковскую систему. Но не все так плохо — развитие квантовых компьютеров подтолкнуло ученых в области криптографии к созданию новых, так называемых <em>пост-квантовых</em> алгоритмов шифрования, которые нельзя взломать за разумное время и на классическом, и на квантовом компьютере.</p>
</div>
<div class="section" id="np">
<h5>Комбинаторные и NP-трудные задачи<a class="headerlink" href="#np" title="Permalink to this headline">¶</a></h5>
<p>Помимо уже озвученных проблем с выполнением закона Мура, есть также и другая проблема. А именно то, что существуют задачи, которые скорее всего никогда не получится эффективно решать на классическом компьютере Тьюринга. Даже на фотонном или графеновом. Хороший пример это задача о рюкзаке. Когда у нас есть рюкзак ограниченного объема, а также есть много предметов разного веса и стоимости. И нам надо наполнить наш рюкзак так, чтобы предметы внутри него имели максимальную суммарную стоимость. Задача кажется легкой, но она относится к так называемым <a class="reference external" href="https://ru.wikipedia.org/wiki/NP-%D0%BF%D0%BE%D0%BB%D0%BD%D0%B0%D1%8F_%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0"><span class="math notranslate nohighlight">\(NP\)</span>-полным задачам</a>. Такие задачи, например, в случае большого рюкзака и набора предметов, невозможно точно решить за разумное время. Да и вообще их решить с приемлемой точностью, пусть даже <em>приближенно</em> это сегодня большая проблема!</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Здесь я не зря написал “скорее всего”. Дело в том, что этот вопрос является одним из <a class="reference external" href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B2%D0%B5%D0%BD%D1%81%D1%82%D0%B2%D0%BE_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%BE%D0%B2_P_%D0%B8_NP">так называемых вопросов тысячелетия</a>. Так, для известной задачи о наполнении рюкзака, мы не знаем сегодня эффективного алгоритма решения на классическом компьютере. Но мы также и не можем пока доказать, что такого алгоритма не существует. Ну то есть скорее всего такого алгоритма и правда не существует, а также скорее всего <span class="math notranslate nohighlight">\(P \neq NP\)</span>, но доказать это пока ни у кого не вышло. Но это скорее лирическое отступление.</p>
</div>
<p>Так вот, дело в том, что для квантовых компьютеров уже сегодня известны алгоритмы, которые позволяют потенциально эффективно, пусть и <em>приближенно</em> решать такие задачи на квантовом компьютере. Это задача коммивояжера, задача о рюкзаке, задача кластеризации графа и много других задач комбинаторной оптимизации. В нашем курсе будет целый блок, посвященный таким квантовым алгоритмам как <em>Variational Quantum Eigensolver</em> и <em>Quantum Approximate Optimization Algorithm</em>.</p>
<div class="figure align-default" id="salesman">
<img alt="../_images/Salesman.png" src="../_images/Salesman.png" />
<p class="caption"><span class="caption-number">Fig. 5 </span><span class="caption-text">Визуализация решения задачи коммивояжера – кратчайший путь, чтобы объехать 12 немецких городов – очень важная задача современной логистики</span><a class="headerlink" href="#salesman" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="id10">
<h5>Симуляция квантовой механики<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h5>
<p>Это то, ради чего Фейнман предложил создать квантовые компьютеры. Это отдельная большая тема, где много квантовой механики. Ей будет посвящено сразу несколько отдельных лекций нашего курса. Но попробуем объяснить в двух словах, не вдаваясь в детали.</p>
<p>Дело в том, что задачи квантовой механики не получается решать аналитически. Казалось бы, в чем проблема, законы Ньютона уже для трех тел тоже аналитически не решаются, но это не мешает нам летать в космос, ведь такую задачу можно решить <em>численно</em>. Но ту приходит вторая проблема, а именно, что явно интегрировать уравнение Шрёдингера по времени, или, по простому, решать квантовую механику <em>численно</em> тоже вычислительно почти невозможно более чем для двух частиц.</p>
<div class="figure align-default" id="schrodinger">
<a class="reference internal image-reference" href="../_images/Schrodinger.jpg"><img alt="../_images/Schrodinger.jpg" src="../_images/Schrodinger.jpg" style="width: 350px;" /></a>
<p class="caption"><span class="caption-number">Fig. 6 </span><span class="caption-text">Эрвин Шрёдингер, 1887-1961, создатель знаменитого уравнения и мема про кота</span><a class="headerlink" href="#schrodinger" title="Permalink to this image">¶</a></p>
</div>
<p>Казалось бы, что нам с этого. Ведь квантовая механика это удел теоретиков. Но вот проблема, квантовая механика лежит в основе квантовой химии, а та, в свою очередь, лежит в основе вообще всей химии и таких ее прикладных направлений, как создание новых лекарств, разработка новых аккумуляторов для автомобилей Tesla и многого другого. И сегодня мы вынуждены использовать лишь очень приближенные решения и концепции, точности которых часто не хватает.</p>
<p>Квантовые компьютеры в этом случае могут сделать реальный прорыв. Ведь в силу своей физической природы квантовый компьютер идеально подходит для симуляции квантовой механики, а значит и решения столь важных сегодня задач из области разработки лекарств и дизайна новых материалов.</p>
</div>
<div class="section" id="id11">
<h5>Машинное обучение и искусственный интеллект<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h5>
<p>За последние 10-15 лет машинное обучение достигло поистине небывалых высот в своем развитии. Многие задачи, решение которых силами компьютера, раньше казалось невозможным сегодня успешно решаются при помощи машинного обучения. Примеры таких задач это, например, игра в Go, различение пород чихуахуа по фотографии, распознавание лиц в видеопотоке, составление относительно осмысленных текстов и генерация картин в стиле Пикассо из простых фотографий. Но оно все еще очень далеко от возможностей человеческого мозга. Так, наиболее масштабные искусственные нейронные сети, по примерным оценкам, имеют сегодня размер, эквивалентный 15 миллионам нейронов, в то время как человеческий мозг имеет порядка 85 миллиардов! Вызывает вопросы также и скорость обучения современных нейронных сетей. Так, самые большие языковые модели сегодня обучаются неделями на кластерах из тысяч видеокарт, в то время как человек с его, относительно скромными вычислительными возможностями учится говорить всего 2-3 года.</p>
<p>И тут тоже на помощь могут прийти квантовые компьютеры. В данном случае, квантовые аналоги нейронных сетей, а также их комбинации с классическими нейронными сетями уже сегодня показывают впечатляющие результаты. Так, есть работы, где показано, что 4 квантовых нейрона по своей выразительности эквивалентны классической искусственной нейронной сети с <span class="math notranslate nohighlight">\(\sim 250\)</span> нейронами!</p>
<p>Именно квантовому машинному обучению, а также способам его применения и будет посвящена большая часть нашего курса. Мы постараемся рассмотреть все вопросы по этой теме, начиная от теории того, как можно строить квантовые алгоритмы машинного обучения и заканчивая тем, как их можно запрограммировать на современных языках квантового программирования. Если эта тема вам интересна, то этот курс точно для вас!</p>
</div>
</div>
<div class="section" id="id12">
<h4>Ну и когда взломают биткоин?<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h4>
<p>Наверное это один из главных вопросов, которые возникают при чтении подобных статей. И ответим сразу: взломают нескоро, времени еще много, 10 лет точно есть.</p>
<div class="figure align-default" id="bitcoin">
<a class="reference internal image-reference" href="../_images/Bitcoin.jpg"><img alt="../_images/Bitcoin.jpg" src="../_images/Bitcoin.jpg" style="width: 400px;" /></a>
<p class="caption"><span class="caption-number">Fig. 7 </span><span class="caption-text">Биткоин, как и многие другие электронные средства вынуждены будут перейти на пост-квантовую криптографию</span><a class="headerlink" href="#bitcoin" title="Permalink to this image">¶</a></p>
</div>
<div class="section" id="id13">
<h5>Сколько нужно кубитов под разные задачи?<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h5>
<p>Наверное сразу стоит оценить тот размер, который квантовый компьютер должен иметь для эффективного решения описанных выше задач. Примерно цифры такие:</p>
<ul class="simple">
<li><p>Алгоритм Шора и взлом современной криптографии (включая биткоин): <span class="math notranslate nohighlight">\(\sim 20\cdot 10^6\)</span> (20 миллионов) кубит</p></li>
<li><p>Задачи оптимизации: <span class="math notranslate nohighlight">\(\sim 100 \cdot 10^3\)</span> (100 тысяч) кубит</p></li>
<li><p>Первые полезные задачи в квантовой химии: <span class="math notranslate nohighlight">\(\sim 1\cdot 10^3\)</span> (1 тысяча) кубит</p></li>
<li><p>Квантовое машинное обучение: <span class="math notranslate nohighlight">\(\sim 100-500\)</span> кубит</p></li>
</ul>
<p>Это кстати одна из причин, почему наш курс посвящен по большей части именно квантовому машинному обучению.</p>
</div>
<div class="section" id="vs">
<h5>Логические vs Физические кубиты<a class="headerlink" href="#vs" title="Permalink to this headline">¶</a></h5>
<p>Есть еще такая проблема, что вся квантовая механика вероятностная. А еще, что квантовые компьютеры работают в области микромира и очень чувствительны к любым шумам извне. Это ведет к совершенно недопустимому уровню ошибок в вычислениях и их низкой детерминированности. Например, сегодня хорошим уровнем точности для квантовых компьютеров является 99% на одну операцию. Но ведь каждый алгоритм включает в себя сотни или даже тысячи операций! И тогда уровень ошибок становится совсем печальным.</p>
<p>Но есть и хорошие новости. Сегодня существует очень много классных алгоритмов коррекции ошибок, которые позволяют используя несколько физических кубит с высоким уровнем ошибок создать один логический кубит, имеющий очень низкий уровень ошибок. То есть программист будет писать код, который производит операции над одним кубитом, а на физическом уровне это будет операция над несколькими кубитами. В общем вопрос вполне решаемый. Вот только для создания одного качественного логического кубита может потребоваться до тысячи физических кубит! А те оценки, которые мы привели выше, они как раз про логические кубиты, то есть кубиты с очень высокой точностью операций на уровне классических компьютеров.</p>
</div>
<div class="section" id="id14">
<h5>Сколько кубит есть сегодня?<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h5>
<p>Скажем сразу, сегодня уже существуют квантовые компьютеры. Вот только все производители, когда пишут о новом рекорде, имеют в виду чаще всего именно физические кубиты.</p>
<div class="figure align-default" id="qc">
<a class="reference internal image-reference" href="../_images/quantum_computer.jpg"><img alt="../_images/quantum_computer.jpg" src="../_images/quantum_computer.jpg" style="width: 350px;" /></a>
<p class="caption"><span class="caption-number">Fig. 8 </span><span class="caption-text">Квантовый компьютер компании IBM выглядит примерно так</span><a class="headerlink" href="#qc" title="Permalink to this image">¶</a></p>
</div>
<p>Есть квантовые компьютеры с разной архитектурой. Одни имеют больше кубит, но и более высокий уровень ошибок. Другие имеют низкий уровень ошибок, но их трудно масштабировать. Теме квантового железа в нашем курсе будет посвящен отдельный блок из нескольких лекций. Но если кратко, то можно назвать примерно такие цифры:</p>
<ul class="simple">
<li><p>рекорд в относительно легко масштабируемых, но шумных квантовых компьютерах это <span class="math notranslate nohighlight">\(\sim 55\)</span> кубит</p></li>
<li><p>рекорд в относительно точных, но медленных и плохо масштабируемых компьютерах это <span class="math notranslate nohighlight">\(\sim 20\)</span> кубит</p></li>
<li><p>рекорд в точных и масштабируемых, но очень трудно программируемых компьютерах это <span class="math notranslate nohighlight">\(\sim 25\)</span> кубит</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Тут мы имеем ввиду соответственно:</p>
<ul class="simple">
<li><p>сверхпроводящие кубиты, которые сегодня проще всего масштабировать</p></li>
<li><p>ионы в ловушках, которые имеют одну из самых высоких точностей</p></li>
<li><p>фотоны, которые вроде всем хороши, кроме того, что на них программирование это юстировка линз и лазеров на оптическом столе</p></li>
</ul>
</div>
<p>Стоит добавить, что рекорд в точных и масштабируемых, а также программируемых (топологических) кубитах сегодня это ровно 2 кубита. Серьезно, взаимодействие двух логических кубит было опубликовано в <code class="docutils literal notranslate"><span class="pre">Nature</span></code> в этом году.</p>
</div>
<div class="section" id="id15">
<h5>Какие планы имеют ведущие игроки на этом рынке?<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h5>
<p>Казалось бы, с такими масштабами биткоину боятся нечего, да и в целом область выглядит не самой перспективной. Но есть один нюанс. Все крупные игроки на рынке создания квантовых компьютеров (<em>Google Quantum</em>, <em>IBM Quantum</em>, <em>IonQ</em>, <em>Xanadu</em>) озвучили планы к 2030-му году иметь порядка одного миллиона физических кубит, что эквивалентно порядка тысячи логических кубит. Для криптографии это еще не страшно, но вот многие полезные задачи уже можно будет попробовать решать. Ну и стоит еще раз посмотреть на график закона Мура для классических компьютеров, которые каждые десять лет показывают примерно такой же прогресс!</p>
</div>
</div>
<div class="section" id="id16">
<h4>О квантовом превосходстве<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h4>
<p>Очень часто можно услышать разговоры о том, что достигнуто или опровергнуто квантовое превосходство. Попробуем под конец лекции разобраться, что же это такое и почему это важно (или не важно).</p>
<div class="section" id="id17">
<h5>Понятие квантового превосходства<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h5>
<p>Само понятие было сформулировано еще в 2012-м году известным физиком теоретиком Джоном Прескиллом.</p>
<div class="figure align-default" id="preskill">
<a class="reference internal image-reference" href="../_images/Preskill.jpg"><img alt="../_images/Preskill.jpg" src="../_images/Preskill.jpg" style="width: 350px;" /></a>
<p class="caption"><span class="caption-number">Fig. 9 </span><span class="caption-text">Джон Прескил, который и придумал этот термин. Еще он известен своим знаменитым пари с другим физиком Стивеном Хокингом (которое Хокинг проиграл)</span><a class="headerlink" href="#preskill" title="Permalink to this image">¶</a></p>
</div>
<p>Квантовое превосходство это решение на квантовом компьютере задачи, которую нельзя решить на классическом компьютере за разумное время (10 тысяч лет разумным временем не считается). Достижение квантового превосходства это однозначно новый уровень в развитии квантовых вычислений. Но есть один подвох. Дело в том, что речь идет о совершенно любой задаче, независимо от того, насколько она полезна или бесполезна.</p>
<p>Так что когда кто-то заявляет о достижении квантового превосходства, то это важный повод для ученых и разработчиков квантовых компьютеров, но скорее всего это очень малозначимый факт, с точки зрения простого обывателя.</p>
</div>
<div class="section" id="id18">
<h5>Хронология событий<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h5>
<p>Ну и в конце приводим краткую хронологию событий.</p>
<ul class="simple">
<li><p>2019 год, компания <em>Google</em> заявляет о достижении квантового превосходства. Задача выбрана максимально удобная для квантового компьютера и полностью лишенная практического смысла. По словам разработчиков из <em>Google</em> их квантовый компьютер за 4 минуты решил задачу, которую классический суперкомпьютер решал бы 10 тысяч лет. Их квантовый компьютер имел 54 кубита;</p></li>
<li><p>2019 год, компания <em>IBM</em> заявляет, что <em>Google</em> не учли, что их задачу можно решать на классическом компьютере более оптимально, но без экспериментов;</p></li>
<li><p>2020 год, компания <em>Alibaba</em> реализует алгоритм <em>IBM</em> на своем суперкомпьютере и решает задачу за <span class="math notranslate nohighlight">\(\sim 20\)</span> дней;</p></li>
<li><p>2021 год, группа китайских ученых оптимизирует классический алгоритм и решает задачу на 60 видеокартах <em>NVIDIA</em> за 7 дней;</p></li>
<li><p>2021 год, группа других китайских ученых заявляет, что достигла нового превосходства на квантовом компьютере из 56 кубит;</p></li>
</ul>
<p>В общем сейчас идет довольно интересный процесс войны меча и щита. Пока одни ученые строят более мощные квантовые компьютеры, другие придумывают более продвинутые алгоритмы их симуляции. Хотя конечно все ученые говорят, что уже где-то на 60-70 кубитах эта история окончательно закончится в пользу квантовых компьютеров.</p>
</div>
</div>
<div class="section" id="id19">
<h4>А как это вообще выглядит? И сколько стоит?<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h4>
<p>На сегодня почти все известные технологии создания квантовых компьютеров требуют чего-то из:</p>
<ul class="simple">
<li><p>сверхнизкие температуры</p></li>
<li><p>сверхвысокий вакуум</p></li>
<li><p>сверхточная юстировка лазеров на оптическом столе</p></li>
</ul>
<p>Или даже всего сразу. Поэтому сегодня почти все квантовые компьютеры продаются через облачные сервисы. Например, относительно недавно ведущий поставщик облачных технологий – компания <em>Amazon</em> добавила в свой сервис <code class="docutils literal notranslate"><span class="pre">AWS</span></code> новый продукт <a class="reference external" href="https://aws.amazon.com/braket/">Amazon Braket</a>. Этот продукт позволяет взять в аренду самый настоящий компьютер точно также, как мы привыкли брать в аренду процессоры, видеокарты или жесткие диски. Аналогичные продукты сейчас предоставляют и другие крупные игроки на рынке облачных услуг. Хотя это все пока исключительно для целей исследования. Ведь как мы уже поняли, сегодня квантовые компьютеры еще не способны решать реальные задачи. Стоит такое развлечение не очень дорого, например, можно запустить свою квантовую программу на 32-х кубитном компьютере <code class="docutils literal notranslate"><span class="pre">Aspen-9</span></code> всего за 0.3 USD.</p>
<p>Некоторые производители идут дальше и предлагают относительно компактные решения. Так, недавно <a class="reference external" href="https://phys.org/news/2021-06-compact-quantum-server-centers.amp?__twitter_impression=true">было представлено 24-х кубитное решение</a>, которое помещается в две стандартных серверных стойки. Но масштабируемость таких устройств вызывает вопросы.</p>
<p>В любом случае, в ближайшие 15-20 лет точно не стоит ждать появление карманного квантового компьютера, или хотя бы квантового сопроцессора в домашнем ПК. Да и в этом нет особого смысла, ведь мало кому дома нужно взламывать биткоин, решать логистическую проблему или разрабатывать высокотемпературный сверхпроводник.</p>
</div>
<div class="section" id="id20">
<h4>Заключение<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h4>
<p>Это вводная лекция, она не даст вам каких-то особых знаний. Скорее, ее цель заинтересовать читателя. Самое интересное будет в основной части курса, где мы будем разбирать квантовые алгоритмы, пытаться симулировать квантовую механику и обучать самые настоящие квантовые нейросети! Ждем вас на курсе!</p>
</div>
</div>
</div>
<div class="toctree-wrapper compound">
<span id="document-book/pythonblock/pythonintro"></span><div class="section" id="pythonintro">
<span id="id1"></span><h3>О блоке<a class="headerlink" href="#pythonintro" title="Permalink to this headline">¶</a></h3>
<p>Этот блок включает в себя:</p>
<ul class="simple">
<li><p>вступительный тест по Python, позволяющий определить свой уровень;</p></li>
<li><p>описание процесса установки среды разработки для прохождения курса;</p></li>
<li><p>описание синтаксиса языка программирования Python;</p></li>
<li><p>разбор типовых синтаксических конструкций при программировании на Python;</p></li>
<li><p>примеры анализа возникающих ошибок, помогающие в дальнейшем прохождении курса.</p></li>
</ul>
</div>
<span id="document-book/pythonblock/python_l1"></span><div class="section" id="python">
<span id="python-l1"></span><h3>Вводная лекция про Python<a class="headerlink" href="#python" title="Permalink to this headline">¶</a></h3>
<p>Добро пожаловать во вводный блок курса!
Если у вас есть опыт программирования на <code class="docutils literal notranslate"><span class="pre">Python</span></code>, рекомендуем пройти <a class="reference external" href="http://foo">тест по ссылке</a> – так вы сможете понять, какие разделы стоит изучить или освежить в памяти перед прохождением курса. Тест можно игнорировать, если вы только начинаете свое знакомство с <code class="docutils literal notranslate"><span class="pre">Python</span></code>.</p>
<p>Итак, <code class="docutils literal notranslate"><span class="pre">Python</span></code> – это такой язык программирования, который позволяет сообщить компьютеру о том, что нужно сделать, чтобы достичь некоего результата. За последнее десятилетие он получил быстрое распространение и сейчас является одним из самых популярных языков программирования в мире. Входной порог для его использования достаточно низок: вы можете использовать <code class="docutils literal notranslate"><span class="pre">Python</span></code> для решения своих задач даже если никогда не имели дела с программированием.</p>
<div class="section" id="id1">
<h4>Что такое <code class="docutils literal notranslate"><span class="pre">Python</span></code>?<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">Python</span></code> – это язык программирования <em>общего назначения</em>, используемый во многих приложениях. Например:</p>
<ul class="simple">
<li><p>разработка веб-приложений;</p></li>
<li><p>создание игр;</p></li>
<li><p>продвинутая аналитика данных, в том числе с использованием нейронных сетей;</p></li>
<li><p>компьютерная графика;</p></li>
<li><p>геофизика;</p></li>
<li><p>психология;</p></li>
<li><p>химия;</p></li>
<li><p>теория графов.</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">Python</span></code> используют практически все крупные компании, о которых вы слышите каждый день: Google, Yandex, YouTube, Dropbox, Amazon, Facebook … список можно продолжать часами.</p>
<div class="figure align-default" id="blackhole">
<a class="reference internal image-reference" href="../_images/blackhole.png"><img alt="../_images/blackhole.png" src="../_images/blackhole.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">Fig. 10 </span><span class="caption-text"><a class="reference external" href="https://github.com/Python-simulation/Black-hole-simulation-using-python">Рассчитанная в Python симуляция преломлений света черной дырой</a></span><a class="headerlink" href="#blackhole" title="Permalink to this image">¶</a></p>
</div>
<div class="section" id="id2">
<h5>Чем примечателен <code class="docutils literal notranslate"><span class="pre">Python</span></code>?<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h5>
<p>В основе разностороннего применения и популярности лежит <strong>простота изучения</strong>: все чаще люди начинают свой путь в программировании с <code class="docutils literal notranslate"><span class="pre">Python</span></code>, поскольку он очень <strong>дружелюбен к новичкам</strong> и позволяет максимально быстро перейти к решению целевой задачи.</p>
<p>Сюда же можно отнести <strong>многообразие библиотек</strong> (или <em>расширений функциональности</em>, то есть кода, написанного другими людьми, который вы можете переиспользовать). Хотите изучить физику небесных тел и симулировать их взаимодействия? Можно найти и скачать библиотеку, позволяющую за один вечер провести вычисления, о которых в прошлом веке можно было лишь мечтать. Хотите создать прототип мобильного приложения? И на этот случай есть библиотека. Вам нравится квантовая физика и вы хотите использовать ее вместе с умными компьютерными алгоритмами? Что ж, тогда вы снова по адресу.</p>
<div class="figure align-default" id="aero-python">
<a class="reference internal image-reference" href="../_images/aero_python.png"><img alt="../_images/aero_python.png" src="../_images/aero_python.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">Fig. 11 </span><span class="caption-text"><a class="reference external" href="https://lorenabarba.com/blog/announcing-aeropython/">Пример моделирования аэродинамики в Python с помощью библиотеки AeroPython</a></span><a class="headerlink" href="#aero-python" title="Permalink to this image">¶</a></p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Python</span></code> – это <strong>высокоуровневый язык для быстрой разработки и/или прототипирования</strong>, на нем очень удобно проверять гипотезы и идеи. “<em>Высокоуровневый</em>” означает, что вам не нужно вникать в устройство компьютера и тонкости взаимодействия с ним, чтобы перейти к задаче. Многое «сделано за вас»: вы работаете с простыми <em>абстракциями</em> (или удобными представлениями), а не боретесь с компьютером из-за непонимания сложностей его устройства.</p>
<p>Еще один плюс в копилку популярности языка – это <strong>элегантность и краткость синтаксиса</strong> (принципов написания кода, как будто это абзацы в тексте или колонки в газете). Вместе с вышеупомянутым обилием библиотек вы можете буквально за 5 минут и 10 строк кода – а это меньше половины листа А4 – воспроизвести научную статью, в которую вложено несколько человеко-лет. А еще такой синтаксис делает <strong>код легким для чтения, запоминания и понимания</strong>.</p>
<p>Стоит отметить, что <code class="docutils literal notranslate"><span class="pre">Python</span></code> – это <strong>интерпретируемый</strong> язык, а значит, компьютер каждый раз перед выполнением программы читает код строчку за строчкой и определяет (интерпретирует), что нужно сделать дальше, не проводя никаких оптимизаций и предварительных расчетов. Это негативно влияет на общую скорость работы: <code class="docutils literal notranslate"><span class="pre">Python</span></code> является одним из самых медленных языков. Тем не менее он отлично подходит для академических целей, например, исследовательской работы или других задач, где скорость работы не является критически важной. Настоящая сила <code class="docutils literal notranslate"><span class="pre">Python</span></code> заключается в том, что это <strong>“язык-клей”</strong>: он обеспечивает удобный доступ к различным библиотекам, написанным на высокоэффективных языках, например, на C/C++, Fortran, CUDA C и других.</p>
</div>
<div class="section" id="id3">
<h5>И в чем подвох?<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h5>
<p>В простоте языка и его доступности для быстрого старта таится одна из проблем: вы <em>можете не понимать, что происходит внутри</em>, поэтому иногда бывает сложно разобраться в причинах ошибок и неточностей, возникающих по ходу работы над задачей. В целом к <code class="docutils literal notranslate"><span class="pre">Python</span></code> применим следующий принцип: “<strong>Easy to learn, hard to master</strong>”. Возвращаясь к примеру элегантности кода, когда 10 строк кода выполняют всю работу: важно понимать, что за ними стоят еще <em>сотни</em> или даже <em>тысячи строк кода</em>, а это может приводить к ситуациям, когда поиск ошибки в минимальном наборе команд растягивается на несколько дней.</p>
</div>
</div>
<div class="section" id="id4">
<h4>Но не пугайтесь!<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>В данном блоке мы постараемся дать вам всю необходимую интуицию и теорию для успешного прохождения настоящего курса, ответим на основные вопросы, покажем типовые примеры использования <code class="docutils literal notranslate"><span class="pre">Python</span></code> и разберем классические ошибки.</p>
<p>Дополнительно отметим, что <code class="docutils literal notranslate"><span class="pre">Python</span></code> хорош и для квантового машинного обучения (<code class="docutils literal notranslate"><span class="pre">QML</span></code>), ради которого весь курс и затеян, в особенности – для классического машинного обучения (<code class="docutils literal notranslate"><span class="pre">ML</span></code>). В области <code class="docutils literal notranslate"><span class="pre">ML</span></code> этот язык программирования стал де-факто стандартом, который используют практически все специалисты.</p>
<div class="section" id="id5">
<h5>Интересные факты<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h5>
<p>Еще немного дополнительной информации про <code class="docutils literal notranslate"><span class="pre">Python</span></code>:</p>
<ul class="simple">
<li><p>Разработчик языка Гвидо ван Россум назвал его в честь популярного британского комедийного телешоу 1970-х «Летающий цирк Монти Пайтона».</p></li>
<li><p>Актуальной версией <code class="docutils literal notranslate"><span class="pre">Python</span></code> считаются версии <code class="docutils literal notranslate"><span class="pre">3.6</span></code> и выше (<code class="docutils literal notranslate"><span class="pre">3.7</span></code>, <code class="docutils literal notranslate"><span class="pre">3.8.12</span></code>…). Долгое время (до 2020) года существовал <code class="docutils literal notranslate"><span class="pre">Python</span> <span class="pre">2</span></code>, который ныне не поддерживается и не обновляется. Если вы видите кусок кода на <code class="docutils literal notranslate"><span class="pre">Python</span> <span class="pre">2</span></code> и вам предстоит работать с ним, возможно, сначала придется его переписать, хотя большая часть кода имеет совместимость и работает корректно. В этом курсе мы не будем изучать <code class="docutils literal notranslate"><span class="pre">Python</span> <span class="pre">2</span></code>.</p></li>
<li><p>У <code class="docutils literal notranslate"><span class="pre">Python</span></code> огромное сообщество: большинство проблем, с которыми вы можете столкнуться, уже было озвучено и даже решено. Это означает, что используя поисковик, вы можете решить практически все проблемы в течение 10-30 минут. Главное – научиться правильно формулировать свои вопросы.</p></li>
<li><p>При работе с <code class="docutils literal notranslate"><span class="pre">Python</span></code> следует придерживаться принципа “должен существовать один и, желательно, только один очевидный способ сделать это”. Другие принципы (<code class="docutils literal notranslate"><span class="pre">Дзен</span> <span class="pre">Питона</span></code>) на русском языке – <a class="reference external" href="https://tyapk.ru/blog/post/the-zen-of-python">по ссылке</a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Python</span></code> – это <em>открытый проект</em>, в который каждый может внести изменения (но они должны быть предварительно одобрены), например, <a class="reference external" href="https://mail.python.org/archives/list/python-ideas&#64;python.org/">тут</a>.</p></li>
<li><p>Есть целый набор рекомендаций и предложений по улучшению кода (<code class="docutils literal notranslate"><span class="pre">PEP</span></code>, <a class="reference external" href="https://www.python.org/dev/peps/">Python Enhancement Proposals</a>). Они содержат указания на то, как следует писать код и чего стоит избегать, а также дискуссии о будущих изменениях в языке.</p></li>
<li><p>Язык постоянно развивается, в нем появляются новые возможности, улучшается производительность (скорость выполнения).</p></li>
<li><p>Сборник всех существующих в открытом доступе библиотек <a class="reference external" href="https://pypi.org/">находится тут</a>.</p></li>
<li><p>Если вы столкнетесь с багом (системной ошибкой, вызванной внутренним механизмом языка), то сообщить об этом можно <a class="reference external" href="https://bugs.python.org/">на специальном сайте</a>.</p></li>
</ul>
<div class="figure align-default" id="cat-at-the-end">
<a class="reference internal image-reference" href="../_images/cat_at_the_end.png"><img alt="../_images/cat_at_the_end.png" src="../_images/cat_at_the_end.png" style="width: 350px;" /></a>
<p class="caption"><span class="caption-number">Fig. 12 </span><span class="caption-text">Кот для привлечения внимания и в благодарность за то, что вы начали проходить курс и сделали самый сложный шаг – прошли первую лекцию!</span><a class="headerlink" href="#cat-at-the-end" title="Permalink to this image">¶</a></p>
</div>
</div>
</div>
</div>
<span id="document-book/pythonblock/jupyter_l3"></span><div class="section" id="jupyter">
<span id="jupyter-l3"></span><h3>Знакомство с инструментарием: Jupyter<a class="headerlink" href="#jupyter" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id1">
<h4>Описание лекции<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>Эта лекция расскажет:</p>
<ul class="simple">
<li><p>что такое <code class="docutils literal notranslate"><span class="pre">Jupyter</span></code> и чем он хорош;</p></li>
<li><p>о видах ячеек и режимах работы в <code class="docutils literal notranslate"><span class="pre">Jupyter</span></code>;</p></li>
<li><p>о самых необходимых горячих клавишах;</p></li>
<li><p>что такое ядро и почему вас это должно волновать.</p></li>
</ul>
</div>
<div class="section" id="id2">
<h4>Введение<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>Как любой мастер должен знать свой инструмент, так и любой человек, решивший пройти курс QML, должен понимать тонкости рабочей среды. Как вы уже могли понять по прошлому занятию, всю (или большую часть) работы мы будем делать в <code class="docutils literal notranslate"><span class="pre">Jupyter</span> <span class="pre">Notebook</span></code>. Но бояться нечего: по сути, <code class="docutils literal notranslate"><span class="pre">Jupyter</span></code> – это <em>продвинутый текстовый редактор</em> с функцией запуска кода и получения результатов вычислений. Настолько продвинутый, что позволяет вам не только рисовать картинки и писать формулы, но даже строить целые интерактивные карты:</p>
<div class="figure align-default" id="interactive-map">
<a class="reference internal image-reference" href="../_images/interactive_map.gif"><img alt="../_images/interactive_map.gif" src="../_images/interactive_map.gif" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">Fig. 13 </span><span class="caption-text"><a class="reference external" href="https://medium.com/&#64;bartomolina/geospatial-data-visualization-in-jupyter-notebooks-ffa79e4ba7f8">Пример интерактивной визуализации прямо внутри рабочего файла с кодом</a></span><a class="headerlink" href="#interactive-map" title="Permalink to this image">¶</a></p>
</div>
<p>На курсе, конечно, работы с гео-данными не будет, однако очень пригодятся вывод информации в виде <em>таблиц</em>, <em>создание и отрисовка простых графиков</em>, а главное, все это происходит в <strong>браузере</strong>. Редактирование кода в браузере не вызывает лишних проблем со средами разработки и в то же время оно доступно максимально широкому кругу людей. В этом редакторе можно запускать <code class="docutils literal notranslate"><span class="pre">Python</span></code>-код, что очень похоже на интерактивный редактор MATLAB, если вы с ним знакомы.</p>
<p>Благодаря удобству использования и доступности <code class="docutils literal notranslate"><span class="pre">Jupyter</span></code> в настоящее время стал крупным игроком в нише научных вычислений и быстрого прототипирования. Вдобавок он безумно удобен для обучения и передачи знаний. Почему? Давайте разбираться.</p>
</div>
<div class="section" id="id3">
<h4>Типы ячеек<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>В <code class="docutils literal notranslate"><span class="pre">Jupyter</span> </code> существует несколько типов <strong>ячеек</strong>, мы поговорим о двух основных: <strong>Code</strong> и <strong>Markdown</strong>. В прошлом уроке мы создали пустой <strong>ноутбук</strong>, чтобы проверить установку <code class="docutils literal notranslate"><span class="pre">Jupyter</span></code>. <strong>Ноутбуком</strong> это называется потому, что в переводе с английского <strong>notebook</strong> – это тетрадка (альтернативное название на русском языке). В тетрадке можно писать что-то осмысленное, черкаться, оставлять пометки. Сейчас вы должны видеть вот такой экран:</p>
<div class="figure align-default" id="jupyter-ui-1">
<a class="reference internal image-reference" href="../_images/jupyter_ui_1.png"><img alt="../_images/jupyter_ui_1.png" src="../_images/jupyter_ui_1.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">Fig. 14 </span><span class="caption-text">Пример пустой только что созданной тетрадки.</span><a class="headerlink" href="#jupyter-ui-1" title="Permalink to this image">¶</a></p>
</div>
<p>Здесь верхней красной чертой выделено поле с <strong>названием</strong> ноутбука. Можете кликнуть по нему, переименовать во что-то осмысленное и нажать <code class="docutils literal notranslate"><span class="pre">Enter</span></code>, чтобы применить изменения. Нижней же чертой обозначен выпадающий список переключений <strong>типов ячеек</strong>. По умолчанию создана одна <strong>code</strong> ячейка – в ней в будущем мы будем писать <code class="docutils literal notranslate"><span class="pre">Python</span></code>-код. Попробуйте кликнуть по списку и выбрать <strong>Markdown</strong> – визуально ячейка немного изменится.</p>
<div class="admonition-markdown-https-ru-wikipedia-org-wiki-markdown admonition">
<p class="admonition-title">Что такое <a class="reference external" href="https://ru.wikipedia.org/wiki/Markdown">Markdown</a>?</p>
<p><strong>Markdown</strong> (произносится маркда́ун) – облегченный язык разметки, созданный с целью обозначения <strong>форматирования</strong> в простом тексте с максимальным сохранением его читаемости человеком.</p>
</div>
<p>Пример: <code class="docutils literal notranslate"><span class="pre">Text</span> <span class="pre">attributes</span> <span class="pre">_italic_,**bold**,</span> <span class="pre">`monospace`.</span></code></p>
<p>С помощью Markdown можно разнообразить код, вставить формулы (в том числе в <a class="reference external" href="https://ru.wikipedia.org/wiki/LaTeX">LaTeX</a> формате, если он вам знаком), ссылки на статьи и многое другое. Попробуйте скопировать код из примера выше в Markdown-ячейку и нажать кнопку <code class="docutils literal notranslate"><span class="pre">Run</span></code>:</p>
<div class="figure align-default" id="jupyter-ui-2">
<a class="reference internal image-reference" href="../_images/jupyter_ui_2.png"><img alt="../_images/jupyter_ui_2.png" src="../_images/jupyter_ui_2.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">Fig. 15 </span><span class="caption-text">Пример выполненной ячейки. Красным квадратом выделена кнопка  <code class="docutils literal notranslate"><span class="pre">Run</span></code>.</span><a class="headerlink" href="#jupyter-ui-2" title="Permalink to this image">¶</a></p>
</div>
<p>Произошло следующее: ваша ячейка выполнилась и <code class="docutils literal notranslate"><span class="pre">Jupyter</span></code> отобразил ее содержимое. С помощью такого форматирования можно писать целые статьи с выкладками, формулами, графиками, то есть сопроводительной информацией. Поэтому, как уже было сказано, тетрадки очень удобны, особенно если соблюдать структуру, то есть писать сверху вниз с разделением на логические блоки. Также стоит отметить, что создалась новая Code-ячейка прямо под первой.</p>
<div class="figure align-default" id="jupyter-ui-3">
<a class="reference internal image-reference" href="../_images/jupyter_ui_3.png"><img alt="../_images/jupyter_ui_3.png" src="../_images/jupyter_ui_3.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">Fig. 16 </span><span class="caption-text">Пример грамотно <a class="reference external" href="https://nbviewer.jupyter.org/github/rlabbe/Kalman-and-Bayesian-Filters-in-Python/blob/master/05-Multivariate-Gaussians.ipynb">оформленной Jupter-тетрадки</a>. Такую можно скинуть коллегам – и всем все будет понятно!</span><a class="headerlink" href="#jupyter-ui-3" title="Permalink to this image">¶</a></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Самая прекрасная часть тетрадок: <strong>ячейки разных типов можно смешивать по порядку</strong>, таким образом сначала описывая какую-то логику, а затем непосредственно реализовывая ее в коде и выполняя.</p>
</div>
<p>Вам не так часто придется писать Markdown-заметки самостоятельно, основная причина их создания – ваше желание и дальнейшее удобство использования ноутбука. Есть также другая причина, по которой мы акцентируем на них внимание. Может так произойти, что вы <em>случайно</em> изменили тип ячейки и не заметили этого. Теперь, если в Markdown-ячейку вставить <code class="docutils literal notranslate"><span class="pre">Python</span></code>-код, то ничего не произойдет или возникнет ошибка. Если вы заметили что-то странное при выполнении кода в тетрадке – <strong>проверьте, корректен ли тип ячейки</strong>. Для выполнения кода нужно выставить тип <strong>Code</strong>.</p>
<div class="figure align-default" id="jupyter-ui-4">
<a class="reference internal image-reference" href="../_images/jupyter_ui_4.png"><img alt="../_images/jupyter_ui_4.png" src="../_images/jupyter_ui_4.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">Fig. 17 </span><span class="caption-text">Верхняя ячейка с <code class="docutils literal notranslate"><span class="pre">print</span></code> написана в Code-режиме и корректно выполняется, печатая строчку с приветствием. Нижняя ячейка же содержит <strong>текст, а не код</strong>, поэтому ничего работать не будет (точнее, код отобразится как текст, но не будет выполнен).</span><a class="headerlink" href="#jupyter-ui-4" title="Permalink to this image">¶</a></p>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Обратите внимание, как визуально отличаются эти две ячейки. Одна из них имеет прозрачный фон, другая – серый. У <strong>Code</strong> ячейки также есть странная надпись слева (про нее еще поговорим).</p>
</div>
<p>Каждый раз вручную запускать код (или Markdown) через кнопку <code class="docutils literal notranslate"><span class="pre">Run</span></code> не очень-то удобно, поэтому можно запомнить две комбинации клавиш. <code class="docutils literal notranslate"><span class="pre">CTRL+Enter</span></code> <strong>выполнит</strong> текущую ячейку и оставит “курсор” (указатель на ячейку) <strong>на том же месте</strong>, не создавая лишнюю строчку в ноутбуке. <code class="docutils literal notranslate"><span class="pre">Shift+Enter</span></code> повторит функциональность кнопки <code class="docutils literal notranslate"><span class="pre">Run</span></code>: выполнит ячейку, а затем <strong>перейдет на следующую</strong> (или <strong>создаст новую</strong>, если текущая ячейка является <strong>последней</strong>).</p>
<p>Первая комбинация (<code class="docutils literal notranslate"><span class="pre">CTRL+Enter</span></code>) будет полезна в том случае, если вы что-то написали и знаете, что будете вносить изменения (например, менять цвет линии на графике в попытках добиться визуальной красоты), а значит, придется менять код в этой же ячейке.</p>
<p>Вторая (<code class="docutils literal notranslate"><span class="pre">Shift+Enter</span></code>) пригодится тогда, когда вы хотите запустить много-много идущих подряд ячеек (можете представить, что коллега скинул вам свою тетрадку с 30 клетками и вы хотите ее запустить, чтобы получить данные).</p>
<p>Не беспокойтесь, буквально к концу первого блока лекций у вас выработается мышечная память и вы будете использовать сочетания клавиш на автомате.</p>
</div>
<div class="section" id="id4">
<h4>Режимы работы<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>Пришло время разобраться с цветом курсора, выделяющего ячейки. Он может быть <strong>синим</strong> или <strong>зеленым</strong>.</p>
<div class="figure align-default" id="jupyter-ui-5">
<a class="reference internal image-reference" href="../_images/jupyter_ui_5.png"><img alt="../_images/jupyter_ui_5.png" src="../_images/jupyter_ui_5.png" style="width: 600px;" /></a>
</div>
<div class="figure align-default" id="jupyter-ui-6">
<a class="reference internal image-reference" href="../_images/jupyter_ui_6.png"><img alt="../_images/jupyter_ui_6.png" src="../_images/jupyter_ui_6.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">Fig. 18 </span><span class="caption-text">Пример разного цвета указателя клетки.</span><a class="headerlink" href="#jupyter-ui-6" title="Permalink to this image">¶</a></p>
</div>
<p>Никакой тайны за этим нет, это два режима: <strong>режим редактирования и командный режим</strong>. Зеленый цвет сигнализирует о том, что вы работаете <strong>с текстовым содержимым ячейки</strong>, то есть редактируете его! Можете писать код, вставлять формулы, что угодно. Но как только вы нажмете <code class="docutils literal notranslate"><span class="pre">ESC</span></code> на клавиатуре, цвет сменится на синий, что означает <strong>возможность редактирования всего ноутбука, а не отдельных ячеек в нем</strong>. Можно передвигать ячейки, удалять их (полностью, а не только текст в них), добавлять новые. Стрелочками на клавиатуре можно выбирать ячейки (скакать вверх и вниз). Как только доберетесь до нужной (а вместо этого можно просто кликнуть по ней мышкой, что полезно в ситуации, когда клетка <em>очень</em> далеко, в самом низу страницы) – жмите <code class="docutils literal notranslate"><span class="pre">Enter</span></code>, чтобы вернуться к редактированию.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Можно осуществлять переходы между режимами кликом мышки (внутри блока кода либо где-нибудь в стороне, слева или справа от ячейки, где ничего нет).</p>
</div>
<div class="figure align-default" id="jupyter-ui-7">
<a class="reference internal image-reference" href="../_images/jupyter_ui_7.png"><img alt="../_images/jupyter_ui_7.png" src="../_images/jupyter_ui_7.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">Fig. 19 </span><span class="caption-text">Кнопки управления ноутбуком.</span><a class="headerlink" href="#jupyter-ui-7" title="Permalink to this image">¶</a></p>
</div>
<p>Выполнять описанные выше операции можно с помощью горячих клавиш (или хоткеев), либо через интерфейс. Описание выделенного блока кнопок для картинки выше (в порядке слева направо, с указанием сочетаний клавиш):</p>
<ol class="simple">
<li><p><em>Сохранение ноутбука</em> (<code class="docutils literal notranslate"><span class="pre">CTRL+S</span></code>) – делайте его <strong>почаще</strong>, чтобы не потерять результаты работы!</p></li>
<li><p><em>Создание ячейки ниже текущей</em> (<code class="docutils literal notranslate"><span class="pre">B</span></code>) – <code class="docutils literal notranslate"><span class="pre">B</span></code> потому, что создается клетка снизу, то есть <code class="docutils literal notranslate"><span class="pre">Below</span></code>. Логика для <code class="docutils literal notranslate"><span class="pre">A</span></code> и <code class="docutils literal notranslate"><span class="pre">Above</span></code> аналогична.</p></li>
<li><p><em>Вырезать ячейку</em> (<code class="docutils literal notranslate"><span class="pre">X</span></code>) – применимо и к целому блоку ячеек (можно выделить с зажатой клавишей <code class="docutils literal notranslate"><span class="pre">Shift</span></code>). Функциональность как и в Excel/Word: убрать в одном месте, чтобы вставить в другом.</p></li>
<li><p><em>Копировать ячейку</em> (<code class="docutils literal notranslate"><span class="pre">C</span></code>).</p></li>
<li><p><em>Вставить ячейку из буфера</em> (<code class="docutils literal notranslate"><span class="pre">V</span></code>) – после вырезания или копирования ячейки.</p></li>
<li><p><em>Переместить текущую выделенную ячейку <strong>вверх</strong></em>.</p></li>
<li><p><em>Переместить текущую выделенную ячейку <strong>вниз</strong></em>.</p></li>
</ol>
<p>Описание всех доступных команд (и соответствующих им хоткеев) доступно при нажатии на кнопку с клавиатурой в правой части выделенного блока меню (вне красного прямоугольника).</p>
<div class="admonition attention">
<p class="admonition-title">Attention</p>
<p>Попробуйте потратить 5-7 минут на практику использования этих кнопок и сочетаний клавиш.</p>
</div>
<p>Первое время можете пользоваться только элементами UI-интерфейса – это нормально, главное, сопоставить кнопки и стоящую за ними функциональность.</p>
</div>
<div class="section" id="id5">
<h4>Оставшиеся кнопки на панели<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>Про кнопку <code class="docutils literal notranslate"><span class="pre">Run</span></code> (и хоткей <code class="docutils literal notranslate"><span class="pre">Shift+Enter</span></code>) мы уже поговорили, а что с остальными?</p>
<div class="figure align-default" id="jupyter-ui-8">
<a class="reference internal image-reference" href="../_images/jupyter_ui_8.png"><img alt="../_images/jupyter_ui_8.png" src="../_images/jupyter_ui_8.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">Fig. 20 </span><span class="caption-text">Кнопки управления <strong>ЯДРОМ</strong> ноутбуком.</span><a class="headerlink" href="#jupyter-ui-8" title="Permalink to this image">¶</a></p>
</div>
<p>Для того, чтобы вы могли запускать код <code class="docutils literal notranslate"><span class="pre">Python</span></code>, запускается так называемое <strong>“ядро” (или kernel)</strong>, то есть приложение, которое непосредственно выполняет (запускает) ваш код и передает результаты обратно в <code class="docutils literal notranslate"><span class="pre">Jupyter</span></code>-ноутбук. За это отвечает как раз <code class="docutils literal notranslate"><span class="pre">Run</span></code>.</p>
<p>Справа от нее расположен <code class="docutils literal notranslate"><span class="pre">Stop</span></code>, который <strong>прерывает выполнение программы</strong>. Он может быть полезен в случаях, когда вы запустили расчеты на час, но заметили ошибку – и поэтому нужно и код переписать, и ячейку с кодом снова запустить. И в этой ситуации вы сначала <strong>останавливаете</strong> выполнение, редактируете код, затем жмете <code class="docutils literal notranslate"><span class="pre">Run</span></code> – и все готово!</p>
<p>Но случается беда и код не останавливается, потому что ядро <code class="docutils literal notranslate"><span class="pre">Python</span></code> зависает. В таких случаях нужно <strong>перезапустить ядро</strong> – и кнопка с закругленной стрелочкой <code class="docutils literal notranslate"><span class="pre">Restart</span></code> поможет осуществить задуманное. Будьте аккуратны – <strong>вы потеряете ВСЕ несохраненные данные</strong> (значения переменных, результаты расчетов, данные для построения графиков). Сама тетрадка останется без изменений, то есть <strong>написанное сохранится</strong>. Концепция “ядра” и запуска кода станет более понятна, когда мы перейдем к практике.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Пока стоит держаться правила: “Накосячил? Попробуй остановить (<code class="docutils literal notranslate"><span class="pre">Stop</span></code>) ядро. Не получается? Тогда перезапускай (<code class="docutils literal notranslate"><span class="pre">Restart</span></code>) его!”</p>
</div>
<p>Нужно понимать, что ядро “помнит” все предыдущие выполненные ячейки (пока не будет перезагружено или выключено), а значит, вы можете позже в коде переиспользовать те части, которые были описаны ранее (например, переменные или физические константы). Иными словами, состояние ядра сохраняется во времени и между ячейками – <strong>оно относится к документу в целом</strong>, а не к отдельным ячейкам.</p>
<p>Последняя кнопка из выделенного блока имеет говорящее название: <code class="docutils literal notranslate"><span class="pre">Re-start</span> <span class="pre">and</span> <span class="pre">run</span> <span class="pre">all</span></code>. Ядро будет <strong>перезапущено</strong> (все переменные и данные удалятся), а затем <strong>каждая ячейка будет выполнена в порядке сверху вниз</strong>. Поэтому рекомендуется соблюдать структуру, чтобы запускать код с нуля (после возвращения к ноутбуку на следующий день, но с новым ядром, так как компьютер был выключен) – и он отрабатывал.</p>
</div>
<div class="section" id="in">
<h4>Что это за In [*]?<a class="headerlink" href="#in" title="Permalink to this headline">¶</a></h4>
<p>Та самая надпись слева от запущенной Code-ячейки. Это вспомогательная информация о том, что происходит с <strong>кодовой</strong> ячейкой (<code class="docutils literal notranslate"><span class="pre">In</span></code> означает <strong>Input</strong>, то есть ввод кода). Возможно несколько вариантов заполнения.</p>
<div class="figure align-default" id="jupyter-ui-9">
<a class="reference internal image-reference" href="../_images/jupyter_ui_9.png"><img alt="../_images/jupyter_ui_9.png" src="../_images/jupyter_ui_9.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">Fig. 21 </span><span class="caption-text">Пример трех видов информации о статусе ячейки.</span><a class="headerlink" href="#jupyter-ui-9" title="Permalink to this image">¶</a></p>
</div>
<p>В первом случае в квадратных скобках <strong>ничего нет</strong> – это значит, что <strong>ячейка еще не была запущена</strong>. Возможно, вы забыли, а быть может, она просто ждет своего часа.</p>
<p>Во втором случае <strong>ячейка была запущена</strong> шестой по счету (да-да, <strong>ячейки выполняются по порядку, который задаете вы сами</strong>!) и она <strong>успешно отработала и завершилась</strong>.</p>
<p>В последней строчке умышленно был сделан бесконечный цикл. Это означает, что <em>код никогда не сможет выполниться</em> и будет висеть до тех пор, пока вы не остановите (<code class="docutils literal notranslate"><span class="pre">Stop</span></code>ните) ядро. Поэтому там выведен <strong>индикатор выполнения ячейки</strong> – в скобках указана звездочка <code class="docutils literal notranslate"><span class="pre">*</span></code>. Обратите внимание: <strong>это не всегда плохой сигнал</strong>. Если ваш код должен выполняться 2-3 минуты, то все это время будет выводиться <code class="docutils literal notranslate"><span class="pre">[*]</span></code>. Когда код отработает и результат будет получен, отрисуется цифра (например, <code class="docutils literal notranslate"><span class="pre">[7]</span></code> ).</p>
</div>
<div class="section" id="id6">
<h4>Самая полезная клавиша<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<p>Пришло время программировать! Скопируйте себе в ноутбук кусок кода ниже и попробуйте его запустить. Не переживайте, он может показаться сложным и непонятным, но сейчас не требуется понимание всех деталей.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">mat.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>

<span class="c1"># Fixing random state for reproducibility</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">19680801</span><span class="p">)</span>

<span class="c1"># Compute pie slices</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">θ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">radii</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">colors</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">viridis</span><span class="p">(</span><span class="n">radii</span> <span class="o">/</span> <span class="mf">10.</span><span class="p">)</span>

<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;polar&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">θ</span><span class="p">,</span> <span class="n">radii</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">();</span>
</pre></div>
</div>
<p>Вы увидите ошибку. По сообщению видно (стрелочка в левой части указывает на проблемное место), что во второй строчке используется слово <code class="docutils literal notranslate"><span class="pre">mat</span></code>, при этом <code class="docutils literal notranslate"><span class="pre">Python</span></code> жалуется на отсутствие такого модуля. Все дело в том, что в коде выше производится попытка рисования графика и для этого используется библиотека <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code>. Но в одной из строк написано только <code class="docutils literal notranslate"><span class="pre">mat</span></code>. Это не дело, давайте исправлять. Однако всех библиотек не запомнишь – и это не нужно. Попробуйте поставить курсор после буквы <code class="docutils literal notranslate"><span class="pre">t</span></code> (и перед точкой) и нажать <code class="docutils literal notranslate"><span class="pre">TAB</span></code>. Вы должны увидеть <strong>список подсказок</strong> и из него выбрать нужный вариант. Этот список не только сокращает время написания кода (за счет автоматического дополнения), но и позволяет избежать ошибок в написании. Обязательно пользуйтесь этим инструментом.</p>
<p>Если вы все сделали правильно, воспользовавшись подсказкой, то после очередного запуска (<code class="docutils literal notranslate"><span class="pre">Run</span></code>) кода появится рисунок.</p>
<div class="figure align-default" id="jupyter-ui-10">
<a class="reference internal image-reference" href="../_images/jupyter_ui_10.png"><img alt="../_images/jupyter_ui_10.png" src="../_images/jupyter_ui_10.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">Fig. 22 </span><span class="caption-text">Другой пример удачного использования: есть несколько переменных со сложным, но очень похожим названием. Не стоит их перепечатывать – достаточно нажать <code class="docutils literal notranslate"><span class="pre">TAB</span></code>!</span><a class="headerlink" href="#jupyter-ui-10" title="Permalink to this image">¶</a></p>
</div>
<p>Что ж, большое количество новой информации позади, давайте подведем итоги!</p>
</div>
<div class="section" id="id7">
<h4>Что мы узнали из лекции<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>Существует два основных типа ячеек, один предназначен для программирования (написания кода), другой – для описания (формул, определений).</p></li>
<li><p>Существует два режима работы: <code class="docutils literal notranslate"><span class="pre">edit</span></code> – редактирование конкретной ячейки и <code class="docutils literal notranslate"><span class="pre">control</span></code> – работа со всей структурой тетрадки/ноутбука.</p></li>
<li><p>Режимы работы можно различить по цвету рамки вокруг активной ячейки, а тип ячейки – по прозрачности фона и наличию надписи <code class="docutils literal notranslate"><span class="pre">In[</span> <span class="pre">]</span></code> слева.</p></li>
<li><p>Между режимами можно переключаться с помощью <code class="docutils literal notranslate"><span class="pre">Esc</span></code> и <code class="docutils literal notranslate"><span class="pre">Enter</span></code>.</p></li>
<li><p>Чтобы запустить ячейку (с кодом или текстом), нужно нажать на кнопку <code class="docutils literal notranslate"><span class="pre">Run</span></code> сверху, либо воспользоваться сочетаниями клавиш: <code class="docutils literal notranslate"><span class="pre">Shift+Enter</span></code>, <code class="docutils literal notranslate"><span class="pre">CTRL+Enter</span></code>.</p></li>
<li><p>Нужно не забывать сохранять ноутбук (<code class="docutils literal notranslate"><span class="pre">CTRL+S</span></code>), а быстро добавить ячейку кода можно с помощью плюсика слева сверху (или клавиши <code class="docutils literal notranslate"><span class="pre">B</span></code>).</p></li>
<li><p>Клавиши <code class="docutils literal notranslate"><span class="pre">C</span></code> / <code class="docutils literal notranslate"><span class="pre">V</span></code> позволяют копировать и вставлять ячейки в <code class="docutils literal notranslate"><span class="pre">control</span></code>-режиме.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">In[3]</span></code> указывает на порядок выполнения ячеек с кодом, <code class="docutils literal notranslate"><span class="pre">In[*]</span></code> – на процесс выполнения.</p></li>
<li><p>Если вы долго ждете выполнения Code-блока, можно <code class="docutils literal notranslate"><span class="pre">Stop</span></code>нуть ядро, если не помогает – <code class="docutils literal notranslate"><span class="pre">Restart</span></code>нуть.</p></li>
<li><p>Ядро – это процесс, выполняющий код, и после перезагрузки оно не сохраняет переменные.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TAB</span></code> – ваш друг, позволяющий избегать опечаток, а также реже пользоваться документацией.</p></li>
</ul>
</div>
<div class="section" id="id8">
<h4>Бонус-материал<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<p>Полная официальная документация по Jupyter находится по <a class="reference external" href="https://jupyter-notebook.readthedocs.io/en/stable/notebook.html">ссылке тут</a>.</p>
<p>Если вам захочется узнать больше о трюках в ноутбуках, о недостатках и преимуществах по сравнению с альтернативами, предлагаем посмотреть выступление Joel Grus:</p>
<p align="center"><iframe width="560" height="315" style='' src="https://www.youtube.com/embed/7jiPeIFXb6U" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p></div>
</div>
<span id="document-book/pythonblock/python_l4"></span><div class="section" id="python">
<span id="python-l4"></span><h3>Переменные и вывод информации в Python<a class="headerlink" href="#python" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id1">
<h4>Описание лекции<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>Из этой лекции вы узнаете о:</p>
<ul class="simple">
<li><p>базовых типах данных и переменных;</p></li>
<li><p>простейших операциях с числами и строками;</p></li>
<li><p>функции print;</p></li>
<li><p>выводе информации с подстановкой значений.</p></li>
</ul>
</div>
<div class="section" id="id2">
<h4>Суть переменных в <code class="docutils literal notranslate"><span class="pre">Python</span></code><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>Настало время приступить к изучению непосредственно <code class="docutils literal notranslate"><span class="pre">Python</span></code>, ведь прошло три лекции, а мы об языке программирования и не говорили вовсе! И поскольку наш курс посвящен физике, то начнем со <a class="reference external" href="https://ru.wikipedia.org/wiki/%D0%AD%D0%BA%D0%B2%D0%B8%D0%B2%D0%B0%D0%BB%D0%B5%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C_%D0%BC%D0%B0%D1%81%D1%81%D1%8B_%D0%B8_%D1%8D%D0%BD%D0%B5%D1%80%D0%B3%D0%B8%D0%B8">знакомой всем по школьным карандашам формулы</a> <span class="math notranslate nohighlight">\(E=mc^2\)</span>. По ней можно вычислить полную энергию физического объекта <span class="math notranslate nohighlight">\(E\)</span> с помощью известной массы объекта <span class="math notranslate nohighlight">\(m\)</span> и константы <span class="math notranslate nohighlight">\(c\)</span>. Эта постоянная, указывающая на скорость света в вакууме, используется настолько часто, что для нее выделили <strong>отдельное обозначение в виде буквы латинского алфавита</strong>, как и для многих других аналогичных величин. Если в формуле встречается <span class="math notranslate nohighlight">\(c\)</span> (в известном контексте), то вы всегда уверены, что именно нужно подставить при расчетах.</p>
<p>Этот пример полностью описывает концепцию <strong>переменных</strong> в языках программирования, и <code class="docutils literal notranslate"><span class="pre">Python</span></code> не исключение. Запись <span class="math notranslate nohighlight">\(x = 3\)</span> означает, что везде по тексту далее под иксом подразумевается именно тройка, и ничего другого (пока не будет введено новое определение). Этой же логике подчиняется <code class="docutils literal notranslate"><span class="pre">Python</span></code>. Сначала указывается <strong>имя переменной</strong>, а затем – ассоциируемое с ней значение.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="o">=</span> <span class="mi">299_792_458</span> <span class="c1"># запишем константу, м/с</span>
<span class="n">m</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="c1"># масса некоторого абстрактного объекта, кг</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="n">c</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># вычисляем энергию, Дж</span>

<span class="n">some_variable_1</span> <span class="o">=</span> <span class="mf">10.2</span> <span class="c1"># какая-то другая переменная</span>
<span class="n">m</span> <span class="o">=</span> <span class="mi">12</span>
</pre></div>
</div>
</div>
</div>
<p>Пример кода выше иллюстрирует сразу несколько базовых концепций, которые нужно запомнить:</p>
<ol class="simple">
<li><p>В объявлении переменной нет ничего сложного. Синтаксис и правила интуитивно понятны: это можно делать как в физике/математике, как в учебниках и статьях.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">#</span></code> означает комментарий, то есть произвольный текст, который не воспринимается <code class="docutils literal notranslate"><span class="pre">Python</span></code> (все <strong>до конца строки</strong> кода полностью игнорируется). Служит исключительно для создания подсказок в коде, объяснения происходящего, то есть для удобства.</p></li>
<li><p>Числа могут быть <strong>целыми и вещественными</strong>. Разряды в целых числах для удобства визуального восприятия можно разделять нижней чертой.</p></li>
<li><p><strong>Значение переменной может быть вычислимым</strong>, то есть являться производной от других переменных (как <span class="math notranslate nohighlight">\(E\)</span>, ведь это результат перемножения). На самом деле значение вычисляется в момент объявления переменной (при сложной формуле расчета процесс может занимать некоторое время).</p></li>
<li><p>Операция возведения в квадрат реализуется с помощью <code class="docutils literal notranslate"><span class="pre">**</span></code>.</p></li>
<li><p>В качестве названия переменных можно использовать <strong>буквы и цифры</strong>, а также некоторые символы. Однако <strong>имя переменной не может начинаться с цифры</strong>.</p></li>
<li><p>Переменные можно переопределять (и даже менять тип). Однако <strong>старое значение в этом случае будет безвозвратно утрачено</strong>. В данном примере после выполнения последней строчки нельзя установить, чему было равно <span class="math notranslate nohighlight">\(m\)</span> до того, как переменной было присвоено значение дюжины.</p></li>
</ol>
<p>Если говорить менее строго и более абстрактно, то <strong>переменная – это контейнер</strong> (или коробка), в котором что-то лежит, и на самой коробке на приклеенном листочке бумаги указано содержимое. Чем понятнее надпись, тем легче найти и использовать объект (поэтому переменные с названием из одной буквы воспринимаются плохо, особенно если таких переменных очень много).</p>
<div class="figure align-default" id="box-with-a-name">
<a class="reference internal image-reference" href="../_images/box_with_a_name.png"><img alt="../_images/box_with_a_name.png" src="../_images/box_with_a_name.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-number">Fig. 23 </span><span class="caption-text"><a class="reference external" href="https://stevenpcurtis.medium.com/what-is-a-variable-3447ac1331b9">Объявить переменную – значит положить объект в коробку с подписью</a>.</span><a class="headerlink" href="#box-with-a-name" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="id3">
<h4>Типы переменных<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>В листинге кода выше важно заметить, что существует разница между двумя типами численных переменных: <strong>целые и вещественные</strong>. При сугубо математических расчетах и арифметических операциях тип переменной не имеет значения. Однако для некоторого функционала в <code class="docutils literal notranslate"><span class="pre">Python</span></code> нужно быть аккуратным. Мы поговорим подробно об этом в следующих лекциях, а пока стоит запомнить, что вещи, которые необходимо посчитать – в том числе и <strong>длину</strong> чего-то <em>счетного</em> – должны быть целочисленными (как и в жизни: первый, второй, третий…).</p>
<div class="admonition attention">
<p class="admonition-title">Attention</p>
<p>Целочисленный тип называется <strong>int</strong> (от <code class="docutils literal notranslate"><span class="pre">Integer</span></code>), вещественный – <strong>float</strong>. Эти типы можно переводить из одного в другой. При переводе вещественного числа в целое теряется часть информации.</p>
</div>
<p><strong>Тип переменной</strong> – и это относится не только к числам, но и к <strong>любому</strong> объекту – можно узнать с помощью функции <code class="docutils literal notranslate"><span class="pre">type</span></code>. Для вывода информации в <code class="docutils literal notranslate"><span class="pre">Python</span></code> используется функция <code class="docutils literal notranslate"><span class="pre">print</span></code>. Что именно представляет собой функция мы рассмотрим в более поздних лекциях, пока стоит думать об этом как о некотором объекте, который зависит (рассчитывается) от других объектов и выдает некоторый результат. Для передачи аргументов используются круглые скобки (аналогично математике: <span class="math notranslate nohighlight">\(y = F(x)\)</span>). Давайте скомбинируем эти знания и рассмотрим пример:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">first_variable</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">second_variable</span> <span class="o">=</span> <span class="mf">10.0</span>

<span class="c1"># запишем в переменные значения типов данных</span>
<span class="n">type_of_first_variable</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">first_variable</span><span class="p">)</span>
<span class="n">type_of_second_variable</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">second_variable</span><span class="p">)</span>

<span class="c1"># и распечатаем сами типы, чтобы посмотреть глазами и сравнить</span>
<span class="nb">print</span><span class="p">(</span><span class="n">type_of_first_variable</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">type_of_second_variable</span><span class="p">)</span>

<span class="c1"># перезапишем переменные</span>
<span class="n">first_variable</span> <span class="o">=</span> <span class="mf">12.9</span>
<span class="n">second_variable</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">first_variable</span><span class="p">)</span>
<span class="n">third_variable</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">second_variable</span><span class="p">)</span>

<span class="c1"># в print() можно передавать несколько переменных</span>
<span class="nb">print</span><span class="p">(</span><span class="n">first_variable</span><span class="p">,</span> <span class="n">second_variable</span><span class="p">,</span> <span class="n">third_variable</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;class &#39;int&#39;&gt;
&lt;class &#39;float&#39;&gt;
12.9 12 12.0
</pre></div>
</div>
</div>
</div>
<p>Внимательно проанализируйте код выше – в нем продемонстрирован базовый синтаксис <strong>преобразования типов</strong> и <strong>вывода информации</strong>. Легко увидеть подтверждение высказанных ранее тезисов: <code class="docutils literal notranslate"><span class="pre">second_variable</span></code> действительно потеряла часть информации (дробную часть числа), которую нельзя вернуть, если преобразовать переменную обратно во <code class="docutils literal notranslate"><span class="pre">float</span></code>. Преобразование типов в языках программирования называется <strong>приведением</strong> (типов, то есть привести одно к другому, а не из-за страшилок про духов).</p>
</div>
<div class="section" id="id4">
<h4>Арифметические операции с числами<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>Математика <code class="docutils literal notranslate"><span class="pre">Python</span></code> максимально близка к естественной: <code class="docutils literal notranslate"><span class="pre">+-*</span></code> и <code class="docutils literal notranslate"><span class="pre">**</span></code> (рассмотренное ранее возведение в степень) работают в точности как ожидается. С делением <code class="docutils literal notranslate"><span class="pre">/</span></code> есть нюанс: <strong>возвращаемое значение всегда вещественное</strong>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">b</span> <span class="o">=</span> <span class="mf">12.1</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="c1"># можно объединять вызовы функций print и type</span>
<span class="c1"># без создания лишней переменной</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>

<span class="c1"># и даже трёх функций, включая приведение типа</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="p">)))</span>

<span class="c1"># деление числа на само себя даёт единицу, но..</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">a</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">b</span> <span class="o">/</span> <span class="n">b</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">c</span> <span class="o">/</span> <span class="n">c</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="mi">12</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;class &#39;float&#39;&gt;
&lt;class &#39;int&#39;&gt;
1.0
1.0
1.0
3.0
</pre></div>
</div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Обратите внимание, что операции не изменяют переменную саму по себе (то есть операция <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span></code> не меняет ни <code class="docutils literal notranslate"><span class="pre">a</span></code>, ни <code class="docutils literal notranslate"><span class="pre">b</span></code>). Чтобы сохранить получаемое значение, нужно присвоить его некоторой переменной (в примере выше это <code class="docutils literal notranslate"><span class="pre">c</span></code>). Если вы хотите изменить непосредственно саму переменную, то можно переприсвоить ей значение на основе расчёта: <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span></code> или <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">c</span> <span class="pre">+</span> <span class="pre">12</span></code>.</p>
</div>
<p>Даже несмотря на то, что кейс с делением числа на само себя очевиден (всегда получается единица, кроме деления на нуль), будет выведено вещественное значение.
Сами же вещественные значения можно складывать, вычитать, умножать и возводить в степень как с целыми, так и с вещественными числами (и наоборот). Если в таком выражении используется хотя бы одна <code class="docutils literal notranslate"><span class="pre">float</span></code>-переменная, то и результат будет не целочисленным. Однако:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">2</span>

<span class="nb">print</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span> <span class="o">**</span> <span class="n">b</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span> <span class="o">**</span> <span class="n">b</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>5 &lt;class &#39;int&#39;&gt;
6 &lt;class &#39;int&#39;&gt;
9 &lt;class &#39;int&#39;&gt;
</pre></div>
</div>
</div>
</div>
<p>Это <em>практически</em> все тонкости, которые необходимо знать, чтобы не совершать базовые ошибки.</p>
<div class="section" id="id5">
<h5>Примечание<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h5>
<p>Возможно, у вас родился вопрос относительно расстановки пробелов в коде выше. Обязательно ли соблюдать такой синтаксис? Нужно ли ставить пробелы до и после знаков операций? На самом деле нет: это делается исключительно для удобства чтения кода и <strong>настоятельно рекомендуется не удаляться от стандартов языка</strong>. Код ниже выполнится без ошибок, однако ухудшается читаемость:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="o">=</span>            <span class="mi">3</span>
<span class="n">b</span>    <span class="o">=</span><span class="mi">2</span>

<span class="nb">print</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span><span class="n">b</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="o">+</span> <span class="n">b</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span>     <span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="n">b</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="n">b</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span>        <span class="o">**</span> <span class="n">b</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>5 &lt;class &#39;int&#39;&gt;
6 &lt;class &#39;int&#39;&gt;
9 &lt;class &#39;int&#39;&gt;
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="id6">
<h4>Строковые переменные<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<p>Мы разобрались в том, как описывать и хранить числа, как производить арифметические расчеты. Базовый математический язык освоен, но мы же люди, и хочется общаться словами! Конечно, <code class="docutils literal notranslate"><span class="pre">Python</span></code> позволяет это делать. Благодаря <strong>строковым переменным</strong> можно хранить и соединять текстовую информацию:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">text_variable</span> <span class="o">=</span> <span class="s1">&#39;тут что-то написано&#39;</span>
<span class="n">another_text_variable</span> <span class="o">=</span> <span class="s2">&quot;Вася, впиши сюда что-нибудь перед публикацией курса!&quot;</span>

<span class="n">long_text</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut</span>
<span class="s1">labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris</span>
<span class="s1">nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit</span>
<span class="s1">esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt</span>
<span class="s1">in culpa qui officia deserunt mollit anim id est laborum.</span>
<span class="s1">&#39;&#39;&#39;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">another_text_variable</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Вася, впиши сюда что-нибудь перед публикацией курса!
</pre></div>
</div>
</div>
</div>
<p>В примере выше рассмотрено три способа создания текстовых переменных. Первые два не отличаются между собой с точки зрения <code class="docutils literal notranslate"><span class="pre">Python</span></code>, то есть неважно, используете ли вы одинарные кавычки <code class="docutils literal notranslate"><span class="pre">'</span></code> или двойные <code class="docutils literal notranslate"><span class="pre">&quot;</span></code>. Однако стоит понимать, что если ваша строка содержит в себе такой символ, то кавычка должна быть изменена:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>error_string = &#39;Chillin&#39; kid&#39;
another_error_string = &quot;И тут он мне говорит: &quot;у тебя нет ног!&quot;&quot;

print(error_string)
print(another_error_string)
</pre></div>
</div>
<p>Механизм ошибки таков, что <code class="docutils literal notranslate"><span class="pre">Python</span></code> неясно: это вы закончили строчку и дальше идет какая-то команда, или же строчка продолжается. В обоих случаях <strong>нужно сменить способ создания строки</strong> – и тогда все будет хорошо:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">error_string</span> <span class="o">=</span> <span class="s2">&quot;Chillin&#39; kid&quot;</span>
<span class="n">another_error_string</span> <span class="o">=</span> <span class="s1">&#39;И тут он мне говорит: &quot;у тебя нет ног!&quot;&#39;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">error_string</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">another_error_string</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Chillin&#39; kid
И тут он мне говорит: &quot;у тебя нет ног!&quot;
</pre></div>
</div>
</div>
</div>
<p>Если необходимо сохранить какой-либо объемный текст или сообщение, можно воспользоваться мультистрочным объявлением переменной, как в первом примере блока.</p>
<p>Строки можно объединять для удобства вывода информации:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">first_string</span> <span class="o">=</span> <span class="s1">&#39;Результат вычислений: &#39;</span>
<span class="n">second_string</span> <span class="o">=</span> <span class="s2">&quot;. Это не так много!&quot;</span>

<span class="n">a</span> <span class="o">=</span> <span class="mi">12</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>

<span class="c1"># два способа вывода:</span>
<span class="nb">print</span><span class="p">(</span><span class="n">first_string</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">second_string</span><span class="p">)</span>

<span class="c1"># либо через склейку строк вручную</span>
<span class="c1"># обратите внимание на приведение типа int к str</span>
<span class="n">result_string</span> <span class="o">=</span> <span class="n">first_string</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">+</span> <span class="n">second_string</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result_string</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Результат вычислений:  24 . Это не так много!
Результат вычислений: 24. Это не так много!
</pre></div>
</div>
</div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Будьте аккуратны со сложением строк. Объединение строк <code class="docutils literal notranslate"><span class="pre">&quot;3&quot;</span></code> и <code class="docutils literal notranslate"><span class="pre">&quot;5&quot;</span></code> даст результат <code class="docutils literal notranslate"><span class="pre">&quot;35&quot;</span></code>, а не <code class="docutils literal notranslate"><span class="pre">8</span></code> – и тип результирующего значения <strong>будет строковый</strong>. <strong>Сложить строку и число нельзя</strong>: вы получите ошибку и никакого приведения типов не произойдет. Здесь возникнет двусмысленность – нужно привести число к строке и затем сконкатенировать или же строку к числу (а вдруг это невозможно?), после чего сложить.</p>
</div>
<p>Склеивание строк называется <strong>конкатенацией</strong>. Попробуйте в <code class="docutils literal notranslate"><span class="pre">Jupyter</span></code>-ноутбуке объединить строковые, целочисленные и вещественные переменные в разных комбинациях. Разберитесь, что означает ошибка, которая будет выведена в случае, если не делать приведение типов (то есть без <code class="docutils literal notranslate"><span class="pre">str</span></code> в <code class="docutils literal notranslate"><span class="pre">str(result)</span></code>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Обратите внимание на пробел между числом и точкой в первом случае. Они добавлены автоматически функцией <code class="docutils literal notranslate"><span class="pre">print</span></code> – это сделано для того, чтобы разные объекты при последовательном выводе не “склеивались” друг с другом.
Во втором случае этого не происходит, так как мы напрямую склеиваем строки и только затем передаем результат конкатенации на печать в <code class="docutils literal notranslate"><span class="pre">print</span></code>.</p>
</div>
<p>Но на практике это не совсем удобно, поэтому в <code class="docutils literal notranslate"><span class="pre">Python</span></code> придумали <code class="docutils literal notranslate"><span class="pre">F</span></code>-строки. Их суть в том, что переменная из кода напрямую подставляется (с автоматическим приведением типа к строке) в саму строку! Вот:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="mi">12</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>

<span class="n">result_string</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Результат вычислений: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s1">. Это не так много!&#39;</span>

<span class="c1"># и без f</span>
<span class="n">wrong_result_string</span> <span class="o">=</span> <span class="s1">&#39;Результат вычислений: </span><span class="si">{result}</span><span class="s1">. Это не так много!&#39;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">result_string</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">wrong_result_string</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Результат вычислений: 24. Это не так много!
Результат вычислений: {result}. Это не так много!
</pre></div>
</div>
</div>
</div>
<p>Для объявления <code class="docutils literal notranslate"><span class="pre">F</span></code>-строки нужно, во-первых, использовать одинаковые кавычки на концах текста. Во-вторых, нужно указать литеру <code class="docutils literal notranslate"><span class="pre">f</span></code> перед самой строкой. И последнее – нужно обрамить название конкретной переменной (<code class="docutils literal notranslate"><span class="pre">result</span></code> в данном случае) в фигурные скобки.</p>
<p>Когда переменная одна, а также нет текста после ее использования, то выгода <code class="docutils literal notranslate"><span class="pre">F</span></code>-строк не так очевидна (относительно простого <code class="docutils literal notranslate"><span class="pre">print(some_string,</span> <span class="pre">some_variable)</span></code>). Однако представьте, что вам нужно вывести координаты точки в трехмерном пространстве, значение времени, параметры системы и значение некоторой функции от всех переменных выше!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># так тоже можно!</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="mf">12.1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">13</span>
<span class="c1"># скобки, как и в математике, задают порядок выполнения вычислений</span>
<span class="n">func_val</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="o">**</span> <span class="n">z</span>

<span class="n">current_time</span> <span class="o">=</span> <span class="mf">30.113412</span>

<span class="c1"># а вот так можно писать длинные f-строки (но работает и для обычных)</span>
<span class="n">out_string</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;В точке с координатами X=</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1">, Y=</span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s1">, Z=</span><span class="si">{</span><span class="n">z</span><span class="si">}</span><span class="s1"> значение функции &#39;</span>
              <span class="sa">f</span><span class="s1">&#39;равно </span><span class="si">{</span><span class="n">func_val</span><span class="si">}</span><span class="s1">. Состояние системы указано на момент &#39;</span>
              <span class="s1">&#39; времени t=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">current_time</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="n">out_string</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>В точке с координатами X=12.1, Y=0, Z=13 значение функции равно 0.0. Состояние системы указано на момент  времени t=30.113412
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id7">
<h4>Что мы узнали из лекции<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><strong>Переменные – это “контейнеры”</strong>, в которые можно что-то положить и дать название.</p></li>
<li><p>Математика в <code class="docutils literal notranslate"><span class="pre">Python</span></code> не имеет сложных правил, процесс вычислений максимально интуитивен.</p></li>
<li><p>Арифметические операции могут <strong>менять тип</strong> результирующей переменной.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">type()</span></code>, <code class="docutils literal notranslate"><span class="pre">print()</span></code> – базовые функции, с помощью которых можно делать <strong>самопроверки</strong> по ходу написания кода.</p></li>
<li><p><strong>Сменить тип</strong> переменной можно вызовом функций <code class="docutils literal notranslate"><span class="pre">int()</span></code>, <code class="docutils literal notranslate"><span class="pre">float()</span></code>, <code class="docutils literal notranslate"><span class="pre">str()</span></code>.</p></li>
<li><p>Строки могут обрамляться как <code class="docutils literal notranslate"><span class="pre">'</span></code>, так и <code class="docutils literal notranslate"><span class="pre">&quot;</span></code> (но этих символов <strong>не должно быть внутри</strong> текста).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">F</span></code>-строки облегчают комплексный вывод, содержащий как текст, так и переменные <code class="docutils literal notranslate"><span class="pre">Python</span></code> (и автоматически приводит типы).</p></li>
</ul>
</div>
</div>
<span id="document-book/pythonblock/python_l5"></span><div class="section" id="python-l5">
<span id="id1"></span><h3>Условные конструкции, булева логика и сравнения<a class="headerlink" href="#python-l5" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id2">
<h4>Описание лекции<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>В этой лекции мы расскажем про:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">if</span></code>/<code class="docutils literal notranslate"><span class="pre">else</span></code>-конструкции и условия;</p></li>
<li><p>тип <code class="docutils literal notranslate"><span class="pre">bool</span></code>;</p></li>
<li><p>операторы сравнения;</p></li>
<li><p>блоки кода и отступы.</p></li>
</ul>
</div>
<div class="section" id="id3">
<h4>Ветвление логики<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>В прошлых лекциях мы рассмотрели программы с линейной структурой: сначала выполнялась первая конструкция (например, объявление переменной), затем вторая (преобразование переменной или расчет по формуле), после – третья (<code class="docutils literal notranslate"><span class="pre">print</span></code> для вывода результатов). Можно сказать, что происходило последовательное исполнение команд, причем каждая инструкция выполнялась <strong>обязательно</strong>. Но что делать, если хочется опираться на обстоятельства и принимать решения о том, выполнять одну часть кода или другую?</p>
<p>Допустим, по числу <code class="docutils literal notranslate"><span class="pre">x</span></code> нужно определить его абсолютную величину, то есть модуль. Программа должна напечатать значение переменной <code class="docutils literal notranslate"><span class="pre">x</span></code>, если <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> или же величину <code class="docutils literal notranslate"><span class="pre">-x</span></code> в противном случае (<code class="docutils literal notranslate"><span class="pre">-(-5)</span> <span class="pre">=</span> <span class="pre">5</span></code>). Эту логику можно записать следующим образом:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span>  <span class="c1"># попробуйте поменять значение переменной</span>

<span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Исходный x больше нуля&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Исходный x меньше или равен нулю&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Исходный x меньше или равен нулю
3
</pre></div>
</div>
</div>
</div>
<p>В этой программе используется условная инструкция <code class="docutils literal notranslate"><span class="pre">if</span></code> (в переводе с английского <em>“если”</em>). <code class="docutils literal notranslate"><span class="pre">if</span></code> – это ключевое зарезервированное слово (так <em>нельзя назвать свою переменную</em>), указывающее на <strong>условную конструкцию</strong>. После <code class="docutils literal notranslate"><span class="pre">if</span></code> следует указать вычислимое выражение, которое <strong>можно проверить на истинность</strong> (то есть можно сказать, правда это или нет). Общий вид конструкции следующий:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">Условие</span><span class="p">):</span>
    <span class="o">&lt;</span><span class="n">Блок</span> <span class="n">инструкций</span> <span class="mi">1</span><span class="o">&gt;</span>
<span class="k">else</span><span class="p">:</span>
    <span class="o">&lt;</span><span class="n">Блок</span> <span class="n">инструкций</span> <span class="mi">2</span><span class="o">&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">else</span></code> – тоже ключевое слово (в переводе – <em>“иначе”</em>). Таким образом, можно в голове придерживаться такой интерпретации: “<strong>если</strong> условие верно (истинно), <strong>то</strong> выполни первый блок команд, <strong>иначе</strong> выполни второй блок”.</p>
<p>Условная инструкция содержит как минимум ключевое слово <code class="docutils literal notranslate"><span class="pre">if</span></code> (единожды), затем может идти любое количество (включая ноль) блоков с условием <code class="docutils literal notranslate"><span class="pre">else</span> <span class="pre">if</span> <span class="pre">&lt;условие&gt;</span></code> (<em>иначе если</em>, то есть будет выполнена проверка нового условия в случае, если первая проверка в <code class="docutils literal notranslate"><span class="pre">if</span></code> не прошла), затем – опционально – конструкция <code class="docutils literal notranslate"><span class="pre">else</span></code>. Логика чтения и выполнения кода сохраняет порядок <strong>сверху вниз</strong>. Как только одно из условий будет выполнено, выполнится соответствующая инструкция (или набор инструкций), а все последующие блоки будут проигнорированы. Это проиллюстрировано в коде:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mf">3.8</span>  <span class="c1"># попробуйте поменять значение переменной</span>

<span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;x больше нуля&#39;</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># можно написать &quot;else if x &lt; 0:&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;x меньше нуля&#39;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;x в точности равен нулю&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Такие дела!&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>x меньше нуля
Такие дела!
</pre></div>
</div>
</div>
</div>
<p>Понятно, что <code class="docutils literal notranslate"><span class="pre">x</span></code> не может одновременно быть и больше нуля, и меньше (или равен ему). Среди всех трех <code class="docutils literal notranslate"><span class="pre">print</span></code>-блоков будет выполнен <strong>только один</strong>. Если <code class="docutils literal notranslate"><span class="pre">x</span></code> действительно больше нуля, то второе условие (<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">0</span></code>) даже не будет проверяться – <code class="docutils literal notranslate"><span class="pre">Python</span></code> сразу же перейдет к последней строке и выведет надпись “Такие дела!”.</p>
<p>Чтобы лучше разобраться в том, как работает код, можно использовать <strong>визуализаторы</strong> – например, <a class="reference external" href="https://pythontutor.com/visualize.html#mode=edit">такой</a>. Прогоняйте через него весь код (даже в несколько строк) и сверяйте со своими ожиданиями от его работы.</p>
</div>
<div class="section" id="id4">
<h4>А что вообще такое эти ваши условия?<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>Выше было указано, что после конструкций <code class="docutils literal notranslate"><span class="pre">if</span></code>/<code class="docutils literal notranslate"><span class="pre">else</span> <span class="pre">if</span></code> необходимо указать <strong>условие</strong>, которое еще и должно быть истинным или ложным (“правда или нет”). Давайте попробуем определить необходимый <strong>тип</strong> переменной.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mf">3.8</span>

<span class="n">condition_1</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="n">condition_2</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span>

<span class="nb">print</span><span class="p">(</span><span class="n">condition_1</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">condition_1</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">condition_2</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">condition_2</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>False &lt;class &#39;bool&#39;&gt;
True &lt;class &#39;bool&#39;&gt;
</pre></div>
</div>
</div>
</div>
<p>Видно, что оба условия имеют один и тот же тип - <code class="docutils literal notranslate"><span class="pre">bool</span></code>, то есть <code class="docutils literal notranslate"><span class="pre">boolean</span></code>. По <a class="reference external" href="https://developer.mozilla.org/ru/docs/Glossary/Boolean">определению</a>:</p>
<blockquote>
<div><p>Boolean (Булев, Логический тип данных) – примитивный тип данных в информатике, которые могут принимать <strong>два возможных значения</strong>, иногда называемых истиной (True) и ложью (False).</p>
</div></blockquote>
<p>Оказывается, что в коде выше мы получили <strong>ВСЕ</strong> возможные варианты булевой переменной – это истина (<code class="docutils literal notranslate"><span class="pre">True</span></code>, пишется только с заглавной буквы) и ложь (<code class="docutils literal notranslate"><span class="pre">False</span></code>, аналогично). Никаких других значений быть для условия не может. Вот такой это простой тип данных.</p>
</div>
<div class="section" id="bool">
<h4>Способы получения <code class="docutils literal notranslate"><span class="pre">bool</span></code><a class="headerlink" href="#bool" title="Permalink to this headline">¶</a></h4>
<p>Какими вообще могут быть условия? Как с ними можно обращаться? Согласно <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html">официальной документации</a>, в <code class="docutils literal notranslate"><span class="pre">Python</span></code> есть такие операторы сравнения:</p>
<div class="figure align-default" id="operators-table">
<a class="reference internal image-reference" href="../_images/operators_table.png"><img alt="../_images/operators_table.png" src="../_images/operators_table.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-number">Fig. 24 </span><span class="caption-text">Все операции сравнения работают нативно (так же, как и в математике)</span><a class="headerlink" href="#operators-table" title="Permalink to this image">¶</a></p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="mf">3.0</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="mf">3.0</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>False
True
</pre></div>
</div>
</div>
</div>
<p>Здесь практически нечего рассматривать, операторы сравнения они и в <code class="docutils literal notranslate"><span class="pre">Python</span></code> операторы. Куда интереснее принцип <strong>объединения различных условий в одно</strong> – для создания комплексной логики.</p>
<p>Пусть стоит задача определения четверти точки по ее координатам на двумерной плоскости. Решение такой задачи может быть записано следующим образом:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mf">3.6</span>
<span class="n">y</span> <span class="o">=</span> <span class="mf">2.5432</span>

<span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># x &gt; 0, y &gt; 0</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Первая четверть&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># x &gt; 0, y &lt; 0</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Четвертая четверть&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># x &lt; 0, y &gt; 0</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Вторая четверть&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># x &lt; 0, y &lt; 0</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Третья четверть&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Вторая четверть
</pre></div>
</div>
</div>
</div>
<p>Пример показывает, что выполняемым блоком кода может быть любой блок <code class="docutils literal notranslate"><span class="pre">Python</span></code>, включая новый логический блок с <code class="docutils literal notranslate"><span class="pre">if-else</span></code> конструкцией. Однако его можно сократить с помощью <strong>логических операторов</strong> <code class="docutils literal notranslate"><span class="pre">and</span></code>, <code class="docutils literal notranslate"><span class="pre">or</span></code> и <code class="docutils literal notranslate"><span class="pre">not</span></code>. Это стандартные логические операторы <a class="reference external" href="https://ru.wikipedia.org/wiki/%D0%91%D1%83%D0%BB%D0%B5%D0%B2%D0%B0_%D0%B0%D0%BB%D0%B3%D0%B5%D0%B1%D1%80%D0%B0">Булевой алгебры</a>.</p>
<p>Логическое <strong>И</strong> является бинарным оператором (то есть оператором с двумя операндами: левым и правым) и имеет вид <code class="docutils literal notranslate"><span class="pre">and</span></code>. Оператор <code class="docutils literal notranslate"><span class="pre">and</span></code> возвращает <code class="docutils literal notranslate"><span class="pre">True</span></code> тогда и только тогда, когда <strong>оба его операнда имеют значение</strong> <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<p>Логическое <strong>ИЛИ</strong> является бинарным оператором и возвращает <code class="docutils literal notranslate"><span class="pre">True</span></code> тогда и только тогда, когда <strong>хотя бы один операнд равен</strong> <code class="docutils literal notranslate"><span class="pre">True</span></code>. Оператор “логическое ИЛИ” имеет вид <code class="docutils literal notranslate"><span class="pre">or</span></code>.</p>
<p>Логическое <strong>НЕ</strong> (отрицание) является унарным (то есть <strong>с одним операндом</strong>) оператором и имеет вид <code class="docutils literal notranslate"><span class="pre">not</span></code>, за которым следует единственный операнд. Логическое НЕ возвращает <code class="docutils literal notranslate"><span class="pre">True</span></code>, <strong>если операнд равен</strong> <code class="docutils literal notranslate"><span class="pre">False</span></code> и <strong>наоборот</strong>.</p>
<p>Эти правила необходимо запомнить для успешного создания сложных условий с целью разделения логики, заложенной в <code class="docutils literal notranslate"><span class="pre">Python</span></code>-коде.</p>
<p>Проиллюстрируем правила в коде на простых примерах. Обратите внимание на то, как можно объявлять <code class="docutils literal notranslate"><span class="pre">bool</span></code>-переменные – это не сложнее, чем создание целочисленного значения:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">true_value</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">false_value</span> <span class="o">=</span> <span class="kc">False</span>

<span class="c1"># False потому, что один из операндов является False</span>
<span class="n">some_value</span> <span class="o">=</span> <span class="n">true_value</span> <span class="ow">and</span> <span class="n">false_value</span>
<span class="nb">print</span><span class="p">(</span><span class="n">some_value</span><span class="p">)</span>

<span class="c1"># True потому, что хотя бы один из операндов равен True</span>
<span class="n">some_value</span> <span class="o">=</span> <span class="n">true_value</span> <span class="ow">or</span> <span class="n">false_value</span>
<span class="nb">print</span><span class="p">(</span><span class="n">some_value</span><span class="p">)</span>

<span class="c1"># отрицание True (истины) есть False (ложь)</span>
<span class="n">some_value</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">true_value</span>
<span class="nb">print</span><span class="p">(</span><span class="n">some_value</span> <span class="o">==</span> <span class="n">false_value</span><span class="p">)</span>

<span class="c1"># пример сложного условия - порядок лучше в явном виде задавать скобками</span>
<span class="n">hard_condition</span> <span class="o">=</span> <span class="p">(</span><span class="ow">not</span> <span class="n">true_value</span> <span class="ow">or</span> <span class="n">false_value</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">true_value</span> <span class="o">!=</span> <span class="n">false_value</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">hard_condition</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>False
True
True
True
</pre></div>
</div>
</div>
</div>
<p>Теперь попробуем их применить на приближенных к практике примерах:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mf">3.6</span>
<span class="n">y</span> <span class="o">=</span> <span class="mf">2.5432</span>

<span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># конструкция заменяет два вложенных if</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Первая четверть&quot;</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Четвертая четверть&quot;</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Вторая четверть&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Третья четверть&quot;</span><span class="p">)</span>

<span class="c1"># определим, большое ли число x (в терминах модуля)</span>
<span class="n">x_is_small</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="c1"># число большое, если оно не маленькое (по модулю)</span>
<span class="n">x_is_large</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">x_is_small</span>  <span class="c1"># можно отрицать факт малости x</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Is x small? &#39;</span><span class="p">,</span> <span class="n">x_is_small</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Is x large? &#39;</span><span class="p">,</span> <span class="n">x_is_large</span><span class="p">)</span>

<span class="c1"># так тоже можно писать - на манер неравенств в математике</span>
<span class="n">another_x_is_small</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">3</span>
<span class="nb">print</span><span class="p">(</span><span class="n">another_x_is_small</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">another_x_is_small</span> <span class="o">==</span> <span class="n">x_is_small</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Вторая четверть
Is x small?  False
Is x large?  True
False
True
</pre></div>
</div>
</div>
</div>
<p>Так как вторая переменная <code class="docutils literal notranslate"><span class="pre">x_is_large</span></code> – это отрицание (<code class="docutils literal notranslate"><span class="pre">not</span></code>) первой (<code class="docutils literal notranslate"><span class="pre">x_is_small</span></code>), то они <strong>никогда</strong> не будут равны.</p>
</div>
<div class="section" id="id5">
<h4>Блоки кода и отступы<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>В примерах выше вы наверняка заметили упоминание термина “блок кода”, а также откуда-то взявшиеся отступы после условий, и это не случайно. Во-первых, давайте признаем, что так условные конструкции (особенно вложенные!) читать куда легче, и глаза не разбегаются. Во-вторых, это особенность языка <code class="docutils literal notranslate"><span class="pre">Python</span></code> – здесь не используются скобки <code class="docutils literal notranslate"><span class="pre">{}</span></code> для указания блоков, все форматирование происходит с помощью отступов. Отступы <strong>всегда</strong> добавляются в строки кода <strong>после двоеточия</strong>.</p>
<p>Для выделения блока инструкций (строк кода, выполняющихся подряд при любых условиях), относящихся к инструкциям <code class="docutils literal notranslate"><span class="pre">if</span></code>, <code class="docutils literal notranslate"><span class="pre">else</span></code> или другим, изучаемым далее, в языке <code class="docutils literal notranslate"><span class="pre">Python</span></code> используются <strong>отступы</strong>. Все инструкции, которые относятся к одному блоку, должны иметь <strong>равную величину отступа</strong>, то есть одинаковое число <strong>пробелов в начале строки</strong>. В качестве отступа <a class="reference external" href="https://www.python.org/dev/peps/pep-0008/#tabs-or-spaces">PEP 8</a> рекомендует использовать <strong>отступ в четыре пробела</strong> и не рекомендует использовать символ табуляции. Если нужно сделать еще одно вложение блока инструкций, достаточно добавить еще четыре пробела (см. пример выше с поиском четверти на плоскости).</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Хоть и не рекомендуется использовать символ табуляции для создания отступов, кнопка <code class="docutils literal notranslate"><span class="pre">Tab</span></code> на вашей клавиатуре в <code class="docutils literal notranslate"><span class="pre">Jupyter</span></code>-ноутбуке (при курсоре, указывающим на начало строки кода) создаст отступ в четыре пробела. Пользуйтесь этим, чтобы не перегружать клавишу пробела лишними постукиваниями :).</p>
</div>
</div>
<div class="section" id="id6">
<h4>Что мы узнали из лекции<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>Для задания логики выполнения кода и создания нелинейности используются <strong>условные инструкции</strong>, поскольку они следуют некоторым условиям.</p></li>
<li><p>Условная инструкция задается ключевым словом <code class="docutils literal notranslate"><span class="pre">if</span></code>, после которого может следовать несколько (от нуля) блоков <code class="docutils literal notranslate"><span class="pre">else</span> <span class="pre">if</span></code>/<code class="docutils literal notranslate"><span class="pre">elif</span></code>, и – опционально – в конце добавляется <code class="docutils literal notranslate"><span class="pre">else</span></code>, если ни один из блоков выше не сработал.</p></li>
<li><p>Условия должны быть <strong>булевого типа</strong> (<code class="docutils literal notranslate"><span class="pre">bool</span></code>) и могут принимать <strong>всего два значения</strong> – <code class="docutils literal notranslate"><span class="pre">True</span></code> и <code class="docutils literal notranslate"><span class="pre">False</span></code>. Выполнится тот блок кода, который задан истинным (<code class="docutils literal notranslate"><span class="pre">True</span></code>) условием (и только первый!).</p></li>
<li><p>Условные конструкции можно вкладывать друг в друга, а также объединять с помощью <strong>логических операторов</strong> <code class="docutils literal notranslate"><span class="pre">and</span></code>, <code class="docutils literal notranslate"><span class="pre">or</span></code> и <code class="docutils literal notranslate"><span class="pre">not</span></code>.</p></li>
<li><p><strong>Блок кода</strong> – это несколько подряд идущих команд, которые будут выполнены последовательно.</p></li>
<li><p>Чтобы выделить блок кода после условия, используйте <strong>отступы</strong> – четыре пробела.</p></li>
<li><p>Чтобы создать отступ в <code class="docutils literal notranslate"><span class="pre">Jupter</span></code>, нужно нажать <code class="docutils literal notranslate"><span class="pre">Tab</span></code> в начале строки кода.</p></li>
</ul>
</div>
</div>
<span id="document-book/pythonblock/python_l6"></span><div class="section" id="python">
<span id="python-l6"></span><h3>Списки и циклы в Python<a class="headerlink" href="#python" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id1">
<h4>Описание лекции<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>На этом занятии мы разберем следующие темы:</p>
<ul class="simple">
<li><p>списки (<code class="docutils literal notranslate"><span class="pre">list</span></code>) и их методы;</p></li>
<li><p>индексация списков;</p></li>
<li><p>что такое срезы и зачем они нужны;</p></li>
<li><p>цикл <code class="docutils literal notranslate"><span class="pre">for</span></code> и функция <code class="docutils literal notranslate"><span class="pre">range</span></code>;</p></li>
<li><p>итерация по спискам, list comprehensions.</p></li>
</ul>
</div>
<div class="section" id="id2">
<h4>Введение в списки объектов<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>В предыдущих лекциях мы оперировали малым количеством переменных. Для каждого блока логики или примера кода вводилось 3-5 объектов, над которыми осуществлялись некоторые операции. Но что делать, если объектов куда больше? Скажем, вам необходимо хранить информацию об учащихся класса – пусть это будет рост, оценка по математике или что-либо другое. Не знаю, как вы, но я нахожу крайне неудобным создание 30 отдельных переменных. А если еще и нужно посчитать среднюю оценку в классе!</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">average_grade</span> <span class="o">=</span> <span class="n">petrov_math</span> <span class="o">+</span> <span class="n">kosareva_math</span> <span class="o">+</span> <span class="n">zinchenko_math</span> <span class="o">+</span> <span class="n">kotenkov_math</span> <span class="o">+</span> <span class="o">...</span>
<span class="n">average_grade</span> <span class="o">=</span> <span class="n">average_grade</span> <span class="o">/</span> <span class="mi">30</span>
</pre></div>
</div>
<p>Такой код к тому же получается крайне негибким: если количество студентов, как и их состав, изменится, то нужно и формулу переписать, так еще и делитель – в нашем случае 30 – изменять.</p>
<p>Часто в программах – даже в (квантовом) машинном обучении – приходится работать с большим количеством <strong>однотипных</strong> переменных. Специально для этого придуманы <strong>массивы</strong> (по-английски array). В Python их еще называют <strong>списками</strong> (list). В некоторых языках программирования эти понятия отличаются, но не в Python. Список может хранить переменные <strong>разного</strong> типа. Также списки называют “(контейнерами)[https://ru.wikipedia.org/wiki/Контейнер_(программирование)]”, так как они хранят какой-то набор данных. Для создания простого списка необходимо указать квадратные скобки или вызвать конструктор типа (<code class="docutils literal notranslate"><span class="pre">list</span></code> – это отдельный тип, фактически такой же, как int или str), а затем перечислить <strong>объекты через запятую</strong>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># разные способы объявления списков</span>
<span class="n">first_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">second_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="n">third_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;stroka&quot;</span><span class="p">,</span> <span class="mf">3.14</span><span class="p">])</span>
<span class="n">fourth_lust</span> <span class="o">=</span> <span class="p">[</span><span class="mi">15</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;another_list&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">]]</span>

<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">second_list</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">fourth_lust</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">first_list</span><span class="p">,</span> <span class="n">fourth_lust</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;class &#39;list&#39;&gt; &lt;class &#39;list&#39;&gt;
[] [15, 2.2, [&#39;another_list&#39;, False]]
</pre></div>
</div>
</div>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Хоть список и хранит переменные разного типа, но так делать без особой необходимости не рекомендуется – вы сами скорее запутаетесь и ошибетесь в обработке объектов списка. В большинстве других языков прогрммирования массив может хранить только объекты одного типа.</p>
<p>Для хранения сложных структур (скажем, описание студента – это не только оценка по математике, но и фамилия, имя, адрес, рост и так далее) лучше использовать классы – с ними мы познакомимся в будущем. А еще могут пригодиться <strong>кортежи</strong>, или <code class="docutils literal notranslate"><span class="pre">tuple</span></code>. Про них в лекции не рассказано, самостоятельно можно ознакомиться <a class="reference external" href="https://pythonworld.ru/tipy-dannyx-v-python/kortezhi-tuple.html">по ссылке</a>.</p>
</div>
<p>Теперь можно один раз создать список и работать с ним как с единым целым. Да, по прежнему для заведения оценок студентов придется разово их зафиксировать, но потом куда проще исправлять и добавлять! Рассмотрим пример нахождения средней оценки группы, в которой всего 3 учащихся, но к ним присоединили еще 2, а затем – целых 5:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># базовый журнал с тремя оценками</span>
<span class="n">math_journal</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>

<span class="c1"># добавим новопришедших студентов</span>
<span class="n">math_journal</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">math_journal</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># и сразу большую группу новых студентов</span>
<span class="n">math_journal</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">math_journal</span> <span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># найдем среднюю оценку как сумму всех оценок, деленную на их количество</span>
<span class="n">avg_grade</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">math_journal</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">math_journal</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">avg_grade</span> <span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>math_journal = [3, 3, 5, 4, 5, 2, 3, 4, 5, 5]
avg_grade = 3.9
</pre></div>
</div>
</div>
</div>
<p>В коде выше продемонстрировано сразу несколько важных аспектов:</p>
<ol class="simple">
<li><p>Добавлять по одному объекту в конец списка можно с помощью метода списка <code class="docutils literal notranslate"><span class="pre">append</span></code>;</p></li>
<li><p>Метод <code class="docutils literal notranslate"><span class="pre">append</span></code> принимает в качестве аргумента один Python-объект;</p></li>
<li><p>Слияние списков (конкатенация, прямо как при работе со строками) нескольких осуществляется командой <code class="docutils literal notranslate"><span class="pre">extend</span></code> (расширить в переводе с английского);</p></li>
<li><p>Для списков определена функция <code class="docutils literal notranslate"><span class="pre">len</span></code>, которая возвращает целое число <code class="docutils literal notranslate"><span class="pre">int</span></code> – количество объектов в списке;</p></li>
<li><p>Функция <code class="docutils literal notranslate"><span class="pre">sum</span></code> может применяться к спискам для суммирования всех объектов (если позволяет тип – то есть для <code class="docutils literal notranslate"><span class="pre">float</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span></code> и <code class="docutils literal notranslate"><span class="pre">bool</span></code>. Попробуйте разобраться самостоятельно, как функция работает с последним указанным типом);</p></li>
<li><p>Для методов <code class="docutils literal notranslate"><span class="pre">append</span></code> и <code class="docutils literal notranslate"><span class="pre">extend</span></code> не нужно приравнивать результат выполнения какой-то переменной – изменится сам объект, у которого был вызван метод (в данном случае это <code class="docutils literal notranslate"><span class="pre">math_journal</span></code>);</p></li>
<li><p>Списки в Python <strong>упорядочены</strong>, то есть объекты сами по себе места не меняют, и помнят, в каком порядке были добавлены в массив.</p></li>
</ol>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>В тексте выше встречается термин <strong>метод</strong>, который, быть может, вам не знаком. По сути метод – это такая же <strong>функция</strong>, о которых мы говорили раньше, но она принадлежит какому-то объекту с определенным типом. Не переживайте, если что-то непонятно – про функции и методы мы поговорим подробно в ближайших лекциях!</p>
<p><code class="docutils literal notranslate"><span class="pre">print</span></code>, <code class="docutils literal notranslate"><span class="pre">sum</span></code> – функции, они существуют сами по себе;
<code class="docutils literal notranslate"><span class="pre">append</span></code>, <code class="docutils literal notranslate"><span class="pre">extend</span></code> – методы объектов класса <code class="docutils literal notranslate"><span class="pre">list</span></code>, не могут использоваться без них.</p>
</div>
</div>
<div class="section" id="id3">
<h4>Индексация списков<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>Теперь, когда стало понятно, с чем предстоит иметь дело, попробуем усложнить пример. Как узнать, какая оценка у третьего студента? Все просто – нужно воспользоваться <strong>индексацией</strong> списка:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># базовый журнал с пятью оценками</span>
<span class="n">math_journal</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>

<span class="n">third_student_grade</span> <span class="o">=</span> <span class="n">math_journal</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">third_student_grade</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>4
</pre></div>
</div>
</div>
</div>
<p>И снова непонятный пример! Давайте разбираться:</p>
<ol class="simple">
<li><p>Для обращения к <code class="docutils literal notranslate"><span class="pre">i</span></code>-тому объекту нужно в квадратных скобках указать его индекс;</p></li>
<li><p><strong>Индекс</strong> в Python начинается <strong>С НУЛЯ</strong> – это самое важное и неочевидное, здесь чаще всего случаются ошибки;</p></li>
<li><p>Поэтому <code class="docutils literal notranslate"><span class="pre">[3]</span></code> обозначает взятие <strong>четвертой</strong> оценки (и потому выводится четверка, а не тройка);</p></li>
<li><p>Всего оценок 5, но так как индексация начинается с нуля, то строчка <code class="docutils literal notranslate"><span class="pre">math_journal[5]</span></code> выведет ошибку – нам доступны лишь индексы <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4]</span></code> для взятия (так называется процедура обращения к элементу списка по индексу – взятие по индексу).</p></li>
</ol>
<div class="figure align-default" id="list-indexing">
<a class="reference internal image-reference" href="../_images/list_indexing_1.png"><img alt="../_images/list_indexing_1.png" src="../_images/list_indexing_1.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-number">Fig. 25 </span><span class="caption-text">Пример списка из трех объектов. Сверху показаны их индексы, включая отрицательные</span><a class="headerlink" href="#list-indexing" title="Permalink to this image">¶</a></p>
</div>
<p>Также в <code class="docutils literal notranslate"><span class="pre">Python</span></code> существуют отрицательные индексы (-1, -2 …). Они отсчитывают объекты списка, начиная с конца. Так как нуль уже занят (под первый объект), то он не используется.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># базовый журнал с пятью оценками</span>
<span class="n">math_journal</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>

<span class="c1"># возьмем последнюю оценку</span>
<span class="n">last_grade</span> <span class="o">=</span> <span class="n">math_journal</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Последняя оценка: </span><span class="si">{</span><span class="n">last_grade</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># а теперь -- предпоследнюю</span>
<span class="n">prev</span> <span class="o">=</span> <span class="n">math_journal</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Предпоследняя оценка: </span><span class="si">{</span><span class="n">prev</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># конечно, взятие по индексам можно использовать в ранее разобранном синтаксисе</span>

<span class="k">if</span> <span class="n">math_journal</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">math_journal</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]:</span>
    <span class="n">math_journal</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Последняя оценка меньше предпоследней. Натянем студенту?&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">math_journal</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Последний студент сдал очень хорошо, на его фоне предпоследний просто двоечник!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Последняя оценка: 5
Предпоследняя оценка: 4
Последний студент сдал очень хорошо, на его фоне предпоследний просто двоечник!
</pre></div>
</div>
</div>
</div>
<p>Все это важно не только для грамотного оперирования конкретными объектами, но и следующей темы -</p>
</div>
<div class="section" id="id4">
<h4>Срезы<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>Срезы, или slices – это механизм обращения сразу к нескольким объектам списка. Для создания среза нужно в квадратных скобках указать двоеточие, слева от него – индекс начала среза (по умолчанию 0, можно не выставлять) <strong>включительно</strong>, справа – границу среза <strong>не включительно</strong> (пустота означает “до конца списка”). Может показаться нелогичной такая разнородность указания границ, но на самом деле она безумно удобна – особенно вместе с тем, что индексация начинается с нуля. Быстрее объяснить на примере:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># базовый журнал с пятью оценками</span>
<span class="n">math_journal</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>

<span class="c1"># как взять первые 3 оценки?</span>
<span class="n">first_3_grades</span> <span class="o">=</span> <span class="n">math_journal</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">first_3_grades</span> <span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># как взять последние две оценки?</span>
<span class="n">last_2_grades</span> <span class="o">=</span> <span class="n">math_journal</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">last_2_grades</span> <span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># сделаем срез на 4 оценки, начиная со второй (с индексом 1)</span>
<span class="n">start_index</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">some_slice</span> <span class="o">=</span> <span class="n">math_journal</span><span class="p">[</span><span class="n">start_index</span> <span class="p">:</span> <span class="n">start_index</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">some_slice</span> <span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># возьмем столько объектов из начала, сколько объектов в some_slice</span>
<span class="n">yet_another_slice</span> <span class="o">=</span> <span class="n">math_journal</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">some_slice</span><span class="p">)]</span>

<span class="c1"># а вот так можно проверить, попадает ли объект в список</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Верно ли, что единица входит в some_slice? {1 in some_slice}&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Верно ли, что единица входит в yet_another_slice? {1 in yet_another_slice}&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>first_3_grades = [1, 2, 3]
last_2_grades = [4, 5]
some_slice = [2, 3, 4, 5]
Верно ли, что единица входит в some_slice? {1 in some_slice}
Верно ли, что единица входит в yet_another_slice? {1 in yet_another_slice}
</pre></div>
</div>
</div>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Можно сделать пустой срез, и тогда Python вернет пустой список без объектов. Можете проверить сами:
<code class="docutils literal notranslate"><span class="pre">[&quot;1&quot;,</span> <span class="pre">&quot;2&quot;,</span> <span class="pre">&quot;3&quot;][10:20]</span></code></p>
</div>
<p>Давайте проговорим основные моменты, которые <strong>крайне важно понять</strong>:</p>
<ol class="simple">
<li><p>Так как индексация начинается с нуля (значение по умолчанию) и правая граница не включается в срез, то берутся объекты с индексами <code class="docutils literal notranslate"><span class="pre">[0,1,2]</span></code>, что в точности равняется трем первым объектам;</p></li>
<li><p>Срез <code class="docutils literal notranslate"><span class="pre">[-2:]</span></code> указывает на то, что нужно взять все объекты до конца, начиная с предпоследнего</p></li>
<li><p>Значения в срезе могут быть <strong>вычислимы</strong> (и задаваться сколь угодно сложной формулой), но должны оставаться <strong>целочисленными</strong>;</p></li>
<li><p>Если нужно взять <code class="docutils literal notranslate"><span class="pre">k</span></code> объектов, начиная с <code class="docutils literal notranslate"><span class="pre">i</span></code>-го индекса, то достаточно в качестве конца среза указать <code class="docutils literal notranslate"><span class="pre">k+i</span></code>;</p></li>
<li><p>Для проверки вхождения какого-либо объекта в список нужно использовать конструкцию <code class="docutils literal notranslate"><span class="pre">x_obj</span> <span class="pre">in</span> <span class="pre">some_list</span></code>, которая вернет <code class="docutils literal notranslate"><span class="pre">True</span></code>, если массив содержит <code class="docutils literal notranslate"><span class="pre">x_obj</span></code>, и <code class="docutils literal notranslate"><span class="pre">False</span></code> в ином случае;</p></li>
<li><p>Самый простой способ сделать копию списка - это сделать срез по всему объекту: <code class="docutils literal notranslate"><span class="pre">my_list[:]</span></code>. Однако будьте внимательны – в одних случаях копирование происходит полностью (по значению), а в некоторых сохраняются ссылки (то есть изменив один объект в скопированном списке вы измените объект в исходном). Связано это с типом объектов (mutable/immutable), подбробнее об этом будет рассказано в следующей лекции. В общем, если вы работаете с простыми типами (<code class="docutils literal notranslate"><span class="pre">int</span></code>/<code class="docutils literal notranslate"><span class="pre">str</span></code>), то срез вернет копию, и её изменение не затронит исходный список. Однако для хранения новых данных нужна память, поэтому при копировании десятков миллионов объектов можно получить ошибку, связанную с нехваткой памяти.</p></li>
</ol>
</div>
<div class="section" id="id5">
<h4>Циклы<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>До сих пор в примерах мы хоть и обращались к нескольким объектам, добавляли и меняли их, все еще не было рассмотрено взаимодействие сразу с несколькими. Давайте попробуем посчитать, сколько студентов получили оценку от 4 и выше. Для этого интуитивно кажется, что нужно <strong>пройтись по всем оценкам от первой до последней</strong>, сравнить каждую с четверкой. Для прохода по списку, или <strong>итерации</strong>, используются <strong>циклы</strong>.
Общий синтаксис таков:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">example_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">example_list</span><span class="p">:</span>
    <span class="o">&lt;&gt;</span> <span class="n">блок</span> <span class="n">кода</span> <span class="n">внутри</span> <span class="n">цикла</span> <span class="p">(</span><span class="n">аналогично</span> <span class="n">блоку</span> <span class="n">в</span> <span class="k">if</span><span class="p">)</span>
    <span class="o">...</span> <span class="n">что</span><span class="o">-</span><span class="n">то</span> <span class="n">сделать</span> <span class="n">с</span> <span class="n">item</span>
    <span class="o">&lt;&gt;</span>
</pre></div>
</div>
<p>Здесь <code class="docutils literal notranslate"><span class="pre">example_list</span></code> – это некоторый итерируемый объект. Помимо списка в Python существуют и другие итерируемые объекты, но пока будем говорить о массивах.</p>
<p>Этот цикл работает так: указанной <strong>переменной <code class="docutils literal notranslate"><span class="pre">item</span></code> присваивается первое значение из списка</strong>, и выполняется <strong>блок кода</strong> внутри цикла (этот блок, напомним, определяется отступом. Он выполняется весь от начала отступа и до конца, как и было объяснено в пятой лекции). Этот блок еще иногда называют <strong>телом цикла</strong>. Потом переменной <code class="docutils literal notranslate"><span class="pre">item</span></code> присваивается следующее значение (второе), и так далее. Переменную, кстати, можно называть как угодно, не обязательно <code class="docutils literal notranslate"><span class="pre">item</span></code>.</p>
<p><strong>Итерацией</strong> называется каждый <strong>отдельный проход</strong> по телу цикла. Цикл всегда повторяет команды из тела цикла несколько раз. Два примера кода ниже аналогичны:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">math_journal</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">for</span> <span class="n">cur_grade</span> <span class="ow">in</span> <span class="n">math_journal</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">cur_grade</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Всего хорошистов и отличников по математике </span><span class="si">{</span><span class="n">counter</span><span class="si">}</span><span class="s2"> человека&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Всего хорошистов и отличников по математике 2 человека
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">math_journal</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">cur_grade</span> <span class="o">=</span> <span class="n">math_journal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">if</span> <span class="n">cur_grade</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
    <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="c1"># не забываем менять индекс с 0 на 1, так как каждый раз берется следующий элемент</span>
<span class="n">cur_grade</span> <span class="o">=</span> <span class="n">math_journal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="k">if</span> <span class="n">cur_grade</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
    <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="c1"># и с единицы на двойку</span>
<span class="n">cur_grade</span> <span class="o">=</span> <span class="n">math_journal</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="k">if</span> <span class="n">cur_grade</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
    <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Всего хорошистов и отличников по математике </span><span class="si">{</span><span class="n">counter</span><span class="si">}</span><span class="s2"> человека&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Всего хорошистов и отличников по математике 2 человека
</pre></div>
</div>
</div>
</div>
<p>Понятно, что первый кусок кода обобщается на любой случай – хоть оценок десять, хоть тысяча. Второе решение не масштабируется, появляется <strong>много одинакового кода, в котором легко ошибиться</strong> (не поменять индекс, к примеру).</p>
<p>Движемся дальше. Так как каждый элемент списка закреплен за конкретным индексом, то в практике часто возникают задачи, логика которых завязана на индексах. Это привело к тому, что появилась альтернатива для итерации по списку. Функция <code class="docutils literal notranslate"><span class="pre">range</span></code> принимает аргументы, аналогичные срезу в списке, и возвращает итерируемый объект, в котором содержатся целые числа (индексы). Так как аргументы являются аргументами функции, а не среза, то они соединяются запятой (как <code class="docutils literal notranslate"><span class="pre">print(a,</span> <span class="pre">b)</span></code> нескольких объектов). Если подан всего один аргумент, то нижняя граница приравнивается к нулю. Посмотрим на практике, как сохранить номера (индексы) всех хорошо учащихся студентов:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">math_journal</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">good_student_indexes</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">student_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">math_journal</span><span class="p">)):</span>
    <span class="n">curent_student_grade</span> <span class="o">=</span> <span class="n">math_journal</span><span class="p">[</span><span class="n">student_index</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">curent_student_grade</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">good_student_indexes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">student_index</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Преуспевающие по математике студенты находятся на позициях: </span><span class="si">{</span><span class="n">good_student_indexes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Преуспевающие по математике студенты находятся на позициях: [0, 2, 3, 4, 7]
</pre></div>
</div>
</div>
</div>
<p>В примере <code class="docutils literal notranslate"><span class="pre">student_index</span></code> принимает последовательно все значения от <code class="docutils literal notranslate"><span class="pre">0</span></code> до <code class="docutils literal notranslate"><span class="pre">7</span></code> включительно. <code class="docutils literal notranslate"><span class="pre">len(math_journal)</span></code> равняется <code class="docutils literal notranslate"><span class="pre">8</span></code>, а значит, восьмерка сама не будет включена в набор индексов для перебора. На каждой итерации <code class="docutils literal notranslate"><span class="pre">curent_student_grade</span></code> меняет свое значение, после чего происходит проверка. Если бы была необходимость пробежаться только по студентам, начиная с третьего, то нужно было бы указать <code class="docutils literal notranslate"><span class="pre">range(2,</span> <span class="pre">len(math_journal))</span></code> (двойка вместо тройки потому, что индексация с нуля, ведь мы перебираем индексы массива).</p>
<p>Выше описаны основные концепции обращения со списками. Их крайне важно понять и хорошо усвоить, без этого писать любой код будет безумно сложно. Скопируйте примеры к себе в <code class="docutils literal notranslate"><span class="pre">.ipynb</span></code>-ноутбук, поиграйтесь, поменяйте параметры цикла и проанализируйте изменения.</p>
</div>
<div class="section" id="list-comprehensions">
<h4>List comprehensions<a class="headerlink" href="#list-comprehensions" title="Permalink to this headline">¶</a></h4>
<p>Некоторые циклы настолько просты, что занимают 2 или 3 строчки. Как пример – привести список чисел к списку строк:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># грубый вариант</span>
<span class="n">inp_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="n">out_list</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">inp_list</span><span class="p">:</span>
    <span class="n">out_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>

<span class="c1"># list comprehension</span>
<span class="n">out_list</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">inp_list</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">out_list</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;1&#39;, &#39;4&#39;, &#39;6&#39;, &#39;8&#39;]
</pre></div>
</div>
</div>
</div>
<p>Две части кода идентичны за вычетом того, что нижняя – с непонятной конструкцией в скобках – короче. Python позволяет в рамках одной строки произвести какие-либо простые преобразования (помним, что <code class="docutils literal notranslate"><span class="pre">str()</span></code> – это вызов функции, а значит если у вас есть сложная функция, которая делает квантовые вычисления, то ее также можно применить!). Фактически самый частый пример использования – это паттерн “<strong>применение функции к каждому объекту списка</strong>”.</p>
</div>
<div class="section" id="id6">
<h4>Что мы узнали из лекции<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">list</span></code> – это <strong>объект-контейнер, который хранит другие объекты разных типов</strong>. Запись происходит упорядочено и последовательно, а каждому объекту присвоен <strong>целочисленный номер, начиная с нуля</strong>;</p></li>
<li><p>для добавления одного объекта в <code class="docutils literal notranslate"><span class="pre">list</span></code> нужно использовать метод объекта <code class="docutils literal notranslate"><span class="pre">list</span></code> – <code class="docutils literal notranslate"><span class="pre">append</span></code>, а для расширения списка сразу на несколько позиций пригодится <code class="docutils literal notranslate"><span class="pre">extend</span></code>;</p></li>
<li><p>проверить, сходит ли объект в список, можно с помощью конструкции <code class="docutils literal notranslate"><span class="pre">obj</span> <span class="pre">in</span> <span class="pre">some_list</span></code>;</p></li>
<li><p>индексы <strong>могут быть отрицательными</strong>: <code class="docutils literal notranslate"><span class="pre">-1</span></code>, <code class="docutils literal notranslate"><span class="pre">-2</span></code> … В таком случае нумерация начинается от последнего объекта;</p></li>
<li><p>можно получить часть списка, сделав <strong>срез</strong> с помощью конструкции <code class="docutils literal notranslate"><span class="pre">list[start_index</span> <span class="pre">:</span> <span class="pre">end_index]</span></code>, при этом объект на позиции <code class="docutils literal notranslate"><span class="pre">end_idnex</span></code> не будет включен в возвращаемый список (т.е. <strong>срез работает не включительно по правую границу</strong>);</p></li>
<li><p>часто со списками используют <strong>циклы, которые позволяют итерироваться по объектам массива</strong> и выполнять произвольную логику в рамках отделенного отступом блока кода;</p></li>
<li><p>для итерации по индексам можно использовать <code class="docutils literal notranslate"><span class="pre">range()</span></code>;</p></li>
<li><p>простые циклы можно свернуть в <strong>list comprehension</strong>, и самый частый паттерн для такого преобразования – это <strong>применение некоторой функции к каждому объекту</strong> списка (если <code class="docutils literal notranslate"><span class="pre">x</span></code> это функция, то синтаксис будет таков: <code class="docutils literal notranslate"><span class="pre">[x(item)</span> <span class="pre">for</span> <span class="pre">item</span> <span class="pre">in</span> <span class="pre">list])</span></code>).</p></li>
</ul>
</div>
</div>
</div>
<div class="toctree-wrapper compound">
<span id="document-book/mlblock/ml_intro"></span><div class="section" id="ml-intro">
<span id="id1"></span><h3>О блоке<a class="headerlink" href="#ml-intro" title="Permalink to this headline">¶</a></h3>
<p>Этот блок рассказывает о том, что общего у разных задач машинного обучения и как из основных компонентов, подобно паззлу, складываются различные применения моделей машинного обучения. Основная наша  задача – чтоб у читателя даже не знакомого с машинным обучением возникло понимание того, как это все работает и как “сложить паззл” в новой задаче, будь то кластеризация новостей, детекция лиц на фотографиях или различные сложные применения вариационных квантовых схем, о которых пойдет речь далее в курсе.</p>
<div class="figure align-default" id="vqgan-clip-quantum-mind">
<a class="reference internal image-reference" href="../_images/vqgan_clip_quantum_mind.png"><img alt="../_images/vqgan_clip_quantum_mind.png" src="../_images/vqgan_clip_quantum_mind.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">Fig. 26 </span><span class="caption-text">Как “видит” квантовый мир пара нейросетей VQGAN и CLIP, сгенерировано в <a class="reference external" href="https://colab.research.google.com/drive/1L8oL-vLJXVcRzCFbPwOoMkPKJ8-aYdPN">Google Colab</a></span><a class="headerlink" href="#vqgan-clip-quantum-mind" title="Permalink to this image">¶</a></p>
</div>
</div>
<span id="document-book/mlblock/ml_l1"></span><div class="section" id="mll1">
<span id="id1"></span><h3>Машинное обучение как пазл<a class="headerlink" href="#mll1" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id2">
<h4>Введение<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>Мы продолжаем вводную часть нашего курса и переходим к машинному обучению. Если тема для вас хорошо знакома, можете пропустить этот блок, при желании можно пройти  <a class="reference external" href="http://foo">этот тест</a> для определения достаточности уровня знаний. Тест можно проигнорировать, если вы не знакомы с машинным обучением и для вас выглядят магией такие вещи как автоматическая детекция лиц на фото или определение тональности отзыва на товар.</p>
<p>Про машинное обучение, конечно, уже много всего написано, есть и немало неплохих курсов, сочетающих как теорию, так и практику. Но все же теория в этой области еще не догоняет практику, мы пока не понимаем, “почему оно работает”, а гарантии обобщающей способности алгоритмов (т.е. гарантии того, что модель машинного обучения будет работать на новых данных) в теории даются только для очень простых моделей. Таким образом, работа со сложными моделями остается своего рода искусством с примесью математики, инженерии и просто следования хорошим практикам, выработанным, как правило, в корпорациях или академическом сообществе.</p>
<p>В этой лекции мы примем сторону практики и расскажем про задачи машинного обучения как некоторый пазл (или лего, кому что ближе) – меняя разные кусочки, мы будем получать разные прикладные задачи/сценарии/модели применения машинного обучения. Для иллюстрации такое описание мы сопроводим 3-мя примерами:</p>
<ul class="simple">
<li><p>задача рекомендации контента и градиентный бустинг</p></li>
<li><p>автоматическая оценка читаемости научной статьи и BERT</p></li>
<li><p>детекция симптомов COVID-19 на рентгенограммах и YOLO</p></li>
</ul>
<p>В этой лекции мы не опишем подробно, что это за модели машинного обучения (градиентный бустинг, BERT, YOLO), но зато покажем, что сценарии их применения в разных задачах (анализ табличных данных, текстов, изображений) похожи.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Здесь мы почти не будем говорить о математике. Изложенный взгляд на машинное обучение как ремесло, вполне вероятно, вызовет критику со стороны специалистов в области статистики, эконометрики и теории машинного/статического обучения. Мы осознаем эти риски и тем не менее рассказываем о машинном обучении именно как о ремесле. Акцент в курсе делается на квантовые вычисления и квантовое машинное обучение, и в этой лекции мы опишем задачи “классического” машинного обучения на том уровне, чтоб просто было понятно, как это переносится на квантово-классические вариационные схемы и прочие алгоритмы, о которых пойдет речь далее в курсе. При этом строгость изложения материала тоже может немного пострадать.</p>
</div>
</div>
<div class="section" id="id3">
<h4>Составляющие части задачи машинного обучения<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>Выделим следующие компоненты (“пазлы”), которые просматриваются во многих разных задачах машинного обучения:</p>
<ul class="simple">
<li><p>Целевой признак</p></li>
<li><p>Модель</p></li>
<li><p>Данные</p></li>
<li><p>Функция потерь</p></li>
<li><p>Решатель</p></li>
<li><p>Схема валидации и метрика качества</p></li>
</ul>
<p>По ходу изложения будем обсуждать упомянутые примеры задач машинного обучения.</p>
<div class="section" id="id4">
<h5>Целевой признак<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h5>
<p>Есть задачи, в которых машинное обучение не нужно, а достаточно экспертных знаний. По закону Ома, известно что напряжение пропорционально силе тока и электрическому сопротивлению, и вряд ли захочется предсказывать напряжение в сети каким-то другим образом, кроме как применением закона Ома. То же самое можно сказать про многие другие физические явления.</p>
<p>Однако, для очень многих явлений вокруг нет хорошего теоретического объяснения или достаточных экспертных знаний. У нас нет “формулы”, которая описала бы, как поставленный лайк к посту в соцсети, возврат кредита, клик по рекомендации товара или локализация заразы в конкретной части легких зависят от прочих факторов. В таких случаях мы можем приблизить такую неизвестную нам формулу с помощью машинного обучения.</p>
<p>В идеале с помощью машинного обучения мы хотели бы предсказывать какое-то событие, явление или процесс так, чтоб от этого была польза: прибыль компании/клиентов, если речь о бизнес-проекте, или новые знания, если это исследовательский проект. При этом напрямую это сделать вряд ли получится, и надо определить целевой признак, который, как мы считаем, будет связан с целевым событием/явлением. Звучит абстрактно, и дать строгое определение таких событий, явлений или процессов вряд ли получится. Поэтому сразу перейдем к примерам.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Перед этим только небольшое замечание, что потребовав наличие целевого признака, мы ограничилиcь рассмотрением задач обучения с учителем (<a class="reference external" href="https://en.wikipedia.org/wiki/Supervised_learning">supervised learning</a>). Это все еще включает очень большой перечень типов задач машинного обучения, но не все.</p>
</div>
<p><strong>Пример 1. Рекомендация новостного контента</strong></p>
<p>Новостному порталу хочется понять, какой контент нравится пользователям и по каким ссылкам они будут кликать. Здесь <em>событием</em> будет то, что пользователю нравится рекомендуемый контент.</p>
<div class="figure align-default" id="see-also">
<a class="reference internal image-reference" href="../_images/see_also.png"><img alt="../_images/see_also.png" src="../_images/see_also.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">Fig. 27 </span><span class="caption-text">Блок “Читайте также” на новостном портале</span><a class="headerlink" href="#see-also" title="Permalink to this image">¶</a></p>
</div>
<p>Понятно, что нет возможности установить строгую зависимость такого события от прочих факторов. Поэтому мы определяем целевой признак: факт клика пользователя по показанной рекомендованной ссылке. Мы верим, что клик по ссылке связан с <em>событием</em>: если пользователю  нравится рекомендуемый контент, он/она перейдет по ссылке.</p>
<p><strong>Пример 2. Автоматическая оценка читаемости научной статьи</strong></p>
<p>Допустим, научному журналу хочется автоматически оценивать читаемость текста, чтобы знать, какие статьи можно сразу подавать на ревью, а какие лучше предварительно направить в сервис proofreading, где статья будет вычитана и поправлена носителем языка.</p>
<p>В идеале мы бы хотели предсказывать, “хорошо” ли написана статья или “плохо”. Но это очень сложно определить формально, и потому есть много метрик читаемости текста, таких как <a class="reference external" href="https://en.wikipedia.org/wiki/Automated_readability_index">Automated readability index</a> или <a class="reference external" href="https://en.wikipedia.org/wiki/Flesch%E2%80%93Kincaid_readability_tests#Flesch_reading_ease">Flesch reading ease</a>, которые являются эвристиками и “приближают” то что мы имеем в виду под “хорошо” или “плохо” написанным текстом. Кстати, на момент написания это лекции на платформе Kaggle проходит <a class="reference external" href="https://www.kaggle.com/c/commonlitreadabilityprize/overview">соревнование</a> по этой теме.</p>
<p>Небольшое лирическое отступление: во многом опыт специалиста по машинному обучению сказывается в способности понять, когда это машинное обучение <strong>не</strong> требуется. Описанную задачу можно решить и без всякого машинного обучения. Можно замерить 5-10 метрик читаемости текста, разметить 100-200 статей вручную (желательно, чтоб это делали эксперты уровня редактора журнала, а еще и лучше бы иметь по 3 оценки на статью) и заключить, хорошо ли метрики читаемости коррелируют с оценками экспертов. Другой вариант – попытаться малой ценой использоваться готовые решения, например, Grammarly.</p>
<p>Но если этого окажется недостаточно, придется подумать. Пока остановимся тут и еще раз подчеркнем, что определить читаемость текста напрямую – невозможно, и мы это заменим на другой <em>Целевой признак</em>, например, на агрегированную метрику читаемости текста.</p>
<p><strong>Пример 3. Детекция симптомов COVID-19 на рентгенограммах</strong></p>
<p>Последние пару лет мы видели бурное развитие методов глубокого обучение в приложениях к анализу медицинских данных, а в особенности это стало актуальным в симптомов COVID-эпоху.</p>
<p>Допустим, стоит задача определения аномалий на рентгенограммах грудной клетки. В идеале мы хотели мы сразу по таким изображениям обнаруживать симптомы симптомов COVID-19 у пациента. Но заголовок этого примера выдает желаемое за действительное, и, конечно, сразу по снимкам диагностировать не получится.</p>
<div class="figure align-default" id="covid-detection-ct">
<a class="reference internal image-reference" href="../_images/covid_detection_ct.png"><img alt="../_images/covid_detection_ct.png" src="../_images/covid_detection_ct.png" style="width: 1000px;" /></a>
<p class="caption"><span class="caption-number">Fig. 28 </span><span class="caption-text">Пример данных <a class="reference external" href="https://www.kaggle.com/c/siim-COVID19-detection">соревнования</a> по определению аномалий на рентгенограммах грудной клетки. <a class="reference external" href="https://www.kaggle.com/andradaolteanu/siim-COVID-19-box-detect-dcm-metadata">Источник</a></span><a class="headerlink" href="#covid-detection-ct" title="Permalink to this image">¶</a></p>
</div>
<p>Поэтому в такой задаче надо аккуратно определить <em>Целевой признак</em>. В данном случае их несколько. Согласно <a class="reference external" href="https://www.kaggle.com/c/siim-covid19-detection/data">описанию источника данных</a> соревнования, комитет врачей-радиологов проанализировал 6334 рентгенограмм и пометил их метками: ‘Negative for Pneumonia’ (нет пневмонии), ‘Typical Appearance’ (нормально), ‘Indeterminate Appearance’ (неразборчиво) и ‘Atypical Appearance’ (ненормально). Надо четко понимать, что возможности обученной модели будут ограничены имеющейся разметкой и поэтому заголовок “детекция симптомов COVID-19” слегка “желтоват”, в реальности модель детекции сможет выделять участок изображения (bounding box) и помечать это вектором из 4-х значений, соответствующих описанным целевым признакам в обучающей выборке.</p>
<div class="figure align-default" id="covid-detection-prediction">
<a class="reference internal image-reference" href="../_images/covid_detection_prediction.png"><img alt="../_images/covid_detection_prediction.png" src="../_images/covid_detection_prediction.png" style="width: 1000px;" /></a>
<p class="caption"><span class="caption-number">Fig. 29 </span><span class="caption-text">Прогноз модели детекции, обученной на данных <a class="reference external" href="https://www.kaggle.com/c/siim-COVID19-detection">соревнования</a> по определению аномалий на рентгенограммах грудной клетки. <a class="reference external" href="https://www.kaggle.com/yujiariyasu/catch-up-on-positive-samples-plot-submission-csv">Источник</a></span><a class="headerlink" href="#covid-detection-prediction" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="id5">
<h5>Данные<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h5>
<p>Определение <em>Целевого признака</em> неразрывно связано с имеющимися данными. Нет смысла определять целевой признак, который мы не можем измерить или по которому мы не можем собрать данные. Например, если новостной портал не логирует клики пользователей, нет смысла задавать вопрос о том, нравятся ли пользователям показанные рекомендации – для начала надо настроить сервисы для хранения кликов. Другой пример: вряд ли стоит пытаться предсказывать движения денежных активов в микросекундном диапазоне, если нет дорогостоящей инфраструктуры для сбора и обработки таких данных.</p>
<p>Но <em>Данные</em> – это, конечно, не только <em>Целевой признак</em>. Но и просто <em>признаки</em>, также в эконометрике называемые предикторами или независимыми переменными. С помощью <em>признаков</em> как раз и получится предсказать <em>Целевой признак</em>, а хорошо или плохо – об этом чуть далее.</p>
<p>Продумывание, сбор, и обработка  <em>признаков</em> – один из наиболее творческих аспектов работы специалистов по машинному обучению. Эта работа может включать в себя общение с представителями предметной области или бизнеса, клиентами, чтение научных статей, применение и более технических приемов, таких как порождение признаков из других признаков (feature engineering) или использование моделей для получения признаков (например, признаки изображения, полученные предобученной искусственной нейросетью).</p>
<p><strong>Пример 1. Рекомендация новостного контента</strong></p>
<p>В этой задаче, как правило, хорошо работают данные о поведении пользователей, попросту – “клики”. Обычно алгоритмы рекомендации хорошо работают при обучении на больших объемах данных, и поэтому большая часть проекта посвящена настройка хранилища данных и обработке потоковых событий (показ рекомендации, клик по рекомендации).</p>
<p>Если есть возможность собрать какие-то признаки пользователей (пол, возраст, указанные интересы) или рекомендуемого контента (темы новостей, представление текста новости “эмбеддингами”), эту информацию можно добавить в модель.</p>
<p>При достаточно хорошей подготовке данных задачу можно решить и без машинного обучения. Довольно сильным прототипом (baseline-решением), опять же, при достаточных объемах данных, моет быть просто сортировка контента по Click-through-Rate (CTR). Для каждой новости мы просто собираем статистику, сколько раз она была показана пользователю в качестве рекомендации и сколько раз по ней в итоге кликнули. Отношение кликов к показам и есть Click-through-Rate. Есть, конечно, детали – что делать с “холодными” новостями, без накопленной статистики для расчета CTR, что делать с clickbait-новостями, как фильтровать то, что нельзя показывать в качестве рекомендации. Но после решения этих проблем может оказаться, что просто сортировка по CTR – уже неплохое решение.</p>
<p><strong>Пример 2. Автоматическая оценка читаемости научной статьи</strong></p>
<p>Допустим, научному журналу удалось договориться с сервисом proofreading и получить данные о том, какие статьи хорошо написаны и не требуют множества правок, а какие пришлось переписывать почти что с нуля. Эту информацию можно пытаться использовать для обучения модели, которая для заданного куска текста будет предсказывать, как сильно его нужно поправить.</p>
<p>Тут мы будем иметь дело с задачей из области NLP (Natural Language Processing) – на входе будет просто текст (полный текст статьи или разбитый на параграфы) и по сути мы можем не придумывать <em>признаки</em> вручную, а модель сама их извлечет, то есть выучит представление текста. <em>Целевым признаком</em> при этом будет, например, какое-либо расстояние (скажем, Левенштейна) между оригинальным текстом и поправленным редактором. Таким образом, это будет задачей регрессии, в которой для текста предсказывается, как сильно его следует изменить.</p>
<p>Опять стоит отметить, что в такой задаче скорее всего нужно много  обучающих данных, чтобы описанный алгоритм хорошо заработал.</p>
<p>И еще стоит отметить, что задачи NLP зачастую пересекаются с лингвистикой, и это как раз такой пример. Вполне вероятно, что задачу можно решить без тоже машинного обучения и по-другому – на основе правил-эвристик, разработанных в сотрудничестве с лингвистами. Эдакая версия Grammarly для работы с научными текстами.</p>
<p>Но дальше в примере будем считать, что лингвистов в команде нет, простые метрики читаемости текста, описанные выше, работают плохо, и мы решаем задачу регрессии, то есть используем машинное обучение.</p>
<p><strong>Пример 3. Детекция симптомов COVID-19 на рентгенограммах</strong></p>
<p>В этой задаче ключевые данные для обучения модели – это собственно изображение, рентгенограмма области грудной клетки и разметка, которая состоит из координат интересующей области изображения и типа области, в данном случае это одна из 4-х меток: ‘Negative for Pneumonia’ (нет пневмонии), ‘Typical Appearance’ (нормально), ‘Indeterminate Appearance’ (неразборчиво) и ‘Atypical Appearance’ (ненормально).</p>
<p>Конечно, у снимков есть разные метаданные, да и форматы медицинских данных обычно специфические, но нам для примера подойдет такое упрощение.</p>
</div>
<div class="section" id="id6">
<h5>Модель<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h5>
<p>С моделированием знаком любой исследователь. Чтоб рассчитать минимальную толщину стекла вагона метро для защиты от птиц во время движения по открытым участкам, достаточно представить птицу цилиндром той же массы, и для данной задачи цилиндр будет подходящей моделью птицы.</p>
<p>Подобным же образом, в задачах машинного обучения с учителем <em>Модель</em> приближает <em>Целевой признак</em> и делает это с помощью <em>Данных</em> и <em>Параметров</em>. (Параметры – это неотъемлемая часть модели, и поэтому мы их не выносим как отдельный компонент задач машинного обучения).</p>
<p>Надо понимать, что предлагая модель, мы совершаем уже второе упрощение. Сначала, как мы говорили, <em>Целевой признак</em> заменяет нам то, что мы реально хотим знать. А теперь, к тому же, мы заменяем целевой признак на его прогноз с помощью модели.</p>
<p><strong>Пример 1. Рекомендация новостного контента</strong></p>
<p>В задачах рекомендации есть классический алгоритм ALS (Alternative Least Squares), но можно задачу решить и как задачу ранжирования. Это может быть предпочтительно, поскольку можно использовать боевую лошадку машинного обучения на табличных данных – градиентный бустинг (доступно, на русском про эту модель написано <a class="reference external" href="https://habr.com/ru/company/ods/blog/327250/">тут на Хабре</a> в рамках курса <a class="reference external" href="https://mlcourse.ai">mlcourse.ai</a>).  Бустинг подходит для задач классификации, регрессии и ранжирования, и его можно использовать также и в описанной задаче.</p>
<p>Также, если бустинг уже используется в компании в других задачах, скорее всего получится безболезненно переиспользовать опыт поддержки модели и соответствующей инфраструктуры в “продакшене” вместо того, чтобы отдельно все это разрабатывать для ALS.</p>
<p><strong>Пример 2. Автоматическая оценка читаемости научной статьи</strong></p>
<p>Описанную задачу, опять же с оговорками про возможность альтернативного подхода без всякого машинного обучения, скорее всего хочется решать с помощью языковых моделей, основанных на трансформерах. В частности, в этой задаче имеет смысл использовать <a class="reference external" href="https://github.com/allenai/scibert">SciBERT</a>, предобученный как раз на научных текстах. Это модель типа BERT (Bidirectional Encoder Representations from Transformers, <a class="reference external" href="https://arxiv.org/abs/1810.04805">arXiv</a>), которая основана на архитектуре трансформеров, ставшей настоящей революцией в NLP (оригинальная статья – <a class="reference external" href="https://papers.nips.cc/paper/2017/file/3f5ee243547dee91fbd053c1c4a845aa-Paper.pdf">Attention is all you need</a>, NIPS 2017). BERT используется для представления текста на основе трансформеров и дообучения параметров под многие стандартные задачи NLP – классификация текстов, пар текстов, вопросно-ответные системы, разпознавание именованных сущностей и т.д. Подробнее про BERT можно почитать в <a class="reference external" href="https://jalammar.github.io/">постах Jay Alammar</a> (англ.) или в их переводах на русский: <a class="reference external" href="https://habr.com/ru/post/486358/">“Transformer в картинках”</a> и <a class="reference external" href="https://habr.com/ru/post/498144/">“Ваш первый BERT: иллюстрированное руководство”</a>.</p>
<p><strong>Пример 3. Детекция симптомов COVID-19 на рентгенограммах</strong></p>
<p>Подходов к детекции объектов на изображениях немало, но по соотношению скорости и качества работы особенно хорошо себя зарекомендовала модель <a class="reference external" href="https://github.com/ultralytics/yolov5">YOLOv5</a>. Про принцип работы этой модели можно узнать из лекции <a class="reference external" href="https://www.youtube.com/watch?v=nDPWywWRIRo">“Detection and segmentation”</a> курса cs231n, также на Хабре можно найти <a class="reference external" href="https://habr.com/ru/post/503200/">статью</a> про YOLOv4.</p>
<div class="figure align-default" id="detection-yolo">
<a class="reference internal image-reference" href="../_images/detection_yolo.jpeg"><img alt="../_images/detection_yolo.jpeg" src="../_images/detection_yolo.jpeg" style="width: 800px;" /></a>
<p class="caption"><span class="caption-number">Fig. 30 </span><span class="caption-text">Пример обнаружения объектов на изображении. <a class="reference external" href="https://habr.com/ru/post/503200/">Источник</a></span><a class="headerlink" href="#detection-yolo" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="id7">
<h5>Функция потерь<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h5>
<p>Выбор функции потерь (loss function) зависит от конкретной задачи, и это вопрос, изучаемый в курсах машинного обучения. Функция потерь определена для объектов обучающей выборки и по сути говорит, насколько прогноз хорошо соответствует значению целевого признака.</p>
<p>Тут тонкий момент: примерно для того же нужны метрики качества, о которых речь пойдет ниже. Но функция потерь на практике чаще всего используется именно для того, чтоб задать цель обучения модели (для чего именно ей менять свои параметры) и также оценить, насколько хорошо модель обучилась, попросту, насколько хорошо она “сошлась”.</p>
<p>В отличие от метрик качества, функции потерь вполне могут быть плохо интерпретируемыми, например как логистическая функция потерь (logloss, на русском про нее можно прочитать в <a class="reference external" href="https://dyakonov.org/2018/03/12/%D0%BB%D0%BE%D0%B3%D0%B8%D1%81%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F-%D0%BE%D1%88%D0%B8%D0%B1%D0%BA%D0%B8/">посте</a> А.Г. Дьяконова), и на практике при разработке модели Data Scientist посмотрит на значение функции потерь всего несколько раз:</p>
<ul class="simple">
<li><p>при отладке модели стоит проверить, может ли она “переобучиться под мини-батч”, то есть может ли она при обучении всего с парой десятком примеров добиться почти нулевого значения функции потерь. Это важно, чтоб понять, нет ли где-то ошибки в коде описания модели и хватает ли модели сложности (capacity), чтобы подстроиться под данные</p></li>
<li><p>чтобы избежать переобучения, стоит проверять (вручную или автоматически) значение функции потерь на отложенной выборке</p></li>
<li><p>еще значения функции потерь можно сравнивать для разных версий модели, чтоб понять, какая из них лучше обучилась</p></li>
</ul>
<p>Заметим, что дизайн функции потерь под задачу, как и придумывание признаков – порой интересный творческий процесс, а итоговая функции потерь, используемая для обучения модели может быть сложной, состоящей из нескольких более простых функций потерь.</p>
<p>Для примера, в задаче переноса стиля (style transfer), в классическом варианте задаются два изображения – “контентное” и “стилевое” – и генерируется третье изображение, которое похоже в целом на “контентное” изображение, но по стилю – на “стилевое”. При этом функция потерь складывается из двух других:</p>
<ul class="simple">
<li><p>одна – content loss – передает, насколько отличаются карты признаков (feature maps) генерируемого и “контентного” изображений</p></li>
<li><p>вторая – style loss – соответственно передает, насколько похожи стили генерируемого и “стилевого” изображений. Делается это хитро, и за деталями лучше обратиться, например, к <a class="reference external" href="https://www.youtube.com/watch?v=6wcs6szJWMY">лекции “Visualizing and Understanding”</a> стэнфордского курса cs231n.</p></li>
</ul>
<div class="figure align-default" id="example-styletransfer-png">
<a class="reference internal image-reference" href="../_images/example_styletransfer.png"><img alt="../_images/example_styletransfer.png" src="../_images/example_styletransfer.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-number">Fig. 31 </span><span class="caption-text">Пример решения задачи Neural Style Transfer из <a class="reference external" href="https://cs231n.github.io/assignments2020/assignment3/">задания 3</a> стэнфордского курса cs231n.</span><a class="headerlink" href="#example-styletransfer-png" title="Permalink to this image">¶</a></p>
</div>
<p>Функция потерь может включать и много составляющих, больше двух, если мы хотим чтоб модель выучила разные аспекты задачи. К примеру, в <a class="reference external" href="https://habr.com/ru/post/562064/">этой статье на Хабре</a> (уровень - продвинутый NLP) Давид Дале описывает дистилляцию нескольких больших NLP моделей для получения маленькой версии русскоязычной модели BERT. Маленький BERT по сути “учится” у больших моделей RuBERT, LaBSE, USE и T5, а описание того, что маленькая модель должна уметь (предсказывать замаскированные токены по контексту, строить представления токенов подобно тому, как это делают большие модели, предсказывать правильный порядок токенов в предложении) – это и есть составление сложной функции потерь.</p>
<p><strong>Пример 1. Рекомендация новостного контента</strong></p>
<p>Задача свелась к задаче ранжирования на табличных данных, и тут можно использовать функцию потерь, которую можно оптимизировать с помощью градиентного бустинга (т.е. дифференцируемую, это важно), для задачи ранжирования. Например, <a class="reference external" href="https://www.microsoft.com/en-us/research/publication/from-ranknet-to-lambdarank-to-lambdamart-an-overview/">LambdaMART</a>.</p>
<p><strong>Пример 2. Автоматическая оценка читаемости научной статьи</strong></p>
<p>Тут задача свелась к задаче регрессии с текстовым входными данными, и можно использовать простую функцию потерь – среднеквадратичную ошибку (Mean Squared Error). Подробнее о функциях потерь в задаче регрессии можно прочитать в <a class="reference external" href="https://dyakonov.org/2018/10/23/%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8-%D0%BE%D1%88%D0%B8%D0%B1%D0%BE%D0%BA-%D0%B2-%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0%D1%85-%D1%80%D0%B5%D0%B3%D1%80%D0%B5%D1%81%D1%81%D0%B8%D0%B8/">посте</a> А.Г. Дьяконова.</p>
<p><strong>Пример 3. Детекция симптомов COVID-19 на рентгенограммах</strong></p>
<p>В задаче детекции объектов на изображениях, как правило, для каждого объекта модель выдает 4 числа – координаты окна (bounding box) и его длину и ширину, а также вектор с числами – оценки принадлежности данного региона к каждому из классов. Поэтому функция потерь, как правило, складывается из двух других:</p>
<ul class="simple">
<li><p>Для сравнения предсказанного региона с реальным (согласно разметке в обучающей выборке) используется среднеквадратичная ошибка (Mean Squared Error).</p></li>
<li><p>Для сравнения вектора оценок принадлежности региона к каждому из классов с реальным (согласно разметке в обучающей выборке) используется стандартная для задачи классификации функция потерь – логистическая, (также известная под термином “кросс-энтропия”), которую мы упоминали выше.</p></li>
</ul>
<div class="figure align-default" id="object-detection-loss">
<a class="reference internal image-reference" href="../_images/object_detection_loss.png"><img alt="../_images/object_detection_loss.png" src="../_images/object_detection_loss.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-number">Fig. 32 </span><span class="caption-text">Слайд стэнфордского курса cs231n про функцию потерь в задаче детекции объектов. <a class="reference external" href="http://cs231n.stanford.edu/slides/2020/lecture_12.pdf">Источник</a>.</span><a class="headerlink" href="#object-detection-loss" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="id8">
<h5>Решатель<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h5>
<p>Когда мы определились с целевым признаком, обучающими данными, моделью и функцией потерь, мы наконец можем собственно обучать модель – то есть менять ее параметры так, чтобы все лучше и лучше предсказывать целевой признак, что меряется с помощью функции потерь.</p>
<p>Наиболее часто используемых вариантов два:</p>
<ul class="simple">
<li><p>явное решение (closed-form solution), в котором просто применится формула для получения оптимальных параметров модели. Тут <em>Решателем</em> будет фреймворк, вычисляющий эту явно выписанную формулу, т.е. скорее всего производящий матричные умножения –  например, <code class="docutils literal notranslate"><span class="pre">NumPy</span></code>.</p></li>
<li><p>оптимизация параметров модели градиентными методами оптимизации. Тут <em>Решателем</em> будет алгоритм оптимизации и его конкретная реализация, например, в <code class="docutils literal notranslate"><span class="pre">PyTorch</span></code></p></li>
</ul>
<p>Самый известный пример первого варианта – это явное решение задачи наименьших квадратов. Существует прямо конкретная формула, включающая в себя перемножение матриц и векторов и взятие обратной матрицы, и дающая оптимальный (по минимизации среднеквадратичной ошибки) вектор весов линейной модели при наличии, конечно, обучающей выборки.</p>
<p>Получилось, что эта лекция вводная, без математических выкладок, поэтому не будем здесь приводить формулы без контекста, детали можно найти в любом классическом учебнике по статистике или машинному обучению или вкратце <a class="reference external" href="https://habr.com/ru/company/ods/blog/322076/">в этой статье</a> на Хабре в разделе “Линейная регрессия”.</p>
<p>Во всех трех примерах задач, которые мы попутно рассматриваем и которые сводятся к обучению градиентного бустинга, SciBERT и YOLO соответственно, нет явного решения, которое простой формулой выдало бы оптимальные параметры модели, поэтому параметры подбираются с помощью методов оптимизации. В примере с градиентным бустингом “под капотом” – алгоритм обучения деревьев решений, с ним можно познакомиться в <a class="reference external" href="https://habr.com/ru/company/ods/blog/322534/">этой статье</a>. А в двух других примерах обучаются искусственные нейронные сети, и сегодня это делается как правило с помощью оптимизаторов, реализованных во фреймворках (PyTorch/TensorFlow/etc), причем аппаратная реализация, в которой работает <em>Решатель</em>, – это скорее видеокарта или TPU.</p>
<p>Ко второму из рассмотренных вариантов <em>Решателя</em> можно также отнести и автоматическое дифференцирование. Чтобы оптимизировать параметры модели градиентными методами, нужно знать собственно градиенты функции потерь – вектора частных производных функции потерь по параметрам. Попросту говоря, это ответ на вопрос, какие параметры модели стоит изменять и как это скажется на функции потерь, которую мы хотим минимизировать.</p>
<p>Иногда такие градиенты функции потерь можно найти аналитически, например, в случае линейной или логистической регрессии. Но как правило, в случае более сложных моделей с большим числом параметров аналитическое выражение для градиента функции потерь выглядит слишком громоздко, лучше вычислять его численно. Это задача методов автоматического дифференцирования. В частности, возможно, величайший алгоритм машинного обучения всех времен - алгоритм обратного распространения ошибки (backpropagation) – не что иное как численный метод нахождения производных функции потерь по параметрам модели.</p>
</div>
<div class="section" id="id9">
<h5>Схема валидации и метрика качества<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h5>
<p>Наконец, когда мы определились с целевым признаком, обучающими данными, моделью, функцией потерь, а также научились подбирать параметры модели так, чтоб функция потерь уменьшалась, остался последний шаг – решить, как мы действительно поймем, что решаем задачу хорошо.</p>
<p>Выбор метрики качества напрямую связан с тем, чего мы хотим от модели машинного обучения в более широком контексте. Например, в бизнес-процессе могут быть ключевые показатели, которые мы <em>опосредованно</em> можем улучшать с помощью машинного обучения. Ключевыми показателями могут быть такие вещи как дневная аудитория приложения, Life-Time Value, показатели, связанные с удержанием (retention) клиентов/сотрудников, удовлетворенность клиентов и т.д. Многие из этих показателей нельзя замерять напрямую и оптимизировать, и тогда искусство Data Scientist-а заключается в том, чтобы выбрать простую метрику качества, которая бы задавалась понятной формулой (например, доля верных ответов или полнота) и при этом неплохо “коррелировала” с тем показателем бизнес-процесса, который хочется оптимизировать и таким образом приносить деньги компании или уменьшать операционные расходы.</p>
<p>Определение схемы валидации нужно, чтобы ответить на следующие вопросы:</p>
<ul class="simple">
<li><p>как понять, что модель сработает неплохо на новых, ранее не виденных данных</p></li>
<li><p>как понять, что мы улучшили решение, поменяв модель, ее гиперпараметры или добавив новые признаки</p></li>
<li><p>как понять, что одна модель лучше другой модели, один набор признаков лучше другого при фиксированной модели и т.д.</p></li>
</ul>
<p>Во многом это связано с переобучением. Недостаточно просто замерить метрику качества на обучающей выборке. Надо хотя бы разбить выборку на 2 части: на одной обучать модель, на второй – проверить метрику качества. И чаще всего при больших объемах данных и больших моделях ровно так и делают. Но в мире “малых данных” и легковесных моделей более предпочтительна кросс-валидация. В этой схеме выборка делится на несколько частей, а модель обучается столько же раз. При этом каждая из подвыборок один раз является тестовой частью, на которой измеряется качество прогнозов, а все остальные разы она участвует в обучении модели. Таким образом, кросс-валидация дает более надежную оценку того, как модель сработает на новых данных, в сравнении с простым разбиением обучающей выборки на две части.</p>
<div class="figure align-default" id="k-fold-cross-validation-png">
<a class="reference internal image-reference" href="../_images/k_fold_cross_validation.png"><img alt="../_images/k_fold_cross_validation.png" src="../_images/k_fold_cross_validation.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">Fig. 33 </span><span class="caption-text">Схема K-fold кросс-валидации.</span><a class="headerlink" href="#k-fold-cross-validation-png" title="Permalink to this image">¶</a></p>
</div>
<p>Вы вряд ли ошибетесь, если на практике будете применять 5-кратную стратифицированную (такую что распределение целевого признака примерно одинаковое в каждой подвыборке) кросс-валидацию, но надо понимать, что кросс-валидация – не панацея. И схема валидации, которую мы тут описываем, – это больше, чем просто кросс-валидация.</p>
<p>Часто выделяют “офлайн” и “онлайн” режимы валидации. И метрики, полученные на кросс-валидации относятся к первому режиму, “офлайн”. То есть мы один раз собрали обучающие данные, они больше не меняются, и вот с таким статическим срезом данных мы работаем, создаем признаки, обучаем модели, измеряем значения метрик на кросс-валидации. Но это не отвечает на вопрос, что получится, когда мы “выкатим модель в прод”, какие значения метрик ожидать на новых данных. И тут, как правило, устраиваются A/B-тесты, которые позволяют понять, а действительно ли мы видим эффект от модели, лучше ли вообще с моделью, чем без нее, а если лучше с моделью, то какую модель выбрать. A/B-тестирование – это очень обширная тема, выходящая за рамки данной статьи, и развивать ее тут мы не будем. Только отметим, что определение схемы валидации – зачастую нетривиальный процесс и в зависимости от проекта может быть методологически сложным, в том числе и приводить к ошибкам.</p>
<p>Также заметим, что AutoML, о котором столь многие мечтают, решает некоторые вопросы, но далеко не все. В частности, алгоритмы AutoML не подберут вам правильную схему валидации. Они работают с уже имеющейся схемой валидации, и если валидация неверна, приводит к ошибкам, то тут и AutoML не поможет. Так что Data-Scientist-ов AutoML пока не вытеснит.</p>
<p><strong>Пример 1. Рекомендация новостного контента</strong></p>
<p>В этой задаче для выбора модели и ее гиперпараметров можно использовать обычную кросс-валидацию, но вот чтоб убедиться, что “в бою” модель также работает, лучше настроить A/B-тест (а точнее, для задач ранжирования намного лучше использовать <a class="reference external" href="https://sease.io/2020/05/online-testing-for-learning-to-rank-interleaving.html">интерливинг</a>).  Пришло время сказать, что этот пример взят из практики автора этой лекции, Юрия Кашницкого, и в <a class="reference external" href="https://www.youtube.com/watch?v=uK4hPD12YmI">выступлении на DataFest 2018</a> описывались сложности валидации модели в задаче рекомендации новостей. Вывод такой, что в задачах рекомендации (да и во многих других) надо устроить онлайн-проверку модели (A/B-тест, интерливинг) помимо офлайн-проверки (кросс-валидации), только таким образом можно удостовериться, что модель действительно полезна, например, что использовать модель – лучше, чем просто показывать самый популярный контент.</p>
<p><strong>Пример 2. Автоматическая оценка читаемости научной статьи</strong></p>
<p>Здесь тоже может использоваться обычная кросс-валидация, хотя на практике из-за объемов данных и размера модели кросс-валидацию проводить будет дороговато и придется удовлетвориться разбиением обучающей выборки на две части и проверкой модели на отложенной части.</p>
<p>Есть, конечно, детали. BERT не очень хорошо работает с длинными текстами, так что скорее всего мы разобьем полный текст статьи на параграфы и будем их подавать в модель по очереди. В таком случае лучше проводить <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.GroupKFold.html">GroupKFold кросс-валидацию</a> так, чтобы на каждом этапе кросс-валидации в обучающей и проверочной выборке были параграфы из разных статей. Мы вряд ли хотим обучаться на одной половине статьи и проверять модель на второй ее половине – так бы мы получили слишком оптимистичную оценку качества модели.</p>
<p>Но даже при оговоренных тонкостях кросс-валидации самая большая сложность данной задачи – убедиться, что метрика качества соответствует тому, что мы реально хотим получить в задаче. Это связано со сложностью определения “хорошо” и “плохо” написанного научного текста, о которой мы говорили выше. Поэтому в данной задаче, как и во многих других практических задачах машинного обучения, не обойтись без проверки результатов модели вручную. Такая проверка модели будет делаться уже после кросс-валидации, и в этом смысле она похожа на онлайн-оценку модели.</p>
<p><strong>Пример 3. Детекция симптомов COVID-19 на рентгенограммах</strong></p>
<p>Здесь схема проверки модели очень похожа на предыдущую. Сначала кросс-валидация или проверка модели на отложенной части, а потом – проверка предсказаний модели экспертами. Конечно, никто не будет по одной только кросс-валидации или результатам участников в соревновании Kaggle заключать, что модель прекрасно работает и ее можно нести врачам. В данном случае надо проверить модель на данных, приближенных к тем, которые будут использоваться врачами на практике. Чтобы не было <a class="reference external" href="https://www.technologyreview.com/2020/04/27/1000658/google-medical-ai-accurate-lab-real-life-clinic-covid-diabetes-retina-disease/">таких историй</a>, как у Google Health, когда Deep Learning модель достигала 90% верных ответов при определении диабетической ретинопатии по фото зрачка, но при обучении на качественных снимках высокого разрешения. А при работе с менее качественными снимками система просто слишком часто отказывалась выносить вердикт из-за того, что была недостаточно уверена в прогнозе.</p>
</div>
<div class="section" id="id10">
<h5>Заключение<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h5>
<p>В этой лекции мы описали, из чего складывается постановка задачи машинного обучения и рассмотрели, как общие компоненты проглядываются в разных по своей природе задачах. При этом мы поговорили о моделях-рабочих лошадках в трех разных областях: градиентном бустинге для табличных данных, BERT для текстов и YOLO для детекции изображений.</p>
<p>Немного пожертвовав, возможно, строгостью определения таких понятий как целевой признак или решатель, мы, надеюсь, описали все “пазлы” достаточно абстрактно, чтоб сложилось общее представление о том, как машинное обучение применяется в разных задачах, а также какие подводные камни стоит ожидать при боевом применении машинного обучения. Надеемся, это позволит лучше осознать взаимосвязь разных компонентов в квантово-классических схемах обучения, о которых речь пойдет далее в курсе.</p>
</div>
</div>
</div>
</div>
<div class="toctree-wrapper compound">
<span id="document-book/qcblock/qcintro"></span><div class="section" id="qcintro">
<span id="id1"></span><h3>О блоке<a class="headerlink" href="#qcintro" title="Permalink to this headline">¶</a></h3>
<p>Этот блок включает в себя:</p>
<ul class="simple">
<li><p>общий рассказ о том, что такое квантовый бит;</p></li>
<li><p>введение в основные квантовые гейты.</p></li>
</ul>
<p>Продвинутые темы блока дополнительно рассказывают:</p>
<ul class="simple">
<li><p>о квантовой физике, на которой базируется концепция кубита;</p></li>
<li><p>о смешанных состояниях, операторе плотности и энтропии фон Неймана;</p></li>
<li><p>об алгоритмах Шора и Гровера.</p></li>
</ul>
</div>
<span id="document-book/qcblock/qubit"></span><div class="section" id="qubit">
<span id="id1"></span><h3>Квантовый бит<a class="headerlink" href="#qubit" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id2">
<h4>Описание лекции<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>Эта лекция расскажет:</p>
<ul class="simple">
<li><p>что такое кубит;</p></li>
<li><p>в чем разница между значением и состоянием;</p></li>
<li><p>что такое сфера Блоха;</p></li>
<li><p>какие можно делать операции над кубитами;</p></li>
<li><p>что такое измерение.</p></li>
</ul>
</div>
<div class="section" id="id3">
<h4>Введение<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>Это первая лекция основного блока нашего курса. Прежде чем мы начнем детально разбирать понятие кубита, давайте взглянем на общий пайплайн квантовых схем.</p>
<div class="figure align-default" id="qscheme">
<img alt="../_images/diagram1.png" src="../_images/diagram1.png" />
<p class="caption"><span class="caption-number">Fig. 34 </span><span class="caption-text">Схема любого квантового алгоритма</span><a class="headerlink" href="#qscheme" title="Permalink to this image">¶</a></p>
</div>
<p>Любая квантовая схема включает в себя:</p>
<ul class="simple">
<li><p>кубиты, инициализируемые в начальное состояние, обычно <span class="math notranslate nohighlight">\(\ket{0}\)</span>;</p></li>
<li><p>унитарные и обратимые операции над кубитами;</p></li>
<li><p>измерение кубитов.</p></li>
</ul>
<p>Эта лекция посвящена разбору операций для одного кубита. Начнем с понятия кубита и его отличий от бита классических компьютеров.</p>
</div>
<div class="section" id="id4">
<h4>Что такое кубит<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>Классический компьютер оперирует двоичными числами – нулем и единицей. Минимальный объем информации для классического компьютера называется бит. Квантовый компьютер оперирует квантовыми битами или кубитами, которые тоже имеют два возможных значения – 0 и 1. Так в чем же разница? В чем особенности квантовых компьютеров, которые дают им преимущества над классическими компьютерами?</p>
<p>Разница в том, что для квантовомеханических систем (и кубитов в частности) их <em>состояния</em> и <em>значения</em> – это не одно и то же.</p>
</div>
<div class="section" id="vs">
<h4>Состояние vs значение<a class="headerlink" href="#vs" title="Permalink to this headline">¶</a></h4>
<div class="section" id="id5">
<h5>Состояние классического бита<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h5>
<p>Обычно мы не отличаем состояние классического бита от его значения и считаем, что если бит имеет значение <strong>1</strong>, то и состояние его описывается числом <strong>1</strong>.</p>
</div>
<div class="section" id="id6">
<h5>Кот Шредингера<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h5>
<p>Давайте вспомним мысленный эксперимента Шредингера. Кот, который одновременно и жив, и мертв. Понятно, что <em>значение</em> кота точно одно: он либо жив, либо мертв. Но <em>состояние</em> его более сложное. Он находится в <em>суперпозиции</em> состояний “жив” и “мертв” одновременно.</p>
<div class="figure align-default" id="schrodingers-cat">
<a class="reference internal image-reference" href="../_images/Schrodingers_cat.svg"><img alt="../_images/Schrodingers_cat.svg" src="../_images/Schrodingers_cat.svg" width="600px" /></a>
<p class="caption"><span class="caption-number">Fig. 35 </span><span class="caption-text">Код Шредингера</span><a class="headerlink" href="#schrodingers-cat" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="id7">
<h5>Состояние кубита<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h5>
<p>Состояние кубита, если можно так сказать, аналогично состоянию кота Шредингера. Оно отличается от <em>значения</em> кубита и описывается вектором из двух комплексных чисел. Мы будем обозначать состояния (или вектора) символом <span class="math notranslate nohighlight">\(\ket{\Psi}\)</span> (кет – вектор-столбец) – это широко принятая в квантовой механике и квантовых вычислениях нотация Дирака:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\ket{\Psi} = \begin{bmatrix}
c_0 \\
c_1
\end{bmatrix}
\end{split}\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Может возникнуть вопрос, а почему комплексные числа? Короткий ответ на этот вопрос дать сложно. Если в двух словах, то использование комплексных чисел связано с удобством представления матричных групп, используемых в квантовой механике.</p>
<p>Все еще звучит сложно??? Тогда нужно вспомнить, что изначально квантовая механика возникла, в том числе из-за того, что физики экпериментально обнаружили у фундаментальных
частиц свойство <code class="docutils literal notranslate"><span class="pre">корпускулярно-волнового</span> <span class="pre">дуализма</span></code>. Иными словами, электроны, фотоны и другие частицы проявляли как типичные свойства волнового движения (например
интерференцию и дифракцию), и свойства частиц – например, всегда есть минимальная порция (<code class="docutils literal notranslate"><span class="pre">квант</span></code>!) света или электричества. Кстати, часто вместо вектора состояния
используется понятие <code class="docutils literal notranslate"><span class="pre">волновой</span> <span class="pre">функции</span></code>, которая описывает плотность вероятности обнаружить частицу в той или иной точке пространства (обычного или специального). Ко
времени создания квантоваой механики для описания волнового движения ученые уже привыкли использовать комплескные числа, которые позволяют упростить описание многих
эффектов за счет разделения амплитуды и фазы процесса. Такое удобство справедливо и для многих задач квантовой физики.</p>
<p>Для более детального ответа авторы курса рекомендуют читать книги по истории квантовой физики (и по самой квантовой физике).</p>
</div>
<p>Значение чисел <span class="math notranslate nohighlight">\(c_0\)</span> и <span class="math notranslate nohighlight">\(c_1\)</span> мы обсудим чуть позже, а пока запишем наш кубит <span class="math notranslate nohighlight">\(\ket{\Psi}\)</span> в коде Python. Для начала <span class="math notranslate nohighlight">\(c_0 = c_1 = \frac{1}{\sqrt{2}}\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">qubit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>Здесь мы создаем именно вектор-столбец размерности <span class="math notranslate nohighlight">\(2\times1\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">qubit</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(2, 1)
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id8">
<h5>Связь состояния и значения кубита<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h5>
<p>Разберем подробнее вектор <span class="math notranslate nohighlight">\(\ket{\Psi}\)</span> и значение цифр <span class="math notranslate nohighlight">\(c_0, c_1\)</span>. Посмотрим на состояния кубита, значение которого мы знаем точно. То есть “посмотрим на кота Шредингера”, но который точно жив или точно мертв.</p>
<div class="section" id="id9">
<h6>Базисные состояния<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h6>
<p>Посмотрим, как выглядят состояния кубитов с точно определенными значениями:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\ket{0} = \begin{bmatrix}
1 \\ 0
\end{bmatrix} \text{\qquad}
\ket{1} = \begin{bmatrix}
0 \\ 1
\end{bmatrix}
\end{split}\]</div>
<p>Что мы можем сказать об этих состояниях? Как минимум следующее:</p>
<ul class="simple">
<li><p>они ортогональны (<span class="math notranslate nohighlight">\(\ket{0} \perp \ket{1}\)</span>);</p></li>
<li><p>они имеют единичную норму;</p></li>
<li><p>они образуют базис.</p></li>
</ul>
<p>Что это значит для нас? А то, что любое состояние <span class="math notranslate nohighlight">\(\ket{\Psi}\)</span> можно записать как линейную комбинацию векторов <span class="math notranslate nohighlight">\(\ket{0}\)</span> и <span class="math notranslate nohighlight">\(\ket{1}\)</span>, причем коэффициентами в этой комбинации будут как раз наши <span class="math notranslate nohighlight">\(c_0, c_1\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">basis_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">basis_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

<span class="n">c0</span> <span class="o">=</span> <span class="n">c1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">qubit</span><span class="p">,</span> <span class="n">c0</span> <span class="o">*</span> <span class="n">basis_0</span> <span class="o">+</span> <span class="n">c1</span> <span class="o">*</span> <span class="n">basis_1</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id10">
<h6>Амплитуды вероятностей<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h6>
<p>Квантовая механика устроена таким интересным образом, что если мы будем измерять <strong>значение</strong> кубита, то вероятность каждого из вариантов будет пропорциональна соответствующему коэффициенту в разложении <strong>состояния</strong>. Но так как амплитуды – это в общем случае комплексные числа, а вероятности должны быть строго действительные, нужно домножить амплитуды на комплексно сопряженные значения. В случае наших значений <span class="math notranslate nohighlight">\(c_0 = c_1 = \frac{1}{\sqrt{2}}\)</span> получаем:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">p0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">c0</span><span class="p">)</span> <span class="o">*</span> <span class="n">c0</span>
<span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span> <span class="o">*</span> <span class="n">c1</span>

<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">p0</span> <span class="o">+</span> <span class="n">p1</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
True
</pre></div>
</div>
</div>
</div>
<p>Видим еще одну важную вещь: сумма вероятностей всех состояний должна быть равна 100%. Это сразу приводит нас к тому, что состояния – это не любые комплексные вектора, а комплексные вектора с единичной нормой:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">qubit</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<p>Мы будем очень часто пользоваться транспонированием и взятием комплексно сопряженного от векторов. В квантовой механике это имеет специальное обозначение <span class="math notranslate nohighlight">\(\bra{\Psi} = \Psi^{T*} = \Psi^\dagger\)</span> (бра – вектор-строка). Тогда наше правило нормировки из =NumPy= кода может быть записано в нотации Дирака так:</p>
<div class="math notranslate nohighlight">
\[
\braket{\Psi} = 1
\]</div>
</div>
</div>
</div>
<div class="section" id="id11">
<h4>Сфера Блоха<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<p>Описанный выше базис <span class="math notranslate nohighlight">\(\ket{0}, \ket{1}\)</span> не является единственно возможным. Вектора <span class="math notranslate nohighlight">\(\ket{0}, \ket{1}\)</span> – это лишь самый часто применимый базис, который называют <span class="math notranslate nohighlight">\(\mathbf{Z}\)</span> базисом. Но есть и другие варианты.</p>
<div class="section" id="id12">
<h5>Возможные базисы<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h5>
<div class="section" id="z">
<h6>Z-базис<a class="headerlink" href="#z" title="Permalink to this headline">¶</a></h6>
<p>Уже описанные нами <span class="math notranslate nohighlight">\(\ket{0}\)</span> и <span class="math notranslate nohighlight">\(\ket{1}\)</span>.</p>
</div>
<div class="section" id="x">
<h6>X-базис<a class="headerlink" href="#x" title="Permalink to this headline">¶</a></h6>
<p>Базисные состояния <span class="math notranslate nohighlight">\(\ket{+} = \frac{\ket{0} + \ket{1}}{\sqrt{2}}\)</span> и <span class="math notranslate nohighlight">\(\ket{-} = \frac{\ket{0} - \ket{1}}{\sqrt{2}}\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plus</span> <span class="o">=</span> <span class="p">(</span><span class="n">basis_0</span> <span class="o">+</span> <span class="n">basis_1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">minus</span> <span class="o">=</span> <span class="p">(</span><span class="n">basis_0</span> <span class="o">-</span> <span class="n">basis_1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="y">
<h6>Y-базис<a class="headerlink" href="#y" title="Permalink to this headline">¶</a></h6>
<p>Базисные состояния <span class="math notranslate nohighlight">\(\ket{R} = \frac{\ket{0} + i\ket{1}}{\sqrt{2}}\)</span> и <span class="math notranslate nohighlight">\(\ket{L} = \frac{\ket{0} - i\ket{1}}{\sqrt{2}}\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">R</span> <span class="o">=</span> <span class="p">(</span><span class="n">basis_0</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">basis_1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">L</span> <span class="o">=</span> <span class="p">(</span><span class="n">basis_0</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">basis_1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Легко убедиться, что все вектора каждого из этих базисов ортогональны:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">basis_0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">basis_1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">plus</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">minus</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">L</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
True
True
</pre></div>
</div>
</div>
</div>
<p>Заметьте, что в наших векторных пространствах скалярное произведение – это <span class="math notranslate nohighlight">\(\vec{a}\vec{b} = \left\langle a\middle| b\right\rangle\)</span> (бра-кет). Именно поэтому нужно делать транспонирование и комплексное сопряжение первого вектора в паре.</p>
</div>
</div>
<div class="section" id="id13">
<h5>Сфера Блоха<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h5>
<p>Обозначения <span class="math notranslate nohighlight">\(\ket{0}, \ket{1}, \ket{+}, \ket{-}, \ket{R}, \ket{L}\)</span> выбраны неслучайно: они имеют геометрический смысл.</p>
<div class="figure align-default" id="blochcphere">
<a class="reference internal image-reference" href="../_images/Blochsphere.svg"><img alt="../_images/Blochsphere.svg" src="../_images/Blochsphere.svg" width="400px" /></a>
<p class="caption"><span class="caption-number">Fig. 36 </span><span class="caption-text">Сфера Блоха</span><a class="headerlink" href="#blochcphere" title="Permalink to this image">¶</a></p>
</div>
<p>Принято считать, что ось <span class="math notranslate nohighlight">\(\mathbf{Z}\)</span> – это основная ось, так как физически квантовые компьютеры измеряют именно по ней. Ось <span class="math notranslate nohighlight">\(\mathbf{X}\)</span> “смотрит на нас” и поэтому обозначается <span class="math notranslate nohighlight">\(\ket{+}\)</span> и <span class="math notranslate nohighlight">\(\ket{-}\)</span>. А ось <span class="math notranslate nohighlight">\(\mathbf{Y}\)</span> направлена как бы вдоль, поэтому базис обозначают как “право” (<span class="math notranslate nohighlight">\(\ket{R}\)</span>) и “лево” (<span class="math notranslate nohighlight">\(\ket{L}\)</span>).</p>
<p>Вектор состояния кубита еще называют волновой функцией и этот вектор может идти в любую точку сферы Блоха. Сама сфера имеет единичный радиус и это гарантирует нам, что для всех состояний сумма квадратов амплитуд будет равна единице.</p>
<div class="section" id="id14">
<h6>Состояние в полярных координатах<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h6>
<p>Состояние кубита можно выразить через полярные координаты на сфере Блоха:</p>
<div class="math notranslate nohighlight">
\[
\ket{\Psi} = c_0 \ket{0} + c_1 \ket{1} = \cos\theta\ket{0} + e^{i\phi}\sin\theta \ket{1},
\]</div>
<p>где <span class="math notranslate nohighlight">\(\theta,\phi\)</span> – это угловые координаты на сфере Блоха. В этом смысле сфера Блоха очень удобна для представления состояний одного кубита.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Тут мы воспользовались формулой Эйлера, а также вынесли за скобки локальные фазы множителей <span class="math notranslate nohighlight">\(c_0\)</span> и <span class="math notranslate nohighlight">\(c_1\)</span>. Если у вас возникают трудности с подобными операциями над комплексными числами, то рекомендуем еще раз пересмотреть базовую лекцию по линейной алгебре и комплексным числам, там эти моменты освещаются более подробно.</p>
</div>
</div>
</div>
</div>
<div class="section" id="id15">
<h4>Что можно делать с таким кубитом?<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h4>
<div class="section" id="id16">
<h5>Линейные операторы<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h5>
<p>Любое действие, которое мы совершаем с кубитом в состоянии <span class="math notranslate nohighlight">\(\ket{\Psi}\)</span>, должно переводить его в другое состояние <span class="math notranslate nohighlight">\(\ket{\Phi}\)</span>. Что переводит один вектор в другой вектор в том же пространстве? Правильно, матрица. Другими словами, линейный оператор. Мы будем обозначать операторы как <span class="math notranslate nohighlight">\(\hat{U}\)</span>.</p>
</div>
<div class="section" id="id17">
<h5>Унитарность<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h5>
<p>Как мы уже говорили, квадраты амплитуд – это вероятности. Следовательно, волновая функция должна быть нормирована на единицу. А значит, любой оператор, который переводит одно состояние в другое <span class="math notranslate nohighlight">\(\hat{U}\ket{\Psi} = \ket{\Phi}\)</span>, должен сохранять эту нормировку, то есть должен быть <em>унитарным</em>. Более того, свойство унитарности приводит к тому, что любой квантовый оператор еще и сохраняет скалярное произведение:</p>
<div class="math notranslate nohighlight">
\[
\bra{\Psi}\hat{U}^\dagger\hat{U}\ket{\Psi} = \bra{\Psi}\ket{\Psi}
\]</div>
<p>Другими словами, унитарный оператор удовлетворяет условию <span class="math notranslate nohighlight">\(\hat{U}^\dagger \hat{U} = \hat{I}\)</span>.</p>
</div>
<div class="section" id="id18">
<h5>Обратимость<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h5>
<p>Одно из важных следствий унитарности операций над кубитами – это их обратимость. Если вы сделали какую-то последовательность унитарных операций над кубитами <span class="math notranslate nohighlight">\(\hat{U}\)</span>, то их можно вернуть в начальное состояние, ведь у унитарного оператора всегда есть обратный оператор <span class="math notranslate nohighlight">\(\hat{U}^{-1} = \hat{U}^\dagger\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Квантовый компьютер должен уметь делать несколько не унитарных операций, например, инициализацию кубита в определенное состояние (например, <span class="math notranslate nohighlight">\(\ket{0}\)</span>) и считывание состояния кубитов. Такие неунитарные операции приводят к потере информации и являются необратимыми.</p>
</div>
</div>
<div class="section" id="id19">
<h5>Пример оператора<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h5>
<p>В дальнейших лекциях мы разберем много операторов, так как именно операторы (или квантовые <strong>гейты</strong>) являются основой квантовых вычислений. А пока посмотрим простой пример: оператор Адамара (<strong>Hadamard gate</strong>), который переводит <span class="math notranslate nohighlight">\(\ket{0} \to \ket{+}\)</span>.</p>
<div class="section" id="id20">
<h6>Гейт Адамара<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h6>
<p>Начнем с того, что пока у нас лишь один кубит. Состояние одного кубита – это вектор размерности два. Значит, оператор, который переводит его в другой вектор размерности два – это матрица <span class="math notranslate nohighlight">\(2\times 2\)</span>. Запишем оператор Адамара в матричном виде, а потом убедимся, что он унитарный и действительно переводит состояние <span class="math notranslate nohighlight">\(\ket{0} \to \ket{+}\)</span>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\hat{H} = \frac{1}{\sqrt{2}}\begin{bmatrix}
1 &amp; 1 \\
1 &amp; -1 \\
\end{bmatrix}
\end{split}\]</div>
<div class="section" id="python">
<h7>Реализация в Python<a class="headerlink" href="#python" title="Permalink to this headline">¶</a></h7>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">h</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
<span class="p">])</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id21">
<h7>Унитарность<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h7>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">@</span> <span class="n">h</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id22">
<h7>Правильное действие<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h7>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">h</span> <span class="o">@</span> <span class="n">basis_0</span><span class="p">,</span> <span class="n">plus</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="id23">
<h4>Измерение<a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h4>
<p><strong>Измерение</strong> в квантовых вычислениях выделяется отдельно именно потому, что оно “открывает” коробку с котом Шредингера: мы точно узнаем, жив он или мертв, и уже никогда не сможем это “забыть” обратно. Вся <em>суперпозиция</em> его состояния исчезает. То есть <em>измерение</em> – это как раз пример одной из не унитарных операций, которые должен уметь делать квантовый компьютер.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Это интересный факт: исчезновение суперпозиции многим кажется парадоксом, именно поэтому и появляются разные интерпретации квантовой механики, например, многомировая интерпретация Эверетта. Действительно, это кажется немного странным, что полностью обратимая квантовая механика и непрерывная динамика волновых функций вдруг “ломаются” и мы получаем такой коллапс, который еще называют редукцией фон Неймана. Доктору Эверетт тоже это не нравилось и он предложил другую интерпретацию этого процесса. Согласно его теории, когда мы производим измерения, мы как бы “расщепляем” нашу вселенную на две ниточки: в одной кот остается жив, а в другой остается мертв.</p>
<p>Такие теории остаются на уровне спекуляций, так как почти невозможно придумать эксперимент, который бы подтверждал или опровергал такую гипотезу. Скорее это вопрос личного понимания и интерпретации процесса, так как математически подобные теории в итоге дают один и тот же наблюдаемый и измеримый результат.</p>
</details>
</div>
<p>Как мы уже говорили, у кубита может быть несколько разных базисов: <span class="math notranslate nohighlight">\(\ket{0}, \ket{1}\)</span>, <span class="math notranslate nohighlight">\(\ket{+}, \ket{-}\)</span>, <span class="math notranslate nohighlight">\(\ket{R}, \ket{L}\)</span>. <em>Значение</em> кубита в каждом из этих базисов может быть измерено. Но что такое измерение с точки зрения математики?</p>
<div class="section" id="id24">
<h5><a class="reference internal" href="book/index.html#term-22"><span class="xref std std-term">Операторы Паули</span></a><a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h5>
<p>На самом деле, любая наблюдаемая величина соответствует какому-то оператору. Например, измерения в разных базисах <span class="math notranslate nohighlight">\(\mathbf{X}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{Y}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{Z}\)</span> соответствуют операторам Паули:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\hat{\sigma^x} = \begin{bmatrix}
0 &amp; 1\\
1 &amp; 0
\end{bmatrix}
\qquad
\hat{\sigma^y} = \begin{bmatrix}
0 &amp; -i\\
i &amp; 0
\end{bmatrix}
\qquad
\hat{\sigma^z} = \begin{bmatrix}
1 &amp; 0\\
0 &amp; -1
\end{bmatrix}
\end{split}\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pauli_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">]])</span>
<span class="n">pauli_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">]])</span>
<span class="n">pauli_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]])</span>
</pre></div>
</div>
</div>
</div>
<p>Эти операторы очень важны, рекомендуется знать их наизусть, так как они встречаются в каждой второй статье по квантовым вычислениям, а также постоянно фигурируют в документации всех основных библиотек для квантового машинного обучения.</p>
</div>
<div class="section" id="id25">
<h5>Собственные значения<a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h5>
<p>Мы поняли, что есть связь между нашими измерениями и операторами. Но какая именно? Что значит, например, что измерения по оси <span class="math notranslate nohighlight">\(\mathbf{Z}\)</span> соответствуют оператору <span class="math notranslate nohighlight">\(\hat{\sigma^Z}\)</span>?</p>
<p>Здесь мы приходим к собственным значениям операторов. Оказывается (так устроен наш мир), что <em>измеряя</em> какую-то величину в квантовой механике, мы всегда будем получать одно из собственных значений соответствующего оператора, а состояние будет коллапсировать в соответствующий собственный вектор этого оператора. Другими словами, <em>измеряя</em> кота Шредингера, мы будем получать значения “жив” или “мертв”, а состояние кота будет переходить в состояние, соответствующее одному из этих значений. А еще <em>измерение</em> не является обратимой операцией: однажды открыв коробку с котом и поняв, жив он или мертв, мы уже не сможем закрыть ее обратно и вернуть кота в суперпозицию.</p>
<p>Описанное выше – не абстрактные рассуждения из квантовой физики. Оно пригодится, когда мы будем говорить о решении практических комбинаторных задач, таких как задача о выделении сообществ в графе.</p>
</div>
<div class="section" id="hat-sigma-z">
<h5>Собственные вектора <span class="math notranslate nohighlight">\(\hat{\sigma^Z}\)</span><a class="headerlink" href="#hat-sigma-z" title="Permalink to this headline">¶</a></h5>
<p>Вернемся к нашему оператору <span class="math notranslate nohighlight">\(\hat{\sigma^Z}\)</span>. Легко убедиться, что его собственные значения равны 1 и -1, а соответствующие им собственные вектора – это <span class="math notranslate nohighlight">\(\begin{bmatrix}1 \\ 0\end{bmatrix}\)</span> и <span class="math notranslate nohighlight">\(\begin{bmatrix}0 \\ 1\end{bmatrix}\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">pauli_z</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(array([ 1.+0.j, -1.+0.j]), array([[1.+0.j, 0.+0.j],
       [0.+0.j, 1.+0.j]]))
</pre></div>
</div>
</div>
</div>
<p>Таким образом, измерение по оси <span class="math notranslate nohighlight">\(\mathbf{Z}\)</span> всегда будет давать нам одно из этих двух значений и переводить состояние кубита в соответствующий собственный вектор.</p>
</div>
<div class="section" id="id26">
<h5>Формальная запись<a class="headerlink" href="#id26" title="Permalink to this headline">¶</a></h5>
<p>Формально мы можем записать для любого эрмитова оператора <span class="math notranslate nohighlight">\(\hat{U}\)</span>, что собственные состояния этого оператора являются его собственными векторами, а собственные значения в этом случае являются наблюдаемыми значениями:</p>
<div class="math notranslate nohighlight">
\[
\hat{U}\ket{\Psi} = u\ket{\Psi}
\]</div>
</div>
<div class="section" id="id27">
<h5>Другие операторы Паули<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h5>
<p>Убедимся, что у остальных операторов собственные значения такие же:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">pauli_x</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">pauli_y</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(array([ 1.+0.j, -1.+0.j]), array([[ 0.70710678-0.j,  0.70710678+0.j],
       [ 0.70710678+0.j, -0.70710678-0.j]]))
(array([ 1.+0.j, -1.+0.j]), array([[-0.        -0.70710678j,  0.70710678+0.j        ],
       [ 0.70710678+0.j        ,  0.        -0.70710678j]]))
</pre></div>
</div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Можно заметить, что у всех операторов Паули нет ни одного общего собственного вектора. Таким образом, мы приходим к ситуации, когда не можем одновременно точно провести измерения двумя разными операторами, так как наше измерение должно переводить состояние в соответствующий собственный вектор. В квантовой механике это называется <strong>принципом неопределенности</strong>.</p>
</div>
</div>
<div class="section" id="id28">
<h5>Ожидаемое значение при измерении<a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h5>
<p>Мы не будем писать с нуля полный симулятор кубитов, который включает измерения – это требует введения сложного случайного процесса. Но мы можем легко ответить на другой вопрос. А именно: можно ли сказать, какое будет <em>ожидаемое</em> значение оператора <span class="math notranslate nohighlight">\(\hat{U}\)</span> для состояния <span class="math notranslate nohighlight">\(\Psi\)</span>? Другими словами, какое будет математическое ожидание большого числа измерений? Это можно записать следующим образом:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{E}(\hat{U}) = \bra{\Psi}\hat{U}\ket{\Psi}
\]</div>
<p>Например, оператор <span class="math notranslate nohighlight">\(\hat{\sigma^z}\)</span> полностью не определен в состоянии <span class="math notranslate nohighlight">\(\ket{+}\)</span>, то есть мы будем равновероятно получать значения -1 и 1, а математическое ожидание, соответственно, будет равно нулю:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">plus</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">pauli_z</span> <span class="o">@</span> <span class="n">plus</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[-2.23711432e-17+0.j]]
</pre></div>
</div>
</div>
</div>
<p>С другой стороны, измеряя состояние <span class="math notranslate nohighlight">\(\ket{+}\)</span> в <em>X</em>-базисе мы всегда будем получать 1:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">plus</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">pauli_x</span> <span class="o">@</span> <span class="n">plus</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[1.+0.j]]
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id29">
<h5>Вероятности битовых строк<a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h5>
<p>Последнее, чего мы коснемся в части измерений – это битовые строки и метод Шредингера. Мы много говорили о вероятностной интерпретации волновой функции и аналогиях с классическим битом, но пока этого никак не касались на практике. Как же получить вероятность определенной битовой строки для произвольного состояния? Если взять все битовые строки размерности вектора состояния и отсортировать их в лексикографическом порядке (например, <span class="math notranslate nohighlight">\(0 &lt; 1\)</span>, <span class="math notranslate nohighlight">\(00 &lt; 01 &lt; 10 &lt; 11\)</span>, и т.д.), то вероятность каждой битовой строки получается следующим выражением:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{P} = | \bra{\Psi}\ket{\vec{s}} |^2,
\]</div>
<p>где <span class="math notranslate nohighlight">\(\vec{s}\)</span> – это вектор, каждая компонента которого соответствует порядковой битовой строке или вектор битовых строк. Другими словами, вероятность получить <em>i</em>-ю битовую строку равна квадрату <em>i</em>-го элемента амплитуды волновой функции. Кажется немного запутанным, но на самом деле <span class="math notranslate nohighlight">\(|\ket{\Psi}|^2\)</span> – это идейно и есть плотность вероятности.</p>
</div>
<div class="section" id="id30">
<h5>Еще пара слов об измерениях<a class="headerlink" href="#id30" title="Permalink to this headline">¶</a></h5>
<div class="section" id="id31">
<h6>Измерение как проекция на пространство собственных векторов<a class="headerlink" href="#id31" title="Permalink to this headline">¶</a></h6>
<p>Мы уже говорили, что при измерении мы как бы “выбираем” один из собственных векторов наблюдаемой. Более строго такой процесс называется проецированием на пространство собственных векторов. Для собственного вектора <span class="math notranslate nohighlight">\(\ket{\Phi}\)</span> проекция будет линейным оператором:</p>
<div class="math notranslate nohighlight">
\[
\hat{P}\_{\ket{\Phi}} = \ket{\Phi}\bra{\Phi}
\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">super_position</span> <span class="o">=</span> <span class="n">h</span> <span class="o">@</span> <span class="n">basis_0</span>
<span class="n">eigenvectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">pauli_z</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

<span class="n">proj_0</span> <span class="o">=</span> <span class="n">eigenvectors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">@</span> <span class="n">eigenvectors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="n">proj_1</span> <span class="o">=</span> <span class="n">eigenvectors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">@</span> <span class="n">eigenvectors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id32">
<h6>Правило Борна<a class="headerlink" href="#id32" title="Permalink to this headline">¶</a></h6>
<p>Вероятность наблюдения каждого из собственных значений <span class="math notranslate nohighlight">\(\lambda\)</span> какого-то оператора <span class="math notranslate nohighlight">\(\hat{U}\)</span> определяется как результат измерения оператора проекции на соответствующий собственный вектор:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{P}(\lambda_i) = \bra{\Psi} \hat{P_i} \ket{\Psi}
\]</div>
<p>Считать ожидаемое значение оператора мы уже умеем. Давайте убедимся, что для состояния <span class="math notranslate nohighlight">\(\ket{\Psi} = \frac{1}{\sqrt{2}}\begin{bmatrix} 1 \\ 1\end{bmatrix}\)</span> результаты измерений операторов проекций дадут 0.5 и совпадут с результатом упражнения, которое мы проделали ранее:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">p_0</span> <span class="o">=</span> <span class="n">super_position</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">proj_0</span> <span class="o">@</span> <span class="n">super_position</span>
<span class="n">p_1</span> <span class="o">=</span> <span class="n">super_position</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">proj_1</span> <span class="o">@</span> <span class="n">super_position</span>

<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">p_0</span> <span class="o">+</span> <span class="n">p_1</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">p_0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
True
</pre></div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="id33">
<h4>Что мы узнали?<a class="headerlink" href="#id33" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>Состояние и значение для кубита – это не одно и то же.</p></li>
<li><p>Состояния представляют собой комплекснозначные вектора.</p></li>
<li><p>Квантовые операторы – унитарные и самосопряженные.</p></li>
<li><p>Измеряемые значения – собственные значения операторов.</p></li>
<li><p>Измерение “ломает” суперпозицию.</p></li>
</ul>
</div>
</div>
<span id="document-book/qcblock/gates"></span><div class="section" id="gates">
<span id="id1"></span><h3>Квантовые гейты<a class="headerlink" href="#gates" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id2">
<h4>Описание лекции<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>Из этой лекции мы узнаем:</p>
<ul class="simple">
<li><p>какие есть основные однокубитные и многокубитные гейты;</p></li>
<li><p>как записывать многокубитные состояния;</p></li>
<li><p>как конструировать многокубитные операторы;</p></li>
<li><p>как работать с библиотекой <code class="docutils literal notranslate"><span class="pre">PennyLane</span></code>.</p></li>
</ul>
</div>
<div class="section" id="id3">
<h4>Введение<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>Квантовые гейты являются основными <em>строительными</em> блоками для любых квантовых схем, в том числе и тех, что применяются для машинного обучения. Можно сказать, что это своеобразный алфавит квантовых вычислений. Он необходим, чтобы сходу понимать, например, что изображено на подобных схемах:</p>
<div class="figure align-default" id="lvqe">
<a class="reference internal image-reference" href="../_images/Layer-VQE.png"><img alt="../_images/Layer-VQE.png" src="../_images/Layer-VQE.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">Fig. 37 </span><span class="caption-text"><a class="reference external" href="https://arxiv.org/abs/2102.05566">Схема Layered-VQE</a></span><a class="headerlink" href="#lvqe" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="id4">
<h4>Основные однокубитные гейты<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>В прошлый раз мы познакомились с <a class="reference internal" href="book/index.html#term-22"><span class="xref std std-term">операторами Паули</span></a>, а также гейтом Адамара. Как для обычных квантовых алгоритмов, так и
для QML-алгоритмов нужны и другие гейты, потому что одни только эти гейты не позволяют перейти во все возможные квантовые состояния.
Теперь давайте посмотрим, какие еще однокубитные гейты часто применяются в квантовых вычислениях и квантовом машинном обучении.</p>
<div class="section" id="t">
<h5>T-гейт<a class="headerlink" href="#t" title="Permalink to this headline">¶</a></h5>
<p>T-гейт очень популярен в универсальных квантовых вычислениях. Его матрица имеет вид:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\hat{T} = \begin{bmatrix}
1 &amp; 0 \\
0 &amp; \frac{1+i}{\sqrt{2}}
\end{bmatrix}
\end{split}\]</div>
<p>Любой однокубитный гейт можно аппроксимировать последовательностью гейтов Адамара и T-гейтов. Чем точнее требуется аппроксимация, тем длиннее будет аппроксимирующая последовательность.</p>
<p>Помимо важной роли в математике квантовых вычислений, гейт Адамара и T-гейт интересны тем, что именно на них построено большинство предложений по реализации квантовых вычислений с топологической защитой или с коррекцией ошибок. На сегодняшний день эти схемы реально пока не очень работают: никаких топологически защищенных кубитов продемонстрировано не было, а коррекция ошибок не выходит за пределы двух логических кубитов.</p>
</div>
<div class="section" id="id5">
<h5>Гейты поворота вокруг оси<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h5>
<p>Поворотные гейты играют центральную роль в квантовом машинном обучении. Вспомним на секунду, как выглядят наши однокубитные состояния на сфере Блоха:</p>
<div class="figure align-default" id="blochsphere">
<a class="reference internal image-reference" href="../_images/Blochsphere.svg"><img alt="../_images/Blochsphere.svg" src="../_images/Blochsphere.svg" width="400px" /></a>
<p class="caption"><span class="caption-number">Fig. 38 </span><span class="caption-text">Сфера Блоха</span><a class="headerlink" href="#blochsphere" title="Permalink to this image">¶</a></p>
</div>
<p>Любой однокубитный гейт можно представить как вращение вектора состояния <span class="math notranslate nohighlight">\(\Psi\)</span> на некоторый угол вокруг некоторой оси, проходящей через центр сферы Блоха.</p>
<p>Гейты <span class="math notranslate nohighlight">\(\hat{RX}(\phi), \hat{RY}(\phi), \hat{RZ}(\phi)\)</span> осуществляют поворот на определенный угол <span class="math notranslate nohighlight">\(\phi\)</span> вокруг соответствующей оси на сфере Блоха.</p>
<p>Давайте внимательно рассмотрим это на примере гейта <span class="math notranslate nohighlight">\(\hat{RY}\)</span>.</p>
<div class="section" id="hat-ry">
<h6>Гейт <span class="math notranslate nohighlight">\(\hat{RY}\)</span><a class="headerlink" href="#hat-ry" title="Permalink to this headline">¶</a></h6>
<p>Сам гейт определяется следующим образом:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\hat{RY}(\phi) = \begin{bmatrix}
\cos(\frac{\phi}{2}) &amp; -\sin(\frac{\phi}{2}) \\
\sin(\frac{\phi}{2}) &amp; \cos(\frac{\phi}{2})
\end{bmatrix}
\end{split}\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">ry</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">phi</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)],</span>
        <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>  <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)]</span>
    <span class="p">])</span> <span class="o">@</span> <span class="n">state</span>
</pre></div>
</div>
</div>
</div>
<p>Запишем наше состояние <span class="math notranslate nohighlight">\(\ket{0}\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>Внимательно посмотрим на сферу Блоха. Можно заметить, что если повернуть состояние из <span class="math notranslate nohighlight">\(\ket{0}\)</span> на <span class="math notranslate nohighlight">\(\pi\)</span> и измерить значение <span class="math notranslate nohighlight">\(\hat{\sigma^z}\)</span>, то получится 1. А если повернуть на <span class="math notranslate nohighlight">\(-\pi\)</span>, то получится 0:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">expval</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">state</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">op</span> <span class="o">@</span> <span class="n">state</span>

<span class="n">pauli_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">]])</span>

<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">expval</span><span class="p">(</span><span class="n">ry</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">pauli_x</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">expval</span><span class="p">(</span><span class="n">ry</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">pauli_x</span><span class="p">),</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
True
</pre></div>
</div>
</div>
</div>
<p>Убедимся также, что вращение на угол, пропорциональный <span class="math notranslate nohighlight">\(2\pi\)</span>, не меняет результат измерения. Возьмем случайное состояние:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\ket{\Psi} = \begin{bmatrix}
0.42 \\
\sqrt{1 - 0.42^2}
\end{bmatrix}
\end{split}\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">random_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.42</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">0.42</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>Измерим его по осям <span class="math notranslate nohighlight">\(\mathbf{X}\)</span> и <span class="math notranslate nohighlight">\(\mathbf{Z}\)</span>, затем повернем на угол <span class="math notranslate nohighlight">\(2\pi\)</span> и измерим снова:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pauli_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]])</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Z:</span><span class="se">\n\t</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">expval</span><span class="p">(</span><span class="n">random_state</span><span class="p">,</span> <span class="n">pauli_z</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;X:</span><span class="se">\n\t</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">expval</span><span class="p">(</span><span class="n">random_state</span><span class="p">,</span> <span class="n">pauli_x</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Z after RY:</span><span class="se">\n\t</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">expval</span><span class="p">(</span><span class="n">ry</span><span class="p">(</span><span class="n">random_state</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span> <span class="n">pauli_z</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;X after RY:</span><span class="se">\n\t</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">expval</span><span class="p">(</span><span class="n">ry</span><span class="p">(</span><span class="n">random_state</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span> <span class="n">pauli_x</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Z:
	[[-0.6472+0.j]]

X:
	[[0.76232025+0.j]]

Z after RY:
	[[-0.6472+0.j]]

X after RY:
	[[0.76232025+0.j]]
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id6">
<h6>Другие гейты вращений<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h6>
<p>Аналогичным образом определяются гейты <span class="math notranslate nohighlight">\(\hat{RX}\)</span> и <span class="math notranslate nohighlight">\(\hat{RZ}\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\hat{RX}(\phi) = \begin{bmatrix}
\cos(\frac{\phi}{2}) &amp; -i\sin(\frac{\phi}{2}) \\
-i\sin(\frac{\phi}{2}) &amp; \cos(\frac{\phi}{2})
\end{bmatrix} \qquad \hat{RZ}(\phi) = \begin{bmatrix}
e^{-\frac{i\phi}{2}} &amp; 0 \\
0 &amp; e^{\frac{i\phi}{2}}
\end{bmatrix}
\end{split}\]</div>
</div>
<div class="section" id="id7">
<h6>Общая форма записи однокубитных гейтов<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h6>
<p>В общем случае однокубитные гейты могут быть также записаны следующим образом:</p>
<div class="math notranslate nohighlight">
\[
\large \hat{R}^\vec{n}(\alpha) = e^{-\frac{i\alpha\hat{\vec{\sigma}}\vec{n}}{2}},
\]</div>
<p>где <span class="math notranslate nohighlight">\(\alpha\)</span> – это угол поворота, <span class="math notranslate nohighlight">\(\vec{n}\)</span> – единичный вектор в направлении оси поворота, а <span class="math notranslate nohighlight">\(\hat{\vec{\sigma}} = \{\hat{\sigma}^x, \hat{\sigma}^y, \hat{\sigma}^z\}\)</span> – это вектор, составленный из операторов Паули. Если использовать покоординатную запись и <span class="math notranslate nohighlight">\(\vec{n} = \{n_x, n_y, n_z\}\)</span> задает ось вращения, то</p>
<div class="math notranslate nohighlight">
\[
\large \hat{R}^\vec{n}(\alpha) = e^{-i\frac{\alpha}{2}\left(\hat{\sigma}^xn_x+\hat{\sigma}^yn_y+\hat{\sigma}^zn_z\right)}.
\]</div>
<p>Забегая вперед, можно сказать, что именно гейты вращений – это основа квантовых вариационных схем, главного инструмента этого курса.</p>
</div>
</div>
<div class="section" id="phase-shift">
<h5>Phase-shift гейт<a class="headerlink" href="#phase-shift" title="Permalink to this headline">¶</a></h5>
<p>Другой важный гейт – это так называемый phase-shift гейт или <span class="math notranslate nohighlight">\(\hat{U}_1\)</span> гейт. Его матричная форма имеет следующий вид:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\hat{U}_1(\phi) = \begin{bmatrix}
1 &amp; 0 \\
0 &amp; e^{i\phi}
\end{bmatrix}
\end{split}\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">u1</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">phi</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phi</span><span class="p">)]])</span> <span class="o">@</span> <span class="n">state</span>
</pre></div>
</div>
</div>
</div>
<p>Легко видеть, что с точностью до глобального фазового множителя, который ни на что не влияет, Phase-shift-гейт – это тот же <span class="math notranslate nohighlight">\(\hat{RZ}(\phi)\)</span>.
Он играет важную роль в квантовых ядерных методах.</p>
</div>
<div class="section" id="hat-u-2-hat-u-3">
<h5>Гейты <span class="math notranslate nohighlight">\(\hat{U}_2\)</span> и <span class="math notranslate nohighlight">\(\hat{U}_3\)</span><a class="headerlink" href="#hat-u-2-hat-u-3" title="Permalink to this headline">¶</a></h5>
<p>Более редкие в QML гейты, которые однако все равно встречаются в статьях.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\hat{U}_2(\phi, \lambda) = \frac{1}{\sqrt{2}}\begin{bmatrix}
1 &amp; -e^{i\lambda} \\
e^{i\phi} &amp; e^{i(\phi + \lambda)}
\end{bmatrix} = \hat{U}_1(\phi + \lambda)\hat{RZ}(-\lambda)\hat{RY}(\frac{\pi}{2})\hat{RZ}(\lambda)
\end{split}\]</div>
<p>Давайте убедимся в справедливости этого выражения:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">rz</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">phi</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)]])</span> <span class="o">@</span> <span class="n">state</span>


<span class="k">def</span> <span class="nf">u2_direct</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="mi">1</span>
        <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">l</span><span class="p">)],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phi</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="p">(</span><span class="n">phi</span> <span class="o">+</span> <span class="n">l</span><span class="p">))]])</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">u2_inferenced</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">u1</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">phi</span> <span class="o">+</span> <span class="n">l</span><span class="p">)</span>
        <span class="o">@</span> <span class="n">rz</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="n">l</span><span class="p">)</span>
        <span class="o">@</span> <span class="n">ry</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="o">@</span> <span class="n">rz</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">l</span><span class="p">)</span>
    <span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">u2_direct</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">6</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">),</span> <span class="n">u2_inferenced</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">6</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<p>Схожим образом определяется <span class="math notranslate nohighlight">\(\hat{U}_3(\theta, \phi, \lambda)\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\hat{U}_3(\theta, \phi, \lambda) = \begin{bmatrix}
\cos(\frac{\theta}{2}) &amp; -e^{1j\lambda}\sin(\frac{\theta}{2}) \\
e^{1j\phi}\sin(\frac{\theta}{2}) &amp; e^{1j(\phi + \lambda)}\cos(\frac{\theta}{2})
\end{bmatrix} = \hat{U}_1(\phi + \lambda)\hat{RZ}(-\lambda)\hat{RY}(\theta)\hat{RZ}(\lambda)
\end{split}\]</div>
<p>Читатель может сам легко убедиться, что эти формы записи эквивалентны. Для этого надо написать примерно такой же код, что мы писали раньше для <span class="math notranslate nohighlight">\(\hat{U}_2\)</span>.</p>
</div>
<div class="section" id="id8">
<h5>Еще пара слов об однокубитных гейтах<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h5>
<p>На этом мы завершаем обзор основных однокубитных гейтов. Маленькое замечание: гейты, связанные со сдвигом фазы, никак не меняют состояние кубита, если оно сейчас <span class="math notranslate nohighlight">\(\ket{0}\)</span>. Так как мы всегда предполагаем, что начальное состояние кубитов – это именно <span class="math notranslate nohighlight">\(\ket{0}\)</span>, то перед применением, например, <span class="math notranslate nohighlight">\(\hat{U}_1\)</span>, рекомендуется применить гейт Адамара:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">u1</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">6</span><span class="p">),</span> <span class="n">basis</span><span class="p">))</span>

<span class="n">h</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">u1</span><span class="p">(</span><span class="n">h</span> <span class="o">@</span> <span class="n">basis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">6</span><span class="p">),</span> <span class="n">h</span> <span class="o">@</span> <span class="n">basis</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
False
</pre></div>
</div>
</div>
</div>
<div class="section" id="id9">
<h6>Единичный гейт<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h6>
<p>Самое последнее об однокубитных гейтах – это единичный гейт <span class="math notranslate nohighlight">\(\hat{I}\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\hat{I} = \begin{bmatrix}
1 &amp; 0 \\
0 &amp; 1
\end{bmatrix}
\end{split}\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[1.+0.j 0.+0.j]
 [0.+0.j 1.+0.j]]
</pre></div>
</div>
</div>
</div>
<p>Он не делает с кубитом ровным счетом ничего. Но единичный гейт понадобится нам позже, когда мы будем конструировать многокубитные операторы.</p>
</div>
</div>
</div>
<div class="section" id="id10">
<h4>Многокубитные состояния и гейты<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h4>
<p>Очевидно, что с одним кубитом ничего интересного, кроме разве что генератора истинно-случайных чисел, мы не сделаем. Для начала разберемся, как выглядят состояния для многокубитных систем.</p>
<div class="section" id="id11">
<h5>Многокубитные состояния<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h5>
<p>В классическом компьютере один бит имеет два значения – 0 и 1. Два бита имеют четыре значения – 00, 01, 10, 11. Три бита имеют восемь значений и так далее. Аналогично состояние двух кубитов – это вектор в пространстве <span class="math notranslate nohighlight">\(\mathbf{C}^4\)</span>, состояние трех кубитов – вектор в пространстве <span class="math notranslate nohighlight">\(\mathbf{C}^8\)</span>, то есть состояние <span class="math notranslate nohighlight">\(N\)</span> кубитов описывается вектором размерности <span class="math notranslate nohighlight">\(2^N\)</span> в комплексном пространстве. Вероятности каждой из возможных битовых строк (<span class="math notranslate nohighlight">\(0000...00\)</span>, <span class="math notranslate nohighlight">\(0000...01\)</span>, <span class="math notranslate nohighlight">\(0000...10\)</span>, и так далее) получаются по методу Шредингера, который мы обсуждали в конце прошлой лекции:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{P}(\vec{s}) = | \bra{\Psi}\ket{\vec{s}} |^2
\]</div>
<p>Нужно отсортировать наши битовые строки в лексикографическом порядке – и вероятность <em>i</em>-й битовой строки будет равна квадрату <em>i</em>-го элемента вектора <span class="math notranslate nohighlight">\(\ket{\Psi}\)</span>.</p>
<p>Формально многокубитные состояния описываются с помощью математического концепта так называемого тензорного произведения, иначе – произведения Кронекера, обозначаемого значком <span class="math notranslate nohighlight">\(\otimes\)</span>. Так, если <span class="math notranslate nohighlight">\(\ket{\Psi}_A \in \mathrm{H}_A\)</span> и <span class="math notranslate nohighlight">\(\ket{\Psi}_B \in \mathrm{H}_B\)</span>, то <span class="math notranslate nohighlight">\(\ket{\Psi}_{AB} = \ket{\Psi}_A \otimes \ket{\Psi}_B \in \mathrm{H}_{AB} = \mathrm{H}_{A} \otimes \mathrm{H}_{B}\)</span>. О том, как элементы вектора <span class="math notranslate nohighlight">\(\ket{\Psi}_{AB}\)</span> выражаются через элементы векторов <span class="math notranslate nohighlight">\(\ket{\Psi}_{A}\)</span> и <span class="math notranslate nohighlight">\(\ket{\Psi}_{B}\)</span>, можно прочитать на Википедии в статье <a class="reference external" href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5_%D0%9A%D1%80%D0%BE%D0%BD%D0%B5%D0%BA%D0%B5%D1%80%D0%B0/">“Произведение Кронекера”</a>.</p>
</div>
<div class="section" id="id12">
<h5>Многокубитные операторы<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h5>
<p>Как мы уже обсуждали ранее, квантовые операторы должны переводить текущее состояние в новое в том же пространстве и сохранять нормировку, а еще должны быть обратимыми. Значит, оператор для состояния из <span class="math notranslate nohighlight">\(N\)</span> кубитов – это унитарная комплексная матрица размерности <span class="math notranslate nohighlight">\(2^N \times 2^N\)</span>.</p>
</div>
<div class="section" id="id13">
<h5>Конструирование многокубитных операторов<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h5>
<p>Прежде чем мы начнем обсуждать двухкубитные операторы, рассмотрим ситуацию. Представим, что у нас есть состояние из двух кубитов и мы хотим подействовать на первый кубит оператором Адамара. Как же тогда нам написать такой двухкубитный оператор? Мы знаем, что действуем на первый кубит оператором, а что происходит со вторым кубитом? Ничего не происходит – и это эквивалентно тому, что мы действуем на второй кубит единичным оператором. А финальный оператор <span class="math notranslate nohighlight">\(2^2 \times 2^2\)</span> записывается через произведение Кронекера:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\hat{H} \otimes \hat{I} = \frac{1}{\sqrt{2}}\begin{bmatrix}
1 &amp; 1 \\
1 &amp; -1
\end{bmatrix} \otimes \begin{bmatrix}
1 &amp; 0 \\
0 &amp; 1
\end{bmatrix} = \frac{1}{\sqrt{2}} \begin{bmatrix}
\hat{I} &amp; \hat{I} \\
\hat{I} &amp; -\hat{I}
\end{bmatrix} = \frac{1}{\sqrt{2}} \begin{bmatrix}
1 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 1 \\
1 &amp; 0 &amp; -1 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; -1
\end{bmatrix}
\end{split}\]</div>
<p>Учитывая, что многокубитные состояния конструируются аналогичным образом через произведение Кронекера, мы можем убедиться в верности нашего вывода:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">h</span> <span class="o">@</span> <span class="n">basis</span><span class="p">,</span> <span class="n">basis</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span> <span class="n">basis</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id14">
<h5>Наблюдаемые для многокубитных гейтов<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h5>
<p>Аналогичным образом можно сконструировать и наблюдаемые. Например, если мы хотим измерять одновременно два спина по оси <span class="math notranslate nohighlight">\(\mathbf{Z}\)</span>, то наблюдаемая будет выглядеть так:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathbf{ZZ} = \hat{\sigma^z} \otimes \hat{\sigma^z} = \begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; -1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; -1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\end{split}\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span> <span class="n">basis</span><span class="p">)</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">pauli_z</span><span class="p">,</span> <span class="n">pauli_z</span><span class="p">)</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span> <span class="n">basis</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[1.+0.j]]
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="id15">
<h4>Основные двухкубитные гейты<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h4>
<p>Основные многокубитные гейты, которые предоставляют современные квантовые компьютеры, – это двухкубитные гейты.</p>
<div class="section" id="cnot-cx">
<h5>CNOT (CX)<a class="headerlink" href="#cnot-cx" title="Permalink to this headline">¶</a></h5>
<p>Квантовый гейт контролируемого инвертирования – это гейт, который действует на два кубита: <em>рабочий</em> и <em>контрольный</em>. В зависимости от того, имеет ли контрольный кубит значение 1 или 0, этот гейт инвертирует или не инвертирует рабочий кубит.</p>
<div class="figure align-default" id="cnot">
<a class="reference internal image-reference" href="../_images/CNOT_gate.svg"><img alt="../_images/CNOT_gate.svg" src="../_images/CNOT_gate.svg" width="400px" /></a>
<p class="caption"><span class="caption-number">Fig. 39 </span><span class="caption-text">Гейт CNOT</span><a class="headerlink" href="#cnot" title="Permalink to this image">¶</a></p>
</div>
<p>Иногда этот гейт также называют гейтом CX. В матричном виде этот оператор можно записать так:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\hat{CNOT} = \begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1\\
0 &amp; 0 &amp; 1 ,&amp; 0
\end{bmatrix}
\end{split}\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">cnot</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
    <span class="p">[</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">]</span>
<span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">cnot</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span> <span class="n">basis</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span> <span class="n">basis</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span>
    <span class="n">cnot</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">pauli_x</span> <span class="o">@</span> <span class="n">basis</span><span class="p">,</span> <span class="n">basis</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">pauli_x</span> <span class="o">@</span> <span class="n">basis</span><span class="p">,</span> <span class="n">pauli_x</span> <span class="o">@</span> <span class="n">basis</span><span class="p">)</span>
<span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
True
</pre></div>
</div>
</div>
</div>
<p>Заметьте, тут мы воспользовались тем, что <span class="math notranslate nohighlight">\(\hat{\sigma^x}\)</span> работает так же, как инвертор кубитов: он превращает <span class="math notranslate nohighlight">\(\ket{0}\)</span> в <span class="math notranslate nohighlight">\(\ket{1}\)</span> и наоборот.</p>
</div>
<div class="section" id="cy-cz">
<h5>Гейты CY и CZ<a class="headerlink" href="#cy-cz" title="Permalink to this headline">¶</a></h5>
<p>Схожие по принципу гейты – это гейты <span class="math notranslate nohighlight">\(\hat{CY}\)</span> и <span class="math notranslate nohighlight">\(\hat{CZ}\)</span>. В зависимости от значения управляющего кубита к рабочему кубиту применяют соответствующий оператор Паули:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\hat{CY} = \begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; -i\\
0 &amp; 0 &amp; i &amp; 0
\end{bmatrix} \qquad \hat{CZ} = \begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; -1
\end{bmatrix}
\end{split}\]</div>
</div>
<div class="section" id="iswap">
<h5>Гейт iSWAP<a class="headerlink" href="#iswap" title="Permalink to this headline">¶</a></h5>
<p>Гейты <span class="math notranslate nohighlight">\(\hat{CX}\)</span>, <span class="math notranslate nohighlight">\(\hat{CY}\)</span> и <span class="math notranslate nohighlight">\(\hat{CZ}\)</span> эквивалентны с точностью до однокубитных гейтов. Это означает, что любой из них можно получить, добавив необходимые однокубитные гейты до и после другого гейта. Например:</p>
<div class="math notranslate nohighlight">
\[
\hat{CZ} = \left(\hat{I}\times\hat{H}\right)\hat{CX}\left(\hat{I}\times\hat{H}\right).
\]</div>
<p>Этим свойством обладают отнюдь не все двухкубитные гейты. Например, таковым является гейт iSWAP:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathrm{iSWAP} = \begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; -i &amp; 0\\
0 &amp; -i &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\end{split}\]</div>
</div>
<div class="section" id="fsim">
<h5>Гейт fSim<a class="headerlink" href="#fsim" title="Permalink to this headline">¶</a></h5>
<p>Для разных архитектур квантовых процессоров “естественный” гейт может выглядеть по-разному. Например, в квантовом процессоре Google Sycamore естественным является так называемый fermionic simulation gate или fSim. Это двухпараметрическое семейство гейтов вида:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathrm{fSim}(\theta, \phi) = \begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; \cos\theta &amp; -i\sin\theta &amp; 0\\
0 &amp; -i\sin\theta &amp; \cos\theta &amp; 0\\
0 &amp; 0 &amp; 0 &amp; e^{-i\phi}
\end{bmatrix}.
\end{split}\]</div>
<p>Впрочем, и fSim-гейт не является эквивалентным всему множеству двухкубитных гейтов. В общем случае, чем больше кубитов,
тем сложнее будет выглядеть декомпозиция произвольного гейта на физически реализуемые в “железе”.</p>
</div>
</div>
<div class="section" id="pennylane">
<h4>Первое знакомство с PennyLane<a class="headerlink" href="#pennylane" title="Permalink to this headline">¶</a></h4>
<p>На сегодняшний день существует достаточно много фреймворков для программирования квантовых компьютеров. Для целей этого курса мы будем использовать <a class="reference external" href="https://pennylane.ai/">PennyLane</a>. Он предоставляет высокоуровневый <code class="docutils literal notranslate"><span class="pre">Python</span> <span class="pre">API</span></code> и создан специально для решения задач квантового машинного обучения.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pennylane</span> <span class="k">as</span> <span class="nn">qml</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="device">
<h5>Device<a class="headerlink" href="#device" title="Permalink to this headline">¶</a></h5>
<p>Для объявления квантового устройства используется класс <code class="docutils literal notranslate"><span class="pre">Device</span></code>. <code class="docutils literal notranslate"><span class="pre">PennyLane</span></code> поддерживает работу с большинством существующих квантовых компьютеров, но для целей курса мы будем запускать все наши программы лишь на самом простом симуляторе идеального квантового компьютера:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">device</span> <span class="o">=</span> <span class="n">qml</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Первый аргумент тут – указание устройства, а второй – число кубитов.</p>
</div>
<div class="section" id="qnode">
<h5>QNode<a class="headerlink" href="#qnode" title="Permalink to this headline">¶</a></h5>
<p>Основной <em>строительный блок</em> в <code class="docutils literal notranslate"><span class="pre">PennyLane</span></code> – это <code class="docutils literal notranslate"><span class="pre">qnode</span></code>. Это функция, которая отмечена специальным декоратором и включает в себя несколько операций с кубитами. Результатом такой функции всегда является измерение. Напишем функцию, которая поворачивает первый кубит на <span class="math notranslate nohighlight">\(45^o\)</span>, после чего измеряет оба кубита по оси <span class="math notranslate nohighlight">\(\mathbf{Z}\)</span>.</p>
<div class="section" id="numpy">
<h6>Сначала на NumPy<a class="headerlink" href="#numpy" title="Permalink to this headline">¶</a></h6>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span> <span class="n">basis</span><span class="p">)</span>
<span class="n">op</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">ry</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mi">45</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">))</span>
<span class="n">measure</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">pauli_z</span><span class="p">,</span> <span class="n">pauli_z</span><span class="p">)</span>

<span class="nb">print</span><span class="p">((</span><span class="n">op</span> <span class="o">@</span> <span class="n">state</span><span class="p">)</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">measure</span> <span class="o">@</span> <span class="p">(</span><span class="n">op</span> <span class="o">@</span> <span class="n">state</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[0.70710678+0.j]]
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id16">
<h6>Теперь через QNode<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h6>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">angle</span><span class="p">):</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">RY</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">qml</span><span class="o">.</span><span class="n">expval</span><span class="p">(</span><span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">@</span> <span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>


<span class="nb">print</span><span class="p">(</span><span class="n">test</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mi">45</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.7071067811865475
</pre></div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="id17">
<h4>Заключение<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h4>
<p>Это последняя вводная лекция, где мы сами писали операторы и операции на чистом <code class="docutils literal notranslate"><span class="pre">NumPy</span></code>: это должно помочь лучше понять ту математику, которая лежит “под капотом” у квантовых вычислений. Дальше мы будем пользоваться только <code class="docutils literal notranslate"><span class="pre">PennyLane</span></code> и в отдельной лекции расскажем, как работать с этим фреймворком.</p>
<p>Итого:</p>
<ul class="simple">
<li><p>мы знаем, что такое кубит;</p></li>
<li><p>понимаем линейную алгебру, которая описывает квантовые вычисления;</p></li>
<li><p>понимаем, как можно сконструировать нужный нам оператор и как его применить;</p></li>
<li><p>знаем, что такое измерение и наблюдаемые.</p></li>
</ul>
<p>Теперь мы готовы к тому, чтобы знакомиться с квантовыми вариационными схемами и переходить непосредственно к построению моделей квантового машинного обучения.</p>
</div>
<div class="section" id="id18">
<h4>Задачи<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>Как связаны ось и угол вращения на сфере Блоха с собственными значениями и собственными векторами матрицы однокубитного гейта? Для этого найдите собственные векторы и собственные значения гейта <span class="math notranslate nohighlight">\(R^\vec{n}\left(\alpha\right)\)</span>.</p></li>
<li><p>Вокруг какой оси и на какой угол вращает состояние гейт Адамара?</p></li>
<li><p>Гейт SWAP меняет кубиты местами. Его унитарная матрица имеет вид:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathrm{SWAP} =
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}.
\end{split}\]</div>
<p>Попробуйте составить последовательность гейтов, реализующую <span class="math notranslate nohighlight">\(\mathrm{SWAP}\)</span>, из гейтов <span class="math notranslate nohighlight">\(\mathrm{iSWAP}\)</span>, <span class="math notranslate nohighlight">\(\hat{CZ}\)</span> и <span class="math notranslate nohighlight">\(\hat{RZ}(\phi)\)</span>.</p>
</div>
</div>
<span id="document-book/qcblock/deutschs_algorithm"></span><div class="section" id="deutschs-algorithm">
<span id="id1"></span><h3>Алгоритм Дойча<a class="headerlink" href="#deutschs-algorithm" title="Permalink to this headline">¶</a></h3>
<p><strong>Алгоритм Дойча</strong> (в английском варианте - <strong>Deutsch’s algorithm</strong>) - это один из первых алгоритмов, показавших, что квантовый компьютер может решать задачи особым способом, отличающимся как от алгоритмов классического компьютера, так и от интуиции и здравого смысла человека. При этом такое решение может занимать меньшее количество шагов.</p>
<p>Нужно прежде всего сказать, что алгоритм Дойча не имеет практического применения в силу своей предельной простоты, зато является простейшим примером, с помощью которого можно понять, в чем состоит отличие квантовых алгоритмов от классических. Данный алгоритм был предложен в 1985 году, когда квантовых компьютеров еще не было, а практически он был реализован в 1998 году на 2-кубитном квантовом компьютере, работавшем на принципах ядерно-магнитного резонанса.</p>
<div class="admonition- admonition">
<p class="admonition-title">Дэвид Дойч</p>
<p>Помимо занятий теоретической физикой в Оксфордском университете, Дэвид Дойч - автор книг “Структура реальности” и “Начало бесконечности”, в которых он популярно излагает идеи квантовых вычислений с точки зрения многомировой интерпретеции (сторонником которой является) и философствует о будущем науки и человечества. Так что можно сказать, что работа алгоритма, согласно замыслу создателя, производится в параллельных вселенных. Так это или нет, пока проверить невозможно, но вычисления работают, и это главное.</p>
</div>
<p>Итак, в чем состоит задача, которую решает алгоритм? Представьте, что у вас есть функция, которая представляет собой “черный ящик”, принимающий на вход число из множества <span class="math notranslate nohighlight">\(\{0, 1\}\)</span>. Функция неким образом обрабатывает входное значение и возвращает число из этого же множества, то есть либо <span class="math notranslate nohighlight">\(0\)</span>, либо <span class="math notranslate nohighlight">\(1\)</span>. Нам известно, что эта функция принадлежит либо к классу сбалансированных функций, либо к классу константных функций (которые мы также можем называть несбалансированными). Задача алгоритма - установить, к какому классу принадлежит функция.</p>
<p>Рассмотрим все варианты этих двух классов. Всего их четыре, то есть по две функции в каждом классе. Начнем с несбалансированных:
<br/>
<br/>
<b>1). <span class="math notranslate nohighlight">\(f_1(x) = 0\)</span></b>
<br/>
Это функция, всегда возвращающая <span class="math notranslate nohighlight">\(0\)</span>, независимо от входного значения.
<br/>
Для нее справедливы выражения:
<br/>
<span class="math notranslate nohighlight">\(f_1(0) = 0\)</span>
<br/>
<span class="math notranslate nohighlight">\(f_1(1) = 0\)</span>
<br/></p>
<p><b>2). <span class="math notranslate nohighlight">\(f_2(x) = 1\)</span> </b>
<br/>
Такая функция всегда возвращает <span class="math notranslate nohighlight">\(1\)</span>, то есть верно следующее:
<br/>
<span class="math notranslate nohighlight">\(f_2(0) = 1\)</span>
<br/>
<span class="math notranslate nohighlight">\(f_2(1) = 1\)</span>
<br/></p>
<p>Ну а теперь посмотрим на сбалансированные функции.
<br/>
Для них характерно то, что они могут возвращать как <span class="math notranslate nohighlight">\(0\)</span>, так и <span class="math notranslate nohighlight">\(1\)</span>. В этом и заключается “баланс”.
<br/>
<br/>
<b>3). <span class="math notranslate nohighlight">\(f_3(x) = x\)</span></b>
<br/>
Это тождественная функция, которая ничего не делает с входным значением.
<br/>
Для нее справедливо следующее:
<br/>
<span class="math notranslate nohighlight">\(f_3(0) = 0\)</span>
<br/>
<span class="math notranslate nohighlight">\(f_3(1) = 1\)</span>
<br/></p>
<p><b>4). <span class="math notranslate nohighlight">\(f_4(x) = \overline{x}\)</span></b>
<br/>
А вот эта функция инвертирует входное значение, то есть возвращает не то число,
<br/>
которое было подано на вход, а другое:
<br/>
<span class="math notranslate nohighlight">\(f_4(0) = 1\)</span>
<br/>
<span class="math notranslate nohighlight">\(f_4(1) = 0\)</span>
<br/></p>
<p>Классический компьютер справляется с задачей за два шага. Например, нам дана некоторая функция-“черный ящик”, и мы должны установить, сбалансирована ли она.
На первом шаге мы отправляем в функцию входное значение <span class="math notranslate nohighlight">\(0\)</span>. Допустим, мы получили на выходе также <span class="math notranslate nohighlight">\(0\)</span>. Мы можем сказать, что данная функция - либо <span class="math notranslate nohighlight">\(f_1\)</span>
(константная функция, всегда возвращающая <span class="math notranslate nohighlight">\(0\)</span>), либо <span class="math notranslate nohighlight">\(f_3\)</span> (сбалансированная функция, не меняющая входное значение). Для окончательного решения мы должны сделать еще один шаг - отправить в функцию значение <span class="math notranslate nohighlight">\(1\)</span>. Если при этом мы получим опять <span class="math notranslate nohighlight">\(0\)</span>, то это функция <span class="math notranslate nohighlight">\(f_1\)</span>, а если получили на выходе <span class="math notranslate nohighlight">\(1\)</span>, то искомая функция - <span class="math notranslate nohighlight">\(f_3\)</span>.</p>
<p>Способа, с помощью которого на классическом компьютере можно за одно действие установить, сбалансирована функция или нет, не существует. И здесь свое преимущество показывает квантовый компьютер: он может установить класс функции за одно действие.</p>
<p>Для начала рассмотрим простейшую схему, с помощью которой можно отправлять число на вход и получать ответ от черного ящика:</p>
<div class="figure align-default" id="scheme-1">
<a class="reference internal image-reference" href="../_images/scheme_1.png"><img alt="../_images/scheme_1.png" src="../_images/scheme_1.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-number">Fig. 40 </span><span class="caption-text">Схема 1.</span><a class="headerlink" href="#scheme-1" title="Permalink to this image">¶</a></p>
</div>
<p><span class="math notranslate nohighlight">\(U_f\)</span> на данной схеме - это неизвестная функция (ее также часто называют “оракул”), являющаяся унитарным оператором. Обратите внимание, что в квантовой схеме используются два кубита. Это нужно для того, чтобы информация, с которой работает квантовый компьютер, не стиралась. В квантовом компьютере важно, чтобы все действия с кубитами (кроме операции измерения) были обратимыми, а для этого информация должна сохраняться. В верхнем кубите будет записано входное значение, а в нижнем - выходное значение функции. Таким образом, входное значение не будет перезаписано значением, которое вернет функция.</p>
<p>Но нам важно будет не только сохранить значение <span class="math notranslate nohighlight">\(|x\rangle\)</span>, но также и не разрушить <span class="math notranslate nohighlight">\(|y\rangle\)</span>. Так как кубит <span class="math notranslate nohighlight">\(y\)</span> очевидно имеет некоторое изначальное значение, мы не можем его просто перезаписать тем числом, которое выдаст функция <span class="math notranslate nohighlight">\(f(x)\)</span>. Здесь на помощь приходит операция исключающее ИЛИ - <span class="math notranslate nohighlight">\(XOR\)</span> (также ее можно называть сложением по модулю 2), обозначенная на схеме как <span class="math notranslate nohighlight">\(\oplus\)</span>. В процессе работы черный ящик <span class="math notranslate nohighlight">\(U_f\)</span> не только находит значение <span class="math notranslate nohighlight">\(f(x)\)</span>, но и применяет исключающее ИЛИ к значениям <span class="math notranslate nohighlight">\(y\)</span> и <span class="math notranslate nohighlight">\(f(x)\)</span>.
<br/>
Операции <span class="math notranslate nohighlight">\(XOR\)</span> соответствует такая таблица истинности:</p>
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="text-align:center head"><p>a</p></th>
<th class="text-align:center head"><p>b</p></th>
<th class="text-align:center head"><p>a XOR b</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-align:center"><p>0</p></td>
<td class="text-align:center"><p>0</p></td>
<td class="text-align:center"><p>0</p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p>0</p></td>
<td class="text-align:center"><p>1</p></td>
<td class="text-align:center"><p>1</p></td>
</tr>
<tr class="row-even"><td class="text-align:center"><p>1</p></td>
<td class="text-align:center"><p>0</p></td>
<td class="text-align:center"><p>1</p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p>1</p></td>
<td class="text-align:center"><p>1</p></td>
<td class="text-align:center"><p>0</p></td>
</tr>
</tbody>
</table>
<p>Операция <span class="math notranslate nohighlight">\(XOR\)</span> хороша для нас тем, что она не разрушает значение <span class="math notranslate nohighlight">\(|y\rangle\)</span>, так как является обратимой. Убедиться в этом можно, проверив тождество:
<br/>
<span class="math notranslate nohighlight">\((a \oplus b) \oplus b = a\)</span></p>
<p><em>Схема 1</em> пока что не дает преимущества по сравнению с классическим компьютером, но мы можем ее немного усовершенствовать:</p>
<div class="figure align-default" id="scheme-2">
<a class="reference internal image-reference" href="../_images/scheme_2.png"><img alt="../_images/scheme_2.png" src="../_images/scheme_2.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-number">Fig. 41 </span><span class="caption-text">Схема 2.</span><a class="headerlink" href="#scheme-2" title="Permalink to this image">¶</a></p>
</div>
<p>В новой схеме оба кубита вначале будут находиться в состоянии <span class="math notranslate nohighlight">\(|0\rangle\)</span>. Затем мы применим к верхнему кубиту оператор Адамара, а к нижнему - гейт <span class="math notranslate nohighlight">\(X\)</span>, а затем так же, как и к верхнему, оператор Адамара. Тем самым мы приведем оба кубита в состояние суперпозиции перед тем, как они попадут на вход функции <span class="math notranslate nohighlight">\(U_f\)</span>.
Верхний кубит будет находиться в такой суперпозиции:
<br/>
<span class="math notranslate nohighlight">\(|x\rangle = \frac{1}{\sqrt{2}}|0\rangle + \frac{1}{\sqrt{2}}|1\rangle,\)</span>
<br/>
а нижний - в такой:
<br/>
<span class="math notranslate nohighlight">\(|y\rangle = \frac{1}{\sqrt{2}}|0\rangle - \frac{1}{\sqrt{2}}|1\rangle.\)</span></p>
<p>Если рассмотреть это как систему <span class="math notranslate nohighlight">\(|\psi\rangle\)</span>, состоящую из двух кубитов, то она будет выглядеть так:</p>
<p><span class="math notranslate nohighlight">\(|\psi\rangle = \frac{1}{2}(|0\rangle + |1\rangle)(|0\rangle - |1\rangle)\)</span></p>
<p>Сразу после <span class="math notranslate nohighlight">\(U_f\)</span> система будет находиться в состоянии:</p>
<p><span class="math notranslate nohighlight">\(|\psi\rangle = \frac{1}{2}(|0\rangle + |1\rangle)(|0 \oplus f(x)\rangle - |1 \oplus f(x)\rangle)\)</span></p>
<p>После того, как <span class="math notranslate nohighlight">\(U_f\)</span> отрабатывает, нижний кубит, как это ни странно, уже нас не интересует, так что к нему операции больше не применяются, и его измерение также не производится.</p>
<p>Дело в том, что ответ на вопрос о том, сбалансирована функция <span class="math notranslate nohighlight">\(f(x)\)</span> или нет, будет нами получен из верхнего кубита после того, как на него подействует оператор Адамара и будет произведено измерение.</p>
<p>В том случае, если функция сбалансирована, результат измерения верхнего кубита будет равен <span class="math notranslate nohighlight">\(1\)</span>, а если несбалансированна - <span class="math notranslate nohighlight">\(0\)</span>.</p>
<p>Разберемся подробнее, почему это происходит.</p>
<p>Рассмотрим все возможные <span class="math notranslate nohighlight">\(f(x)\)</span>, которые могут находиться в черном ящике:</p>
<p>1). <span class="math notranslate nohighlight">\(f(x) = f_1\)</span></p>
<p>В этом случае <span class="math notranslate nohighlight">\(f(x)\)</span> всегда принимает значение <span class="math notranslate nohighlight">\(0\)</span>, и система кубитов будет выглядеть так:</p>
<p><span class="math notranslate nohighlight">\(|\psi\rangle = \frac{1}{2}(|0\rangle + |1\rangle)(|0\rangle - |1\rangle) = \frac{1}{2}(|00\rangle - |01\rangle + |10\rangle - |11\rangle)\)</span></p>
<p>2). <span class="math notranslate nohighlight">\(f(x) = f_2\)</span></p>
<p><span class="math notranslate nohighlight">\(f(x)\)</span> будет равно <span class="math notranslate nohighlight">\(1\)</span> независимо от аргумента. Используя таблицу истинности XOR, легко убедиться, что во второй скобке <span class="math notranslate nohighlight">\(|0\rangle\)</span> и <span class="math notranslate nohighlight">\(|1\rangle\)</span> поменяются местами, но если вынести минус за скобку, то мы можем его не учитывать, так общий фазовый множитель (-1 в данном случае) для системы не имеет значения:</p>
<p><span class="math notranslate nohighlight">\(|\psi\rangle = \frac{1}{2}(|0\rangle + |1\rangle)(|1\rangle - |0\rangle) = -\frac{1}{2}(|0\rangle + |1\rangle)(|0\rangle - |1\rangle) = -\frac{1}{2}(|00\rangle - |01\rangle + |10\rangle - |11\rangle)\)</span></p>
<p>Видно, что при применении функций <span class="math notranslate nohighlight">\(f_1\)</span> и <span class="math notranslate nohighlight">\(f_2\)</span>, являющихся несбалансированными, мы получаем фактически одно и тоже состояние. Если после этого применить к первому кубиту оператор Адамара, то после измерения мы получим значение <span class="math notranslate nohighlight">\(0\)</span>.</p>
<p>Рассмотрим теперь сбалансированные функции <span class="math notranslate nohighlight">\(f_3\)</span> и <span class="math notranslate nohighlight">\(f_4\)</span>.</p>
<p>3). <span class="math notranslate nohighlight">\(f(x) = f_3\)</span></p>
<p>Здесь ситуация сложнее, так как <span class="math notranslate nohighlight">\(f(x)\)</span> будет зависеть от состояния первого кубита. Поэтому мы раскроем скобки, а значения функции подставим позже:</p>
<p><span class="math notranslate nohighlight">\(|\psi\rangle = \frac{1}{2}(|0\rangle + |1\rangle)(|0 \oplus f(x)\rangle - |1 \oplus f(x)\rangle) =
\frac{1}{2}(|0\rangle |0 \oplus f(x)\rangle - |0\rangle |1 \oplus f(x)\rangle + |1\rangle |0 \oplus f(x)\rangle - |1\rangle |1 \oplus f(x)\rangle)=\)</span></p>
<p><span class="math notranslate nohighlight">\(=\frac{1}{2}(|0\rangle |0 \oplus 0\rangle - |0\rangle |1 \oplus 0\rangle + |1\rangle |0 \oplus 1\rangle - |1\rangle |1 \oplus 1\rangle) =
\frac{1}{2}(|00\rangle - |01\rangle + |11\rangle - |10\rangle) = \)</span></p>
<p><span class="math notranslate nohighlight">\(=\frac{1}{2}(|00\rangle - |01\rangle - |10\rangle + |11\rangle) = \frac{1}{2}(|0\rangle - |1\rangle)(|0\rangle - |1\rangle)\)</span></p>
<p>Видно, что первый кубит поменял свое состояние - теперь он в суперпозиции <span class="math notranslate nohighlight">\(\frac{1}{\sqrt{2}}(|0\rangle - |1\rangle)\)</span>, так что далее к нему можно применить оператор Адамара, после которого он перейдет в состояние <span class="math notranslate nohighlight">\(|1\rangle\)</span>.</p>
<p>4). <span class="math notranslate nohighlight">\(f(x) = f_4\)</span></p>
<p>Здесь будет похожая ситуация:</p>
<p><span class="math notranslate nohighlight">\(|\psi\rangle = \frac{1}{2}(|0\rangle + |1\rangle)(|0 \oplus f(x)\rangle - |1 \oplus f(x)\rangle) =
\frac{1}{2}(|0\rangle |0 \oplus f(x)\rangle - |0\rangle |1 \oplus f(x)\rangle + |1\rangle |0 \oplus f(x)\rangle - |1\rangle |1 \oplus f(x)\rangle)=\)</span></p>
<p><span class="math notranslate nohighlight">\(=\frac{1}{2}(|0\rangle |0 \oplus 1\rangle - |0\rangle |1 \oplus 1\rangle + |1\rangle |0 \oplus 0\rangle - |1\rangle |1 \oplus 0\rangle) =
\frac{1}{2}(|01\rangle - |00\rangle + |10\rangle - |11\rangle) = \)</span></p>
<p><span class="math notranslate nohighlight">\(=-\frac{1}{2}(|00\rangle - |01\rangle + |11\rangle - |10\rangle) =-\frac{1}{2}(|0\rangle - |1\rangle)(|0\rangle - |1\rangle)\)</span></p>
<p>Получили то же состояние <span class="math notranslate nohighlight">\(|\psi\rangle\)</span>, что и для <span class="math notranslate nohighlight">\(f_3\)</span>, с точностью до фазового множителя. Соответственно, здесь первый кубит после применения оператора Адамара также будет измерен с результатом <span class="math notranslate nohighlight">\(1\)</span>.</p>
<p>Теперь можно получить более компактную формулу, которая подходит для всех четырех функций:</p>
<p><span class="math notranslate nohighlight">\(|\psi\rangle = \frac{1}{2}((-1)^{f(0)}|0\rangle + (-1)^{f(1)}|1\rangle)(|0\rangle - |1\rangle)\)</span></p>
<p><strong>Задание</strong>: с помощью квантовых операторов попробуйте создать <span class="math notranslate nohighlight">\(U_f\)</span> для всех четырех <span class="math notranslate nohighlight">\(f(x)\)</span>. (Задание рекомендуется сделать до прочтения программистской части по алгоритму Дойча, так как там содержится ответ).</p>
<div class="section" id="id2">
<h4>Алгоритм Дойча в коде<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>Запрограммируем алгоритм с помощью библиотеки PennyLane. Предполагается, что функция, находящаяся в черном ящике, изначально присутствует, но для учебного примера создадим также и её, точнее, все её четыре варианта. Для того, чтобы нам не сразу было известно, какая из этих функций анализируется алгоритмом (иначе будет неинтересно), будем использовать случайный выбор функции.</p>
<p>Импортируем все необходимые библиотеки и модули, а также создадим квантовое устройство-симулятор, рассчитанное на схему из двух кубитов:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pennylane</span> <span class="k">as</span> <span class="nn">qml</span>
<span class="kn">from</span> <span class="nn">pennylane</span> <span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="n">dev</span> <span class="o">=</span> <span class="n">qml</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s1">&#39;default.qubit&#39;</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Теперь создадим функции для черного ящика. Обратите внимание, что здесь уже учтено сложение по модулю <span class="math notranslate nohighlight">\(2\)</span> результата функции с состоянием второго кубита:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f1</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">f2</span><span class="p">():</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">PauliX</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">f3</span><span class="p">():</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">CNOT</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">f4</span><span class="p">():</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">PauliX</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">CNOT</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">PauliX</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Создадим словарь с функциями и их названиями:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">black_boxes_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;f1&#39;</span><span class="p">:</span> <span class="n">f1</span><span class="p">,</span> <span class="s1">&#39;f2&#39;</span><span class="p">:</span> <span class="n">f2</span><span class="p">,</span> <span class="s1">&#39;f3&#39;</span><span class="p">:</span> <span class="n">f3</span><span class="p">,</span> <span class="s1">&#39;f4&#39;</span><span class="p">:</span> <span class="n">f4</span><span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>А вот таким образом мы будем случайно выбирать название функции для черного ящика:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">random_black_box</span><span class="p">():</span>
    <span class="n">black_boxes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;f1&#39;</span><span class="p">,</span> <span class="s1">&#39;f2&#39;</span><span class="p">,</span> <span class="s1">&#39;f3&#39;</span><span class="p">,</span> <span class="s1">&#39;f4&#39;</span><span class="p">]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">black_boxes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>А теперь самое важное - сам алгоритм Дойча:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">circuit</span><span class="p">(</span><span class="n">black_boxe_name</span><span class="p">):</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">PauliX</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">black_boxes_dict</span><span class="p">[</span><span class="n">black_box_name</span><span class="p">]()</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">qml</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span><span class="p">([</span><span class="mi">0</span><span class="p">]))</span>
</pre></div>
</div>
</div>
</div>
<p>Итак, подготовительные действия завершены, можно приступать к демонстрации работы алгоритма. Для начала выберем случайным образом функцию:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">black_box_name</span> <span class="o">=</span> <span class="n">random_black_box</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>А затем запустим алгоритм Дойча и выведем результат его работы. Собственное значение <span class="math notranslate nohighlight">\(1\)</span> оператора <span class="math notranslate nohighlight">\(Z\)</span> будет соответствовать состоянию <span class="math notranslate nohighlight">\(|0\rangle\)</span> (функция несбалансированна), а собственное значение <span class="math notranslate nohighlight">\(-1\)</span> - состоянию <span class="math notranslate nohighlight">\(|1\rangle\)</span> (функция сбалансирована):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">circuit</span><span class="p">(</span><span class="n">black_box_name</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1
</pre></div>
</div>
</div>
</div>
<p>Проверим, насколько правильно сработал алгоритм. Для этого посмотрим на функцию из черного ящика:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">black_box_name</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>f2
</pre></div>
</div>
</div>
</div>
<p>Также посмотрим, как выглядит квантовая схема:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">circuit</span><span class="o">.</span><span class="n">draw</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span> 0: ──H──H─────┤ Sample[Z] 
 1: ──X──H──X──┤           
</pre></div>
</div>
</div>
</div>
<p>На примере алгоритма Дойча мы видим, что уже двухкубитная схема дает прирост скорости в два раза. Если же увеличивать количество входных параметров (как в аналогичном алгоритме Дойча-Йожи), то ускорение будет экспоненциальным.</p>
<p>Для специалистов, занимающихся искусственным интеллектом, алгоритм может быть интересен тем, что не просто решает задачу нахождения некоторого значения, действуя как калькулятор, а дает возможность определить скрытую функцию. Это похоже на задачи машинного обучения, когда дата сайентист, производя математические манипуляции с данными, в итоге получает модель (фактически - функцию), описывающую связь признаков с целевой переменной. Таким образом, интерес специалистов ИИ к квантовым вычислениям, вполне понятен, как и перспективы квантовых вычислений в этой области.</p>
</div>
</div>
<span id="document-book/qcblock/grovers_algorithm"></span><div class="section" id="grovers-algorithm">
<span id="id1"></span><h3>Алгоритм Гровера<a class="headerlink" href="#grovers-algorithm" title="Permalink to this headline">¶</a></h3>
<p>Одно из самых востребованных действий в работе с данными – поиск по базе данных. При использовании классического компьютера такой поиск в худшем случае требует <span class="math notranslate nohighlight">\(N\)</span> операций, где <span class="math notranslate nohighlight">\(N\)</span> – количество строк в таблице. В среднем найти нужный элемент можно за <span class="math notranslate nohighlight">\(N/2\)</span> операций.</p>
<p>Фактически, это означает, что если мы не знаем, где расположен нужный элемент в таблице, то придется перебирать все элементы, пока не найдем то, что нужно. Для классических вычислений это нормально, но что, если у нас есть квантовый компьютер?</p>
<p>Если наша база данных работает на основе квантовых вычислений, то мы можем применить алгоритм Гровера, и тогда такой поиск потребует всего порядка <span class="math notranslate nohighlight">\(\sqrt{N}\)</span> действий. Конечно же, такое ускорение не будет экспоненциальным, как при использовании некоторых других квантовых алгоритмов, но оно будет квадратичным, что также довольно неплохо.</p>
<div class="figure align-default" id="grover-photo">
<img alt="../_images/Grover_photo.jpg" src="../_images/Grover_photo.jpg" />
<p class="caption"><span class="caption-number">Fig. 42 </span><span class="caption-text">Лов Гровер</span><a class="headerlink" href="#grover-photo" title="Permalink to this image">¶</a></p>
</div>
<div class="admonition- admonition">
<p class="admonition-title">Лов Гровер</p>
<p>Индо-американский ученый в сфере Computer Science Лов Кумар Гровер предложил квантовый алгоритм поиска по базе данных в 1996 году. Этот алгоритм считается вторым по значимости для квантовых вычислений после алгоритма Шора. Впервые он был реализован на простейшем квантовом компьютере в 1998 году, а в 2017 году алгоритм Гровера был впервые запущен для трехкубитной базы данных.</p>
</div>
<p>Итак, наша задача состоит в том, что мы должны найти идентификационный номер (<span class="math notranslate nohighlight">\(Id\)</span>) записи, которая удовлетворяет определенным условиям. Функция-оракул находит такую запись (для простоты будем сначала считать, что такая запись одна) и помечает соответствующий ей <span class="math notranslate nohighlight">\(Id\)</span>. Отметка делается достаточно оригинальным способом: <span class="math notranslate nohighlight">\(Id\)</span> умножается на <span class="math notranslate nohighlight">\(-1\)</span>.</p>
<p>Для полной ясности соотнесем количество <span class="math notranslate nohighlight">\(Id\)</span> с числом кубитов в квантовой схеме. Здесь все очень просто: имея <span class="math notranslate nohighlight">\(n\)</span> кубитов, можно закодировать <span class="math notranslate nohighlight">\(N = 2^n\)</span> идентификаторов. К примеру, если в таблице базы данных <span class="math notranslate nohighlight">\(1024\)</span> записей, то закодировать все <span class="math notranslate nohighlight">\(Id\)</span> можно с помощью десяти кубитов.</p>
<p>Для того, чтобы не запутаться в квантовых операциях, рассмотрим пример поменьше: с помощью двух кубитов закодируем четыре идентификационных номера, один из которых будет помечен функцией-оракулом как искомый – он будет домножен на <span class="math notranslate nohighlight">\(-1\)</span>. Все эти четыре числа могут существовать в квантовой схеме одновременно, если кубиты приведены в состояние суперпозиции.</p>
<p>Пусть искомый <span class="math notranslate nohighlight">\(Id\)</span> равен <span class="math notranslate nohighlight">\(11\)</span> (будем пользоваться двоичной системой и вести счет с нуля), тогда после работы функции-оракула мы будем иметь <span class="math notranslate nohighlight">\(4\)</span> состояния: <span class="math notranslate nohighlight">\(|00\rangle\)</span>, <span class="math notranslate nohighlight">\(|01\rangle\)</span>, <span class="math notranslate nohighlight">\(|10\rangle\)</span>, <span class="math notranslate nohighlight">\(-|11\rangle\)</span>. Проблема в том, что если измерить эту схему, то с равной вероятностью будет обнаружено одно из этих четырех значений, но узнать, какое из них функция-оракул пометила минусом, будет невозможно.</p>
<p>Получается, что одной функции-оракула недостаточно, нужно что-то дополнительное. На помощь приходит алгоритм Гровера. Правда, у него есть такая особенность – он является итерационным, то есть определенные операции (в том числе и применение функции-оракула) нужно повторить несколько раз (порядка <span class="math notranslate nohighlight">\(\sqrt{N}\)</span>). Причем, с количеством итераций нельзя ошибиться, иначе алгоритм даст неправильный ответ.</p>
<p>В идеале после всех итераций квантовую схему можно будет измерить и получить значение <span class="math notranslate nohighlight">\(Id\)</span> искомой записи в таблице базы данных.</p>
<p>Разберем операции, которые включает в себя каждая итерация, но перед этим добавим в схему еще один кубит, который мы будем называть вспомогательным. Он нужен для хранения метки искомого индекса. Звучит не совсем понятно, но ничего сложного в этом нет, все станет ясным после разбора работы функции-оракула. Итак, наша база данных двухкубитная, но сама схема состоит из трех кубитов.</p>
<p>Квантовая схема выглядит так:</p>
<div class="figure align-default" id="grover-2-qubits">
<a class="reference internal image-reference" href="../_images/grover_2_qubits.png"><img alt="../_images/grover_2_qubits.png" src="../_images/grover_2_qubits.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-number">Fig. 43 </span><span class="caption-text">Алгоритм Гровера для n=2 (искомый индекс 11).</span><a class="headerlink" href="#grover-2-qubits" title="Permalink to this image">¶</a></p>
</div>
<p>В самом начале, еще до всех итераций, все кубиты (включая вспомогательный) должны быть приведены в состояние суперпозиции с помощью оператора Адамара. Причем начальное состояние всех кубитов должно быть равно <span class="math notranslate nohighlight">\(0\)</span>, кроме вспомогательного кубита – до действия оператора Адамара он должен быть приведен в состояние <span class="math notranslate nohighlight">\(1\)</span>.</p>
<p>Таким образом, вспомогательный кубит после применения оператора Адамара будет находиться в состоянии <span class="math notranslate nohighlight">\(\frac{1}{\sqrt{2}}(|0\rangle - |1\rangle)\)</span>, тогда как остальные кубиты примут состояние <span class="math notranslate nohighlight">\(\frac{1}{\sqrt{2}}(|0\rangle + |1\rangle)\)</span>.</p>
<p>Далее начинаем итерации. Каждая итерация состоит из двух частей. Первая часть – это действие функции-оракула. Это некоторая функция, умеющая эффективно определять, какой индекс соответствует искомому объекту. Эта функция не может сообщить нам этот индекс напрямую, зато она может пометить его минусом.</p>
<p>Для разбора внутренней работы алгоритма нам потребуется задать функцию-оракул вручную и сделать ее достаточно простой, поэтому нужно знать, что в рабочих условиях она будет действовать похоже, но будет устроена, скорее всего, по-другому, так как предназначена для конкретной задачи выбора искомых данных. Мы не будем касаться вопроса конкретной реализации функции-оракула для выбора определенных данных, так как это уже другой вопрос, не влияющий на принцип алгоритма Гровера.</p>
<p>Для того чтобы понять алгоритм Гровера, мы должны будем понять, какие изменения происходят с состояниями кубитов до того момента, когда производится измерение, выдающее искомый индекс.</p>
<p>Мы договорились, что в нашей учебной задаче искомый <span class="math notranslate nohighlight">\(Id\)</span> равен <span class="math notranslate nohighlight">\(11\)</span>, так что в результате измерения мы должны получить именно это значение. Смоделируем оракул, который будет помечать этот индекс. В качестве такого оракула подойдет гейт Тоффоли (<span class="math notranslate nohighlight">\(CCNOT\)</span>). При подаче на оба его управляющих входа значений <span class="math notranslate nohighlight">\(1\)</span>, он будет применять к управляемому кубиту (это как раз будет вспомогательный кубит) гейт <span class="math notranslate nohighlight">\(X\)</span>.</p>
<div class="figure align-default" id="toffoli-gate">
<a class="reference internal image-reference" href="../_images/Toffoli_gate.png"><img alt="../_images/Toffoli_gate.png" src="../_images/Toffoli_gate.png" style="width: 200px;" /></a>
<p class="caption"><span class="caption-number">Fig. 44 </span><span class="caption-text">Гейт Тоффоли.</span><a class="headerlink" href="#toffoli-gate" title="Permalink to this image">¶</a></p>
</div>
<p>На состояния верхних кубитов, кодирующих индексы <span class="math notranslate nohighlight">\(00\)</span>, <span class="math notranslate nohighlight">\(01\)</span> и <span class="math notranslate nohighlight">\(10\)</span> гейт Тоффоли не будет реагировать, и вспомогательный кубит будет находиться в состоянии <span class="math notranslate nohighlight">\(\frac{1}{\sqrt{2}}(|0\rangle - |1\rangle)\)</span>.</p>
<p>Но при срабатывании гейта на индексе <span class="math notranslate nohighlight">\(11\)</span> к вспомогательному кубиту применится оператор <span class="math notranslate nohighlight">\(X\)</span>, так что вспомогательный кубит примет состояние <span class="math notranslate nohighlight">\(\frac{1}{\sqrt{2}}(|1\rangle - |0\rangle)\)</span>, или, если это состояние записать по-другому, за скобками появится минус: <span class="math notranslate nohighlight">\(-\frac{1}{\sqrt{2}}(|0\rangle - |1\rangle)\)</span>.</p>
<p>Этот минус относится не только к вспомогательному кубиту, но и ко всему состоянию, соответствующему индексу <span class="math notranslate nohighlight">\(11\)</span>, так что можно считать, что вспомогательный кубит остался неизменным, и отнести минус к состоянию <span class="math notranslate nohighlight">\(11\)</span> верхних кубитов. Таким образом, индекс <span class="math notranslate nohighlight">\(11\)</span> помечен минусом как искомый. Другими словами, функция-оракул перевела состояние <span class="math notranslate nohighlight">\(|11\rangle |q_{helper}\rangle\)</span> в состояние <span class="math notranslate nohighlight">\(-|11\rangle |q_{helper}\rangle\)</span>, где <span class="math notranslate nohighlight">\(|q_{helper}\rangle\)</span> – вспомогательный кубит.</p>
<p>Запишем состояние квантовой схемы после применения оракула (состояние вспомогательного кубита – скобка справа):</p>
<p><span class="math notranslate nohighlight">\(|\psi\rangle = \frac{1}{2\sqrt{2}}(|00\rangle + |01\rangle + |10\rangle - |11\rangle)(|0\rangle - |1\rangle)\)</span></p>
<p>Итак, первая часть первой итерации завершена. Искомый индекс помечен, но если измерить кубиты прямо сейчас, то это ничего не даст – минус не проявит себя при измерении. Да и сам индекс <span class="math notranslate nohighlight">\(11\)</span> будет получен только с вероятностью <span class="math notranslate nohighlight">\(0.25\)</span> – такой же, как и у других индексов.</p>
<p>Для того, чтобы лучше понять дальнейшие действия, представим первую половину работы алгоритма в виде рисунка, показывающего вектор текущего состояния. В качестве единичного вектора горизонтальной оси мы будем использовать все состояния из суперпозиции кроме того, который соответствует искомому индексу, а вертикальным единичным вектором будет искомый вектор.</p>
<p>Вектор <span class="math notranslate nohighlight">\(c\)</span> – состояние системы перед первой итерацией – является линейной комбинацией векторов, соответствующим горизонтальной и вертикальной осям.</p>
<div class="figure align-default" id="grover-1a">
<a class="reference internal image-reference" href="../_images/grover_1a.png"><img alt="../_images/grover_1a.png" src="../_images/grover_1a.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-number">Fig. 45 </span><span class="caption-text">Состояние системы перед первой итерацией.</span><a class="headerlink" href="#grover-1a" title="Permalink to this image">¶</a></p>
</div>
<p>Можно выразить вектор <span class="math notranslate nohighlight">\(c\)</span> для нашего случая (системы из двух кубитов с искомым индексом <span class="math notranslate nohighlight">\(11\)</span>), обозначив его координаты за <span class="math notranslate nohighlight">\(x\)</span> и <span class="math notranslate nohighlight">\(y\)</span>:</p>
<p><span class="math notranslate nohighlight">\(\frac{1}{2}(|00\rangle + |01\rangle + |10\rangle + |11\rangle) = x \frac{1}{\sqrt{3}}(|00\rangle + |01\rangle + |10\rangle) + y |11\rangle\)</span></p>
<p>Из данного уравнения находим <span class="math notranslate nohighlight">\(x = \frac{\sqrt{3}}{2}\)</span> и <span class="math notranslate nohighlight">\(y = \frac{1}{2}\)</span>.</p>
<p>По этим координатам можно понять, что угол между вектором <span class="math notranslate nohighlight">\(с\)</span> и горизонтальной осью (обозначим его как <span class="math notranslate nohighlight">\(\theta\)</span>) равен <span class="math notranslate nohighlight">\(\frac{\pi}{6}\)</span>. Если забежать немного вперед, то можно сказать, что наша цель – добиться, чтобы текущее состояние дошло до <span class="math notranslate nohighlight">\(\frac{\pi}{2}\)</span> (или хотя бы приблизительно), то есть почти или полностью равнялось искомому состоянию, так что после измерения можно было его и получить с высокой вероятностью.</p>
<p>Координаты текущего вектора состояния можно записать через угол <span class="math notranslate nohighlight">\(\theta\)</span>:</p>
<p><span class="math notranslate nohighlight">\(x = \cos{\theta}\)</span></p>
<p><span class="math notranslate nohighlight">\(y = \sin{\theta}\)</span></p>
<p>На всякий случай нужно уточнить, что вспомогательный кубит не отражается на рисунке с окружностью, так как он не предназначен для обозначения индекса, а только хранит в себе его метку.</p>
<p>После применения функции-оракула текущий вектор отразится относительно горизонтальной оси. Объясняется это очень легко – его вертикальная компонента (вектор <span class="math notranslate nohighlight">\(|11\rangle\)</span>) становится отрицательной.</p>
<p>Вектор <span class="math notranslate nohighlight">\(c_{1b}\)</span> – это отражение вектора <span class="math notranslate nohighlight">\(c\)</span> на угол <span class="math notranslate nohighlight">\(\theta\)</span> вниз относительно горизонтальной оси:</p>
<div class="figure align-default" id="grover-1b">
<a class="reference internal image-reference" href="../_images/grover_1b.png"><img alt="../_images/grover_1b.png" src="../_images/grover_1b.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-number">Fig. 46 </span><span class="caption-text">Состояние системы после первой части первой итерации.</span><a class="headerlink" href="#grover-1b" title="Permalink to this image">¶</a></p>
</div>
<p>Такое отражение в нашем примере производится с помощью операции <span class="math notranslate nohighlight">\(CCNOT\)</span>, но в общем случае операция выглядит так:</p>
<p><span class="math notranslate nohighlight">\(U_{1b} = I - 2|b\rangle \langle b|\)</span></p>
<p>Функцию-оракул мы здесь обозначили как <span class="math notranslate nohighlight">\(U_{1b}\)</span>. Она меняет знак только для вертикальной составляющей вектора состояния, поэтому и происходит отражение.</p>
<p>Проверим формулу в действии, применив ее для нашего примера:</p>
<p><span class="math notranslate nohighlight">\(U_{1b} |c\rangle = (I - 2|11\rangle \langle 11|) \frac{1}{2}(|00\rangle + |01\rangle + |10\rangle + |11\rangle) = \frac{1}{2} (|00\rangle + |01\rangle + |10\rangle + |11\rangle - 2|11\rangle) = \frac{1}{2} (|00\rangle + |01\rangle + |10\rangle - |11\rangle)\)</span></p>
<p>И наконец приступаем к разбору второй части первой итерации. В ней будет происходить еще одно отражение вектора, но уже не относительно горизонтальной оси, а относительно вектора <span class="math notranslate nohighlight">\(c\)</span>. Нетрудно заметить, что при этом текущий вектор состояния станет равен <span class="math notranslate nohighlight">\(\cos{3 \theta}|a\rangle + \sin{3 \theta}|b\rangle\)</span>.</p>
<div class="figure align-default" id="grover-1c">
<a class="reference internal image-reference" href="../_images/grover_1c.png"><img alt="../_images/grover_1c.png" src="../_images/grover_1c.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-number">Fig. 47 </span><span class="caption-text">Состояние системы после второй части первой итерации.</span><a class="headerlink" href="#grover-1c" title="Permalink to this image">¶</a></p>
</div>
<p>Операция для получения вектора <span class="math notranslate nohighlight">\(c_{1c}\)</span> будет выглядеть так:</p>
<p><span class="math notranslate nohighlight">\(U_{1c} = 2|c\rangle \langle c| - I\)</span></p>
<p>Посчитаем, чему равен вектор <span class="math notranslate nohighlight">\(c_{1c}\)</span> для нашего примера:</p>
<p><span class="math notranslate nohighlight">\(U_{1c} |c_{1b}\rangle = (2|c\rangle \langle c| - I) \frac{1}{2}(|00\rangle + |01\rangle + |10\rangle - |11\rangle) = |11\rangle\)</span></p>
<p>Произошло отражение текущего вектора состояния <span class="math notranslate nohighlight">\(|c_{1b}\rangle\)</span> относительно вектора <span class="math notranslate nohighlight">\(|c\rangle\)</span>. Если представить <span class="math notranslate nohighlight">\(|c_{1b}\rangle\)</span> как <span class="math notranslate nohighlight">\(k_1 |c\rangle + k_2 |c_{\bot}\rangle\)</span>, где <span class="math notranslate nohighlight">\(|c_{\bot}\rangle\)</span> – вектор, перпендикулярный <span class="math notranslate nohighlight">\(|c\rangle\)</span>, а <span class="math notranslate nohighlight">\(k_1\)</span> и <span class="math notranslate nohighlight">\(k_2\)</span> – действительные коэффициенты, то тогда отраженный вектор будет равен <span class="math notranslate nohighlight">\(k_1 |c\rangle - k_2 |c_{\bot}\rangle\)</span>.</p>
<p>В нашей квантовой схеме эта часть итерации реализована таким образом:</p>
<div class="figure align-default" id="iteration-part2">
<a class="reference internal image-reference" href="../_images/iteration_part2.png"><img alt="../_images/iteration_part2.png" src="../_images/iteration_part2.png" style="width: 450px;" /></a>
<p class="caption"><span class="caption-number">Fig. 48 </span><span class="caption-text">Вторая часть итерации.</span><a class="headerlink" href="#iteration-part2" title="Permalink to this image">¶</a></p>
</div>
<p>Вначале применяется оператор Адамара для первого и второго кубитов. Это упрощает нашу задачу, так как теперь отразить вектор состояния нужно не относительно состояния суперпозиции <span class="math notranslate nohighlight">\(\frac{1}{2}(|00\rangle + |01\rangle + |10\rangle + |11\rangle)\)</span>, а относительно состояния <span class="math notranslate nohighlight">\(|00\rangle\)</span>.</p>
<p>Далее требуется отразить вектор, то есть всем состояниям кроме нулевого присвоить минус, но мы сделаем проще: присвоим минус нулевому состоянию <span class="math notranslate nohighlight">\(|00\rangle\)</span>, а остальные состояния, составляющие суперпозицию, оставим как есть. Сделаем это, последовательно применив гейты <span class="math notranslate nohighlight">\(X\)</span> и <span class="math notranslate nohighlight">\(CCNOT\)</span>. После этого вернемся в исходную “систему координат”, применив операции в обратном порядке: сначала <span class="math notranslate nohighlight">\(X\)</span>, а потом <span class="math notranslate nohighlight">\(H\)</span>.</p>
<p>Из-за применения такого лайфхака (присвоения минуса нулевому состоянию) мы в нашем двухкубитном примере получим результат с точностью до общей фазы: не <span class="math notranslate nohighlight">\(|11\rangle\)</span>, а <span class="math notranslate nohighlight">\(-|11\rangle\)</span>. Но это не страшно, так как после измерения мы все равно увидим искомое значение индекса.</p>
<p>По рисунку, изображающему на окружности состояние системы после второй части первой итерации, видно, что в общем случае каждая последующая итерация будет приближать текущий вектор к вертикальному. Но в нашем случае угол между вектором состояния и горизонтальной осью после окончания первой итерации равен <span class="math notranslate nohighlight">\(3 \theta\)</span>, то есть это уже и есть желаемый угол <span class="math notranslate nohighlight">\(\frac{\pi}{2}\)</span>.</p>
<p>В общем случае этот угол равен <span class="math notranslate nohighlight">\((2t + 1) \theta \approx \frac{\pi}{2}\)</span>, где <span class="math notranslate nohighlight">\(t\)</span> – номер произведенной итерации. Отсюда можно вывести число итераций, необходимое для работы алгоритма. При большом количестве итераций <span class="math notranslate nohighlight">\(t\)</span> угол <span class="math notranslate nohighlight">\(\theta\)</span> будет стремиться к <span class="math notranslate nohighlight">\(0\)</span>, так что его можно заменить на <span class="math notranslate nohighlight">\(\sin{\theta}\)</span>, который, в свою очередь, равен <span class="math notranslate nohighlight">\(\frac{1}{\sqrt{N}}\)</span>:</p>
<p><span class="math notranslate nohighlight">\((2t + 1) \theta \rightarrow (2t + 1) \frac{1}{\sqrt{N}} \approx \frac{\pi}{2}\)</span></p>
<p>Если пренебречь единицей в скобках на основании того, что <span class="math notranslate nohighlight">\(t\)</span> – большое число, можно найти, что <span class="math notranslate nohighlight">\(t\)</span> приблизительно равно <span class="math notranslate nohighlight">\(\frac{\pi \sqrt{N}}{4}\)</span>.</p>
<p>Мы уже разобрались, что каждая итерация состоит из двух частей. Первая часть – отражение вниз относительно горизонтальной оси. Вторая часть – отражение вверх относительно изначального состояния, то есть вектора <span class="math notranslate nohighlight">\(c\)</span>. Вектор состояния всегда будет отражаться вверх на больший угол, чем в первой части итерации. Этим и будет обеспечиваться его постепенное приближение в вертикальной оси.</p>
<p>Мы разобрали случай, когда требуется найти один объект в таблице. Если же потребуется найти несколько объектов, то тогда, обозначив их количество за <span class="math notranslate nohighlight">\(K\)</span>, мы должны будем проделать около <span class="math notranslate nohighlight">\(\frac {\pi}{4} \sqrt {\frac{N}{K}}\)</span> итераций. Таким образом, для успешной работы алгоритма Гровера необходимо знать число <span class="math notranslate nohighlight">\(K\)</span>, чтобы можно было найти через него угол <span class="math notranslate nohighlight">\(\theta\)</span>, а затем число итераций.</p>
<div class="section" id="id2">
<h4>Реализация алгоритма Гровера<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>Итак, мы разобрали общие принципы алгоритма Гровера, а также рассмотрели конкретный пример. Настало время написать для этого примера программу.</p>
<p>Для начала импортируем все необходимые библиотеки и создадим схему из трех кубитов:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pennylane</span> <span class="k">as</span> <span class="nn">qml</span>
<span class="kn">from</span> <span class="nn">pennylane</span> <span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="n">dev</span> <span class="o">=</span> <span class="n">qml</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s1">&#39;default.qubit&#39;</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Начальная функция, создающая суперпозицию для каждого кубита:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">U_start</span><span class="p">():</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">PauliX</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Создадим функцию, действующую аналогично оракулу (первая часть итерации). Эта функция помечает значение индекса <span class="math notranslate nohighlight">\(11\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span> <span class="k">def</span> <span class="nf">U_b</span><span class="p">():</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">Toffoli</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>Вторая часть итерации:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span> <span class="k">def</span> <span class="nf">U_c</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
        <span class="n">qml</span><span class="o">.</span><span class="n">PauliX</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>

    <span class="n">qml</span><span class="o">.</span><span class="n">Toffoli</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">qml</span><span class="o">.</span><span class="n">PauliX</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
        <span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Объединим первую и вторую часть итерации в одну функцию:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">U_iteration</span><span class="p">():</span>
    <span class="n">U_b</span><span class="p">()</span>
    <span class="n">U_c</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Переходим к итоговой функции, содержащей все шаги, а также производящей измерение кубитов в конце. В аргументе <span class="math notranslate nohighlight">\(N\)</span> мы должны будем указать количество итераций:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">circuit</span><span class="p">(</span><span class="n">N</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="n">U_start</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">U_iteration</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">qml</span><span class="o">.</span><span class="n">probs</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>Запускаем функцию и выведем ее результат:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">circuit</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[0. 0. 0. 1.]
</pre></div>
</div>
</div>
</div>
<p>Так как в качестве искомого индекса выступало значение <span class="math notranslate nohighlight">\(11\)</span>, то в результате запуска функции мы должны получить массив, состоящий из вероятностей каждого индекса, в котором искомый индекс (в нашем примере он будет последним в массиве) должен иметь наибольшую вероятность. Параметр устройства <code class="docutils literal notranslate"><span class="pre">shots</span></code> при необходимости можно увеличивать, не забывая о том, что его увеличение будет кратно замедлять алгоритм. Таким образом, мы нашли с помощью алгоритма Гровера искомый индекс.</p>
<p>Алгоритм Гровера может применяться не только для задач простого поиска в базе данных, но и как дополнительное средство ускорения для поиска экстремума целочисленной функции, а также для поиска совпадающих строк в базе данных, так что этот алгоритм, как и его модификации, сможет быть полезным в разнообразных задачах Data Science.</p>
</div>
<div class="section" id="id3">
<h4>Задание<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<ol class="simple">
<li><p>Распишите операторы <span class="math notranslate nohighlight">\(U_{1b}\)</span> и <span class="math notranslate nohighlight">\(U_{1c}\)</span> из примера в виде матриц <span class="math notranslate nohighlight">\(4\)</span>x<span class="math notranslate nohighlight">\(4\)</span> и проведите расчеты для получения <span class="math notranslate nohighlight">\(c_{1b}\)</span> и <span class="math notranslate nohighlight">\(c_{1c}\)</span> в виде векторов-столбцов.</p></li>
<li><p>Модифицируйте приведенный выше код алгоритма Гровера для двухкубитной базы данных так, чтобы искомый индекс соответствовал состоянию <span class="math notranslate nohighlight">\(|00\rangle\)</span>.</p></li>
</ol>
</div>
</div>
</div>
<div class="toctree-wrapper compound">
<span id="document-book/progblock/progintro"></span><div class="section" id="progintro">
<span id="id1"></span><h3>О блоке<a class="headerlink" href="#progintro" title="Permalink to this headline">¶</a></h3>
<p>Этот блок включает в себя обзор фреймворков и библиотек для квантовых вычислений. Основная часть курса будет строиться вокруг библиотеки <code class="docutils literal notranslate"><span class="pre">PennyLane</span></code>. Этот фреймворк кажется наиболее простым в освоении, а также является платформо-независимым, так как представляет собой высокоуровневый API. Дополнительные лекции этого блока расскажут также про:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Qiskit</span></code> от компании IBM;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cirq</span></code> и <code class="docutils literal notranslate"><span class="pre">Tensorflow</span> <span class="pre">Quantum</span></code> от компании Google.</p></li>
</ul>
</div>
<span id="document-book/progblock/pennylane"></span><div class="section" id="pennylane">
<h3>PennyLane<a class="headerlink" href="#pennylane" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="https://pennylane.ai/">PennyLane</a> – библиотека Python для квантового машинного обучения, которую можно использовать для обычных квантовых вычислений. Программы, написанные на PennyLane, можно запускать, используя в качестве бэкенда настоящие квантовые компьютеры от IBM Q, Xanadu, Rigetti и другие, либо квантовые симуляторы.</p>
<p>Кубиты в PennyLane называются по-особому – <code class="docutils literal notranslate"><span class="pre">wires</span></code> (от англ. wires – провода). Такое название, скорее всего, связано с тем, что на квантовых схемах кубиты изображаются в виде продольных линий.</p>
<p>Последовательность квантовых операций называется <em>квантовой функцией</em>. Такая функция может принимать в качестве аргументов только хэшируемые объекты. В качестве возвращаемого значения выступают величины, связанные с результатами измерения: ожидаемое значение, вероятности состояний или результаты сэмплирования.</p>
<p>Квантовая функция существует не сама по себе, она запускается на определенном устройстве – симуляторе либо настоящем квантовом компьютере. Такое устройство в PennyLane называется <code class="docutils literal notranslate"><span class="pre">device</span></code>.</p>
<div class="section" id="qnode">
<h4>QNode<a class="headerlink" href="#qnode" title="Permalink to this headline">¶</a></h4>
<p>Квантовые вычисления при использовании PennyLane раскладываются на отдельные узлы, которые называются <code class="docutils literal notranslate"><span class="pre">QNode</span></code>. Для их создания используются квантовые функции совместно с <code class="docutils literal notranslate"><span class="pre">device</span></code>.</p>
<p>Создавать объекты квантовых узлов можно двумя способами: явно либо с помощью декоратора <code class="docutils literal notranslate"><span class="pre">QNode</span></code>.</p>
<p>Рассмотрим первый способ – явное создание узла.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pennylane</span> <span class="k">as</span> <span class="nn">qml</span>
<span class="kn">from</span> <span class="nn">pennylane</span> <span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dev</span> <span class="o">=</span> <span class="n">qml</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s1">&#39;default.qubit&#39;</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">analytic</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">make_entanglement</span><span class="p">():</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">CNOT</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">qml</span><span class="o">.</span><span class="n">probs</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuit</span> <span class="o">=</span> <span class="n">qml</span><span class="o">.</span><span class="n">QNode</span><span class="p">(</span><span class="n">make_entanglement</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuit</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>tensor([0.475, 0.   , 0.   , 0.525], requires_grad=False)
</pre></div>
</div>
</div>
</div>
<p>Работая с библиотекой PennyLane для математических операций, можно использовать интерфейс <code class="docutils literal notranslate"><span class="pre">NumPy</span></code>, но при этом также пользоваться преимуществами автоматического дифференцирования, которое обеспечивает <a href="https://github.com/HIPS/autograd">autograd</a>.
Именно поэтому мы не импортировали <code class="docutils literal notranslate"><span class="pre">NumPy</span></code> обычным способом: <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">numpy</span> <span class="pre">as</span> <span class="pre">np</span></code>, а сделали это так:</p>
<p><code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">pennylane</span> <span class="pre">import</span> <span class="pre">numpy</span> <span class="pre">as</span> <span class="pre">np</span></code>.</p>
<p>Второй способ создания квантовых узлов – с помощью декоратора <code class="docutils literal notranslate"><span class="pre">QNode</span></code>. Пропускаем импорт библиотек и создание устройства, так как в начале код тот же самый:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">circuit</span><span class="p">():</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">CNOT</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">qml</span><span class="o">.</span><span class="n">probs</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">circuit</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[0.487 0.    0.    0.513]
</pre></div>
</div>
</div>
</div>
<p>В данном примере мы взяли двухкубитную систему и создали запутанное состояние, а затем с помощью метода <code class="docutils literal notranslate"><span class="pre">probs</span></code> вычислили вероятности получения состояний <span class="math notranslate nohighlight">\(|00\rangle\)</span>, <span class="math notranslate nohighlight">\(|01\rangle\)</span>, <span class="math notranslate nohighlight">\(|10\rangle\)</span>, <span class="math notranslate nohighlight">\(|11\rangle\)</span>.</p>
</div>
<div class="section" id="id1">
<h4>Операторы<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>В квантовой функции можно применять операторы X, Y, Z, S, T (<code class="docutils literal notranslate"><span class="pre">qml.PauliX</span></code>, <code class="docutils literal notranslate"><span class="pre">qml.PauliY</span></code>, <code class="docutils literal notranslate"><span class="pre">qml.PauliZ</span></code>, <code class="docutils literal notranslate"><span class="pre">qml.S</span></code>, <code class="docutils literal notranslate"><span class="pre">qml.T</span></code> соответственно), а также операторы, в которых можно задавать угол вращения вокруг одной из осей в радианах: <code class="docutils literal notranslate"><span class="pre">qml.RX</span></code>, <code class="docutils literal notranslate"><span class="pre">qml.RY</span></code>, <code class="docutils literal notranslate"><span class="pre">qml.Z</span></code>. Здесь и далее будем использовать <code class="docutils literal notranslate"><span class="pre">qml</span></code> как псевдоним библиотеки <code class="docutils literal notranslate"><span class="pre">PennyLane</span></code>.</p>
<p>В этой функции мы вращаем кубит под индексом 0 вокруг оси X на 90 градусов из начального состояния <span class="math notranslate nohighlight">\(|0\rangle\)</span> и возвращаем <strong>ожидаемое значение</strong> <code class="docutils literal notranslate"><span class="pre">qml.PauliZ</span></code> для этого кубита с помощью <code class="docutils literal notranslate"><span class="pre">qml.expval</span></code>. Вероятности получения состояний <span class="math notranslate nohighlight">\(|0\rangle\)</span> и <span class="math notranslate nohighlight">\(|1\rangle\)</span> равны, так что мы получаем ожидаемое значение, близкое к нулю, что легко проверить:</p>
<div class="math notranslate nohighlight">
\[0.5 \cdot 1 + 0.5 \cdot (-1) = 0\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">circuit</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">RX</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">qml</span><span class="o">.</span><span class="n">expval</span><span class="p">(</span><span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

<span class="n">circuit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>tensor(-0.03, requires_grad=True)
</pre></div>
</div>
</div>
</div>
<p>В следующем примере мы вращаем кубит на тот же угол 90 градусов, но уже вокруг оси Y. Ожидаемое значение в этот раз ищем для <code class="docutils literal notranslate"><span class="pre">qml.PauliX</span></code> и получаем 1, что соответствует вычислениям:</p>
<div class="math notranslate nohighlight">
\[1 \cdot 1 + 0 \cdot (-1) = 1\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">circuit</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">RY</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">qml</span><span class="o">.</span><span class="n">expval</span><span class="p">(</span><span class="n">qml</span><span class="o">.</span><span class="n">PauliX</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

<span class="n">circuit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>tensor(1., requires_grad=True)
</pre></div>
</div>
</div>
</div>
<p>В начале этого урока мы создали устройство, которое создает и запускает одну и ту же схему 1000 раз, каждый раз производя измерения. Поменяем этот параметр:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dev</span><span class="o">.</span><span class="n">shots</span> <span class="o">=</span> <span class="mi">5</span>
</pre></div>
</div>
</div>
</div>
<p>Посмотрим на результат каждого из этих пяти запусков и измерений для <code class="docutils literal notranslate"><span class="pre">qml.PauliZ</span></code>. Квантовая схема будет простой: применим к кубиту с индексом 1 оператор Адамара:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">circuit</span><span class="p">():</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">qml</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span><span class="p">([</span><span class="mi">1</span><span class="p">]))</span>

<span class="n">circuit</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([-1, -1, -1, -1,  1])
</pre></div>
</div>
</div>
</div>
<p>Мы получаем разные результаты: то 1, что соответствует состоянию <span class="math notranslate nohighlight">\(|0\rangle\)</span>, то -1, что соответствует состоянию <span class="math notranslate nohighlight">\(|1\rangle\)</span>.</p>
<p>Если вместо <code class="docutils literal notranslate"><span class="pre">qml.PauliZ</span></code> брать сэмплы для <code class="docutils literal notranslate"><span class="pre">qml.PauliX</span></code>, то результат все время будет один и тот же: 1, что соответствует состоянию <span class="math notranslate nohighlight">\(|+\rangle\)</span> (вектор базиса Адамара).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">circuit</span><span class="p">():</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">qml</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">qml</span><span class="o">.</span><span class="n">PauliX</span><span class="p">([</span><span class="mi">1</span><span class="p">]))</span>

<span class="n">circuit</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([1, 1, 1, 1, 1])
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="qubitunitary">
<h4>QubitUnitary<a class="headerlink" href="#qubitunitary" title="Permalink to this headline">¶</a></h4>
<p>В PennyLane можно использовать готовые операторы, либо задавать операторы явно с помощью матриц.</p>
<p>Для этого можно использовать класс <code class="docutils literal notranslate"><span class="pre">qml.QubitUnitary</span></code>, который принимает два параметра: U – квадратную унитарную матрицу и <code class="docutils literal notranslate"><span class="pre">wires</span></code> – кубиты, на которые действует оператор U.</p>
<p>В качестве примера создадим оператор, осуществляющий обмен состояний между кубитами (SWAP). Такой оператор уже есть в библиотеке PennyLane (<code class="docutils literal notranslate"><span class="pre">qml.SWAP</span></code>), но мы создадим его с помощью <code class="docutils literal notranslate"><span class="pre">qml.QubitUnitary</span></code>. Сначала мы зададим саму матрицу в виде двумерного массива, используя интерфейс <code class="docutils literal notranslate"><span class="pre">NumPy</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> 
              <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> 
              <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> 
              <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
</pre></div>
</div>
</div>
</div>
<p>Создадим заново устройство, при этом зададим число запусков схемы как shots=1: чтобы убедиться, что все работает правильно, нам будет достаточно одного запуска.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dev</span> <span class="o">=</span> <span class="n">qml</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s1">&#39;default.qubit&#39;</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">analytic</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Создадим и запустим схему, в которой перед применением операции SWAP, реализованной с помощью <code class="docutils literal notranslate"><span class="pre">qml.QubitUnitary</span></code>, один кубит будет находиться в состоянии 1, а другой – в состоянии 0.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">circuit</span><span class="p">(</span><span class="n">do_swap</span><span class="p">):</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">PauliX</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">do_swap</span><span class="p">:</span>
        <span class="n">qml</span><span class="o">.</span><span class="n">QubitUnitary</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">qml</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span><span class="p">([</span><span class="mi">0</span><span class="p">])),</span> <span class="n">qml</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span><span class="p">([</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
</div>
</div>
<p>Запустим схему сначала без применения операции SWAP:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuit</span><span class="p">(</span><span class="n">do_swap</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[-1],
       [ 1]])
</pre></div>
</div>
</div>
</div>
<p>А затем – с применением:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuit</span><span class="p">(</span><span class="n">do_swap</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[ 1],
       [-1]])
</pre></div>
</div>
</div>
</div>
<p>Видим, что во втором случае операция SWAP сработала: состояния кубитов поменялись местами. Можно посмотреть, как выглядит такая схема:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">circuit</span><span class="o">.</span><span class="n">draw</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span> 0: ──X──╭U0──┤ Sample[Z] 
 1: ─────╰U0──┤ Sample[Z] 
U0 =
[[1 0 0 0]
 [0 0 1 0]
 [0 1 0 0]
 [0 0 0 1]]
</pre></div>
</div>
</div>
</div>
</div>
</div>
<span id="document-book/progblock/tfq"></span><div class="section" id="cirq-tfq">
<span id="tfq"></span><h3>Cirq &amp; TFQ<a class="headerlink" href="#cirq-tfq" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id1">
<h4>Введение<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p><a class="reference external" href="https://quantumai.google/cirq">Cirq</a> – это библиотека для работы с квантовыми компьютерами и симуляторами компании <em>Google</em>. В рамках темы квантового машинного обучения нам также интересен фреймворк <a class="reference external" href="https://www.tensorflow.org/quantum/overview">Tensorflow Quantum</a> или сокращенно <code class="docutils literal notranslate"><span class="pre">TFQ</span></code>. Это высокоуровневая библиотека, которая содержит готовые функции для квантового и гибридного машинного обучения. В качестве системы автоматического дифференцирования, а также для построения гибридных квантово-классических нейронных сетей там используется библиотека <a class="reference external" href="https://www.tensorflow.org/overview/">Tensorflow</a>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Во всех дальнейших лекциях мы будем использовать в основном библиотеку <code class="docutils literal notranslate"><span class="pre">PennyLane</span></code>, так что данная лекция исключительно обзорная и факультативная. В ней мы посмотрим несколько примеров <em>end2end</em> обучения квантовых схем на <code class="docutils literal notranslate"><span class="pre">TFQ</span></code> без детального объяснения теории и вообще того, что происходит. Основная цель данной лекции – исключительно обзор еще одного инструмента, а не изучение QML! Заинтересованный читатель может вернуться к этому обзору после изучения глав про <a class="reference internal" href="book/index.html#vqc"><span class="std std-ref">VQC</span></a>, <a class="reference internal" href="book/index.html#gradients"><span class="std std-ref">Градиенты</span></a> и <strong>Квантовые нейросети</strong>.</p>
</div>
</div>
<div class="section" id="id2">
<h4>Работа с кубитами<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<div class="section" id="id3">
<h5>Импорты и схема<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h5>
<p>Для начала импортируем <code class="docutils literal notranslate"><span class="pre">cirq</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cirq</span>
</pre></div>
</div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Cirq</span></code> рассчитан на работу с квантовым компьютером от компании <em>Google</em>, который представляет собой решетку кубитов. Например, вот так выглядит решетка кубитов квантового компьютера <code class="docutils literal notranslate"><span class="pre">Sycamore</span></code>:</p>
<div class="figure align-default" id="sycamore-lattice">
<a class="reference internal image-reference" href="../_images/sycamore.png"><img alt="../_images/sycamore.png" src="../_images/sycamore.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-number">Fig. 49 </span><span class="caption-text">Изображение из <span id="id4">[<a class="reference internal" href="book/index.html#id10"><span>AAB+19</span></a>]</span></span><a class="headerlink" href="#sycamore-lattice" title="Permalink to this image">¶</a></p>
</div>
<p>Поэтому в нем все строится вокруг работы с решеткой кубитов – объектом <code class="docutils literal notranslate"><span class="pre">cirq.GridQubit</span></code>. Давайте создадим кубит на решетке, который имеет координаты <span class="math notranslate nohighlight">\((0, 0)\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qubit</span> <span class="o">=</span> <span class="n">cirq</span><span class="o">.</span><span class="n">GridQubit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Следующей важной концепцией в <code class="docutils literal notranslate"><span class="pre">Cirq</span></code> является непосредственно квантовая схема. Давайте создадим схему, которая переводит кубит в суперпозицию состояний <span class="math notranslate nohighlight">\(\ket{0}\)</span> и <span class="math notranslate nohighlight">\(\ket{1}\)</span> и измеряет его:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuit</span> <span class="o">=</span> <span class="n">cirq</span><span class="o">.</span><span class="n">Circuit</span><span class="p">()</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cirq</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="n">qubit</span><span class="p">))</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cirq</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">qubit</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(0, 0): ───H───M───
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id5">
<h5>Запуск и симуляция<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h5>
<p>Теперь создадим квантовый симулятор, который посчитает нам результат этой простой схемы на классическом компьютере:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sim</span> <span class="o">=</span> <span class="n">cirq</span><span class="o">.</span><span class="n">Simulator</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Как мы знаем, результат измерения такой схемы равен 50% для состояния <span class="math notranslate nohighlight">\(\ket{0}\)</span>, то есть если мы будем сэмплировать, то должны получать <span class="math notranslate nohighlight">\(\sim 0.5\)</span>. Проверим это с разным числом сэмплов:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;5 сэмплов:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">repetitions</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">100 сэмплов:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">repetitions</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">1000 сэмплов:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">repetitions</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>5 сэмплов:
(0, 0)    0.8
dtype: float64

100 сэмплов:
(0, 0)    0.44
dtype: float64

1000 сэмплов:
(0, 0)    0.51
dtype: float64
</pre></div>
</div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Метод <code class="docutils literal notranslate"><span class="pre">sim.sample</span></code> озвращает хорошо знакомый всем специалистам в области Data Science объект <code class="docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code>. Для тех, кто слышит про такой впервые рекомендуем обратиться к вводным лекциям про <code class="docutils literal notranslate"><span class="pre">Python</span></code> и классическое машинное обучение.</p>
</div>
<p>Также у нас есть опция запустить схему через метод <code class="docutils literal notranslate"><span class="pre">run</span></code>. Может показаться, что это то же самое, но на самом деле в отличие от <code class="docutils literal notranslate"><span class="pre">sample</span></code> метод <code class="docutils literal notranslate"><span class="pre">run</span></code> возвращает результат в несколько ином виде, а еще он позволяет запускать программу на реальном квантовом компьютере <code class="docutils literal notranslate"><span class="pre">Goolge</span></code> или их новых квантовых симуляторах на TPU:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">repetitions</span><span class="o">=</span><span class="mi">25</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(0, 0)=0100001100011110011110101
</pre></div>
</div>
</div>
</div>
<p>Тут мы просто видим последовательность наших измерений.</p>
</div>
</div>
<div class="section" id="id6">
<h4>Квантовое машинное обучение<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<div class="section" id="id7">
<h5>Импорты<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h5>
<p>Мы будем использовать <code class="docutils literal notranslate"><span class="pre">Tensorflow</span></code> и <code class="docutils literal notranslate"><span class="pre">Tensorflow</span> <span class="pre">Quantum</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="nn">tf</span>
<span class="kn">import</span> <span class="nn">tensorflow_quantum</span> <span class="k">as</span> <span class="nn">tfq</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id8">
<h5>Задача<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h5>
<p>Давайте попробуем решить игрушечную задачку классификации простой гибридной квантово-классической нейронной сетью. У нас будет один квантовый слой и один классический слой. В качестве задачи сгенерируем простенький набор данных, используя рутины <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code>. Сразу переведем входящие признаки в диапазон от нуля до <span class="math notranslate nohighlight">\(\pi\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">make_classification</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_classification</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">n_features</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_informative</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                           <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="n">n_redundant</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">x_min</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">x_max</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">)</span>

<span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
<span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>Посмотрим на эти данные:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">cb</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/tfq_17_0.png" src="../_images/tfq_17_0.png" />
</div>
</div>
</div>
<div class="section" id="id9">
<h5>Кубиты<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">Tensorflow</span> <span class="pre">Quantum</span></code> позволяет “превращать” параметризированные схемы <code class="docutils literal notranslate"><span class="pre">Cirq</span></code> в слои нейронных сетей <code class="docutils literal notranslate"><span class="pre">Tensorflow</span></code>. Но для начала нам все равно потребуется схема. Давайте объявим пару кубитов.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qubits</span> <span class="o">=</span> <span class="p">[</span><span class="n">cirq</span><span class="o">.</span><span class="n">GridQubit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">cirq</span><span class="o">.</span><span class="n">GridQubit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[cirq.GridQubit(0, 0), cirq.GridQubit(0, 1)]
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id10">
<h5>Входной слой нейронной сети<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h5>
<p>Определим входной слой, который будет кодировать наши классические данные в квантовые. Сразу закодируем данные. Так как <code class="docutils literal notranslate"><span class="pre">Tensorflow</span></code> работает с тензорами, то нам необходимо будет преобразовать схемы в тензор. Для этого есть специальная функция <code class="docutils literal notranslate"><span class="pre">convert_to_tensor</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">data2circuit</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">input_circuit</span> <span class="o">=</span> <span class="n">cirq</span><span class="o">.</span><span class="n">Circuit</span><span class="p">()</span>

    <span class="n">input_circuit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cirq</span><span class="o">.</span><span class="n">Ry</span><span class="p">(</span><span class="n">rads</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">input_circuit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cirq</span><span class="o">.</span><span class="n">Ry</span><span class="p">(</span><span class="n">rads</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">input_circuit</span>

<span class="n">x_input</span> <span class="o">=</span> <span class="n">tfq</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">([</span><span class="n">data2circuit</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">x</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id11">
<h5>Слой из параметризованной схемы<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h5>
<p>Для создания параметризованных схем в <code class="docutils literal notranslate"><span class="pre">Tensorflow</span> <span class="pre">Quantum</span></code> используются символы из библиотеки символьных вычислений <a class="reference external" href="https://www.sympy.org/en/index.html"><code class="docutils literal notranslate"><span class="pre">sympy</span></code></a>. Давайте объявим несколько параметров и создадим схему:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>

<span class="n">params</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;w1, w2, w3, w4&quot;</span><span class="p">)</span>

<span class="n">trainable_circuit</span> <span class="o">=</span> <span class="n">cirq</span><span class="o">.</span><span class="n">Circuit</span><span class="p">()</span>

<span class="n">trainable_circuit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cirq</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="n">trainable_circuit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cirq</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="n">trainable_circuit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cirq</span><span class="o">.</span><span class="n">Ry</span><span class="p">(</span><span class="n">rads</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="n">trainable_circuit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cirq</span><span class="o">.</span><span class="n">Ry</span><span class="p">(</span><span class="n">rads</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

<span class="n">trainable_circuit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cirq</span><span class="o">.</span><span class="n">CNOT</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

<span class="n">trainable_circuit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cirq</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="n">trainable_circuit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cirq</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="n">trainable_circuit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cirq</span><span class="o">.</span><span class="n">Rx</span><span class="p">(</span><span class="n">rads</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="n">trainable_circuit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cirq</span><span class="o">.</span><span class="n">Rx</span><span class="p">(</span><span class="n">rads</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

<span class="n">trainable_circuit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cirq</span><span class="o">.</span><span class="n">CNOT</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

<span class="nb">print</span><span class="p">(</span><span class="n">trainable_circuit</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(0, 0): ───H───Ry(w1)───@───H───Rx(w3)───@───
                        │                │
(0, 1): ───H───Ry(w2)───X───H───Rx(w4)───X───
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id12">
<h5>Наблюдаемые<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h5>
<p>В качестве операторов, которые мы будем измерять, воспользуемся парой <span class="math notranslate nohighlight">\(\hat{XY}\)</span> и <span class="math notranslate nohighlight">\(\hat{YX}\)</span> для наших кубитов:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">cirq</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">cirq</span><span class="o">.</span><span class="n">Y</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">cirq</span><span class="o">.</span><span class="n">Y</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">cirq</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id13">
<h5>Гибридная нейронная сеть<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h5>
<p>Теперь воспользуемся классическим <code class="docutils literal notranslate"><span class="pre">Tensorflow</span></code>, чтобы объявить и скомпилировать нашу нейронную сеть, предварительно добавив в нее один классический слой.</p>
<ul class="simple">
<li><p>зафиксируем случайный генератор</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">tf</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">set_seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>входной тензор – это в нашем случае тензор типа <code class="docutils literal notranslate"><span class="pre">string</span></code>, так как это квантовые схемы</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">cirq_inputs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">dtypes</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>квантовый слой</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">quantum_layer</span> <span class="o">=</span> <span class="n">tfq</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">PQC</span><span class="p">(</span>
    <span class="n">trainable_circuit</span><span class="p">,</span>
    <span class="n">ops</span>
<span class="p">)(</span><span class="n">cirq_inputs</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>классический слой и выходной слой</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dense_layer</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s2">&quot;relu&quot;</span><span class="p">)(</span><span class="n">quantum_layer</span><span class="p">)</span>
<span class="n">output_layer</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s2">&quot;sigmoid&quot;</span><span class="p">)(</span><span class="n">dense_layer</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>компилируем модель и смотрим, что получилось. И сразу указываем метрики, которые хотим отслеживать</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="n">cirq_inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="o">=</span><span class="n">output_layer</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
    <span class="n">optimizer</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">optimizers</span><span class="o">.</span><span class="n">SGD</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">),</span>
    <span class="n">loss</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">losses</span><span class="o">.</span><span class="n">BinaryCrossentropy</span><span class="p">(),</span>
    <span class="n">metrics</span><span class="o">=</span><span class="p">[</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">metrics</span><span class="o">.</span><span class="n">BinaryAccuracy</span><span class="p">(),</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">metrics</span><span class="o">.</span><span class="n">BinaryCrossentropy</span><span class="p">(),</span>
    <span class="p">]</span>
<span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Model: &quot;model&quot;
_________________________________________________________________
Layer (type)                 Output Shape              Param #   
=================================================================
input_1 (InputLayer)         [(None,)]                 0         
_________________________________________________________________
pqc (PQC)                    (None, 2)                 4         
_________________________________________________________________
dense (Dense)                (None, 2)                 6         
_________________________________________________________________
dense_1 (Dense)              (None, 1)                 3         
=================================================================
Total params: 13
Trainable params: 13
Non-trainable params: 0
_________________________________________________________________
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id14">
<h5>Предсказания со случайной инициализацией<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h5>
<p>Наша нейросеть имеет случайные начальные параметры. Давайте посмотрим, что она предсказывает до обучения:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">preds</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x_input</span><span class="p">)</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">cb</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">preds</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/tfq_37_0.png" src="../_images/tfq_37_0.png" />
</div>
</div>
</div>
<div class="section" id="id15">
<h5>Обучение сети<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h5>
<ul class="simple">
<li><p>запустим обучение</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x_input</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;tensorflow.python.keras.callbacks.History at 0x7f52a2655b80&gt;
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>визуализируем логи обучения</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="s2">&quot;binary_accuracy&quot;</span><span class="p">])</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="s2">&quot;binary_crossentropy&quot;</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/tfq_41_0.png" src="../_images/tfq_41_0.png" />
</div>
</div>
<ul class="simple">
<li><p>визуализируем предсказания</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">preds_after_training</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x_input</span><span class="p">)</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">cb</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">preds_after_training</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/tfq_43_0.png" src="../_images/tfq_43_0.png" />
</div>
</div>
</div>
</div>
<div class="section" id="id16">
<h4>Заключение<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h4>
<p>В данной лекции мы познакомились с фреймворком <code class="docutils literal notranslate"><span class="pre">Tensorflow</span> <span class="pre">Quantum</span></code>. Это достаточно мощный инструмент, особенно в связке с <code class="docutils literal notranslate"><span class="pre">Tensorflow</span></code>, так как позволяет использовать большое число готовых методов <code class="docutils literal notranslate"><span class="pre">Tensorflow</span></code> и различных расширений. Тем не менее, для целей обучения <code class="docutils literal notranslate"><span class="pre">Tensorflow</span> <span class="pre">Quantum</span></code> кажется не лучшим выбором, так как имеет много неочевидного синтаксиса и предполагает, как минимум, среднего знания <code class="docutils literal notranslate"><span class="pre">Tensorflow</span></code>. Во всех дальнейших лекциях мы будем использовать в основном библиотеку <code class="docutils literal notranslate"><span class="pre">PennyLane</span></code>.</p>
</div>
</div>
</div>
<div class="toctree-wrapper compound">
<span id="document-book/vqcblock/vqcintro"></span><div class="section" id="vqcintro">
<span id="id1"></span><h3>О блоке<a class="headerlink" href="#vqcintro" title="Permalink to this headline">¶</a></h3>
<p>Этот блок включает в себя:</p>
<ul class="simple">
<li><p>вариационные квантовые схемы (VQC);</p></li>
<li><p>квантовые градиенты.</p></li>
</ul>
<p>Продвинутые темы блока дополнительно рассказывают:</p>
<ul class="simple">
<li><p>об универсальности VQC как аппроксиматоров;</p></li>
<li><p>об интерпретации VQC как ядер.</p></li>
</ul>
</div>
<span id="document-book/vqcblock/vqc"></span><div class="section" id="vqc">
<span id="id1"></span><h3>Вариационные квантовые схемы<a class="headerlink" href="#vqc" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id2">
<h4>Описание лекции<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>На этой лекции мы впервые познакомимся непосредственно с квантовым машинным обучением. Теперь вместо <code class="docutils literal notranslate"><span class="pre">NumPy</span></code> мы будем использовать <code class="docutils literal notranslate"><span class="pre">PennyLane</span></code>. Лекция расскажет:</p>
<ul class="simple">
<li><p>в чем заключается идея квантово-классического обучения;</p></li>
<li><p>что такое вариационное машинное обучение;</p></li>
<li><p>как устроена вариационная квантовая схема и как закодировать в нее данные.</p></li>
</ul>
</div>
<div class="section" id="id3">
<h4>Введение<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>В течение всего курса мы будем говорить преимущественно о комбинированном квантово-классическом машинном обучении, построенном на базе вариационных квантовых схем. Именно он является наиболее перспективным в эпоху <span class="xref std std-term">NISQ</span>. Давайте забежим немного вперед и посмотрим, как выглядит типичный цикл такого обучения.</p>
<div class="figure align-default" id="vqcdiag">
<a class="reference internal image-reference" href="../_images/diagram.png"><img alt="../_images/diagram.png" src="../_images/diagram.png" style="height: 400px;" /></a>
<p class="caption"><span class="caption-number">Fig. 50 </span><span class="caption-text">Пример цикла смешанного обучения</span><a class="headerlink" href="#vqcdiag" title="Permalink to this image">¶</a></p>
</div>
<p>Красным цветом на диаграмме помечены блоки, выполняемые на квантовом устройстве, зеленым – те, что считает обычный компьютер. Квантовая часть, которая включает в себя операторы <span class="math notranslate nohighlight">\(\hat{U(X)}\)</span> и <span class="math notranslate nohighlight">\(\hat{U(\theta})\)</span>, а также измерение наблюдаемой <span class="math notranslate nohighlight">\(\hat{M}\)</span>, называется вариационной квантовой схемой. Именно ей посвящена данная лекция.</p>
<p>Но сначала сделаем шаг назад и обсудим в общих чертах идеи, которые лежат в основе квантово-классического обучения.</p>
</div>
<div class="section" id="id4">
<h4>Квантово-классическое обучение<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>Основная идея квантово-классического обучения заключается в том, что в эпоху Noise Intermediate Scale Quantum (<em>NISQ</em>) у нас нет больших работающих квантовых компьютеров и квантовой памяти. Это сильно ограничивает применение алгоритмов, более быстрых, чем классические. Нам остается только “встраивать” квантовые схемы в классический цикл обучения.</p>
<p>В этом случае мы разделяем классическую и квантовую части алгоритма. Выполняем предварительную обработку и подготовку данных на классическом компьютере, затем “прогоняем” их через квантовую схему. Она должна возвращать нам “классические” данные, а значит, должна включать в себя набор последовательно применяемых операторов и измерение. Со стороны классического компьютера такая схема выглядит как “черный ящик” или “оракул”, с которым уже можно работать. Например, можно варьировать параметры схемы таким образом, чтобы она “обучалась” так же, как “обучаются” нейронные сети или другие алгоритмы классического машинного обучения.</p>
<p>Давайте более детально посмотрим на квантовую схему, которую можно использовать в таком подходе.</p>
</div>
<div class="section" id="id5">
<h4>Вариационные квантовые схемы<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>В основе вариационных квантовых схем – Variational Quantum Circuits (<strong>VQC</strong>) – лежит простая идея. Чтобы проиллюстрировать ее, давайте сделаем схему, которая включает в себя набор унитарных операторов и переводит классические данные <span class="math notranslate nohighlight">\(\mathbf{X}\)</span> и параметры <span class="math notranslate nohighlight">\(\theta\)</span> в квантовое состояние <span class="math notranslate nohighlight">\(\ket{\Psi}(\theta, \mathbf{X})\)</span>. Затем будем варьировать наше состояние <span class="math notranslate nohighlight">\(\ket{\Psi}\)</span>, меняя параметры <span class="math notranslate nohighlight">\(\theta\)</span> так, чтобы при его измерении в каком-либо базисе мы получали нужный результат, например, результат классификации входных данных <span class="math notranslate nohighlight">\(\mathbf{X}\)</span>.</p>
<p>Разберем написанное выше на примере.</p>
<div class="section" id="x">
<h5>Аппроксимация <a class="reference internal" href="book/index.html#term-22"><span class="xref std std-term">матрицы Паули</span></a> <strong>X</strong> оператором поворота<a class="headerlink" href="#x" title="Permalink to this headline">¶</a></h5>
<p>Из предыдущих лекций мы помним, что оператор <span class="math notranslate nohighlight">\(\hat{\mathbf{X}}\)</span> работает как квантовый аналог оператора =NOT= – инвертирует значение кубита.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pennylane</span> <span class="k">as</span> <span class="nn">qml</span>

<span class="n">dev</span> <span class="o">=</span> <span class="n">qml</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">simple_x_gate</span><span class="p">():</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">PauliX</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">qml</span><span class="o">.</span><span class="n">expval</span><span class="p">(</span><span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>


<span class="nb">print</span><span class="p">(</span><span class="n">simple_x_gate</span><span class="p">())</span>

<span class="nb">print</span><span class="p">(</span><span class="n">simple_x_gate</span><span class="o">.</span><span class="n">draw</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-1.0
 0: ──X──┤ ⟨Z⟩ 
</pre></div>
</div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Тут мы измеряем наш кубит в <span class="math notranslate nohighlight">\(\mathbf{Z}\)</span>-базисе и чаще всего будем измерять именно в нем. <span class="math notranslate nohighlight">\(\mathbf{Z}\)</span>-базис является неким “стандартом” для квантовых вычислений, так как это измерение “ближе к железу”. Также <span class="math notranslate nohighlight">\(\mathbf{Z}\)</span>-базис удобен для нас из-за диагональности <a class="reference internal" href="book/index.html#term-22"><span class="xref std std-term">оператора Паули</span></a> <span class="math notranslate nohighlight">\(\sigma^z\)</span>.</p>
</div>
<p>С другой стороны, у нас есть оператор <span class="math notranslate nohighlight">\(\hat{RX}(\phi)\)</span>, который “вращает” состояние нашего кубита вокруг оси <span class="math notranslate nohighlight">\(\mathbf{X}\)</span> на угол <span class="math notranslate nohighlight">\(\phi\)</span>. Сделаем параметризованную схему с одним параметром:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">vqc</span><span class="p">(</span><span class="n">phi</span><span class="p">):</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">RX</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">qml</span><span class="o">.</span><span class="n">expval</span><span class="p">(</span><span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>Теперь попробуем подобрать <span class="math notranslate nohighlight">\(\phi\)</span> так, чтобы параметризованная схема работала точно так же, как оператор <span class="math notranslate nohighlight">\(\hat{X}\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Try 1.0: </span><span class="si">{</span><span class="n">vqc</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Try 2.0: </span><span class="si">{</span><span class="n">vqc</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Try 3.0: </span><span class="si">{</span><span class="n">vqc</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Try 3.14159265359: </span><span class="si">{</span><span class="n">vqc</span><span class="p">(</span><span class="mf">3.14159265359</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Try 1.0: 1.0
Try 2.0: -0.4161468365471423
Try 3.0: -0.9899924966004454
Try 3.14159265359: -1.0
</pre></div>
</div>
</div>
</div>
<p>Получается, что нужный нам угол <span class="math notranslate nohighlight">\(\phi\)</span> составляет ровно <span class="math notranslate nohighlight">\(\pi\)</span>. Это логично, мы могли бы это легко понять из простейших соображений линейной алгебры, либо взглянув на сферу Блоха. Но целью этого примера было проиллюстрировать работу VQC.</p>
<p>Наш процесс “подбора” параметра <span class="math notranslate nohighlight">\(\phi\)</span> крайне примитивный, но следующую лекцию мы полностью посвятим тому, как посчитать градиент параметров квантовой схемы и задействовать всю мощь известных на сегодня методов оптимизации. А пока еще немного подумаем о том, как можно закодировать данные в квантовую схему.</p>
</div>
</div>
<div class="section" id="id6">
<h4>Кодирование данных в VQC<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<p>В конструировании VQC есть две важных части:</p>
<ul class="simple">
<li><p>кодирование классических данных в квантовые операторы;</p></li>
<li><p>выбор наблюдаемой для измерений.</p></li>
</ul>
<p>Вот как можно закодировать данные.</p>
<div class="section" id="id7">
<h5>Кодирование поворотами<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h5>
<p>Один из самых популярных методов кодирования классических данных в квантовые схемы – это использование операторов поворота <span class="math notranslate nohighlight">\(\hat{RY}, \hat{RZ}\)</span>. Представим, что мы хотим отображать вектор из двумерного пространства в один кубит <span class="math notranslate nohighlight">\(\vec{x} \in \mathbb{R}^2 \to \mathbb{C}^2\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">angle_vqc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">RY</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">RZ</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">qml</span><span class="o">.</span><span class="n">expval</span><span class="p">(</span><span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>А теперь давайте посмотрим, как такая схема преобразует данные. Для этого сгенерируем набор случайных двумерных данных в диапазоне <span class="math notranslate nohighlight">\([0, 2\pi]\)</span> и применим к каждой точке нашей схемы, затем визуализируем результаты:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">aa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>
<span class="n">bb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>

<span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">angle_vqc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">aa</span><span class="p">,</span> <span class="n">bb</span><span class="p">)]</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
<span class="n">clb</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">aa</span><span class="p">,</span> <span class="n">bb</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">res</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">clb</span><span class="p">)</span>

<span class="n">f</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/vqc_9_0.png" src="../_images/vqc_9_0.png" />
</div>
</div>
<p>Результат довольно необычный. Предсказать такое довольно сложно и хорошо видна возможность нелинейности <code class="docutils literal notranslate"><span class="pre">VQC</span></code> схем. В дальнейших лекциях мы будем более подробно разбирать возможные варианты кодирования данных. Кстати, кодирование углами настолько популярно, что в <code class="docutils literal notranslate"><span class="pre">PennyLane</span></code> для этого есть специальная функция, которая позволяет “повернуть” сразу множество кубитов, используя список из классических данных:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">angle_vqc_pl</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">templates</span><span class="o">.</span><span class="n">embeddings</span><span class="o">.</span><span class="n">AngleEmbedding</span><span class="p">([</span><span class="n">a</span><span class="p">],</span> <span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rotation</span><span class="o">=</span><span class="s2">&quot;Y&quot;</span><span class="p">)</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">templates</span><span class="o">.</span><span class="n">embeddings</span><span class="o">.</span><span class="n">AngleEmbedding</span><span class="p">([</span><span class="n">b</span><span class="p">],</span> <span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rotation</span><span class="o">=</span><span class="s2">&quot;Z&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">qml</span><span class="o">.</span><span class="n">expval</span><span class="p">(</span><span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>Давайте убедимся, что это даст нам ровно тот же результат:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">res_pl</span> <span class="o">=</span> <span class="p">[</span><span class="n">angle_vqc_pl</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">aa</span><span class="p">,</span> <span class="n">bb</span><span class="p">)]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">res_pl</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id8">
<h5>Важность многокубитных гейтов<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h5>
<p>При кодировании параметров целесообразно использовать многокубитные гейты, так как именно они создают запутанные состояния и раскрывают все преимущества квантовых компьютеров. Давайте попробуем это сделать.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dev2</span> <span class="o">=</span> <span class="n">qml</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev2</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">cnot_vqc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">RY</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">RY</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">RZ</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">RZ</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">CZ</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">qml</span><span class="o">.</span><span class="n">expval</span><span class="p">(</span><span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">@</span> <span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>В этой схеме мы видим оператор <span class="math notranslate nohighlight">\(\hat{CZ}\)</span>, который создает запутанное состояние. Посмотрим, как такая схема преобразует наше исходное пространство случайных точек.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">cnot_vqc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">aa</span><span class="p">,</span> <span class="n">bb</span><span class="p">)]</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
<span class="n">clb</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">aa</span><span class="p">,</span> <span class="n">bb</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">res</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">clb</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/vqc_17_0.png" src="../_images/vqc_17_0.png" />
</div>
</div>
<p>Результат выглядит гораздо интереснее. В целом можно сказать, что выбор способа кодирования данных – один из важнейших при проектировании <strong>VQC</strong>. Мы еще много раз будем обсуждать способы сделать это.</p>
</div>
</div>
<div class="section" id="id9">
<h4>Что мы узнали из лекции<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>В эпоху NISQ эпоху мы чаще всего ограничены комбинированием квантового и классического машинного обучения.</p></li>
<li><p>Ключевой элемент такого обучения – вариационные квантовые схемы (VQC). Основная идея VQC:</p>
<ul>
<li><p>кодируем классические данные в квантовые операторы;</p></li>
<li><p>измеряем состояние;</p></li>
<li><p>варьируем параметры на классическом компьютере так, чтобы измерение давало желаемый результат.</p></li>
</ul>
</li>
<li><p>Один из широко применимых методов кодирования – использование операторов вращений <span class="math notranslate nohighlight">\(\hat{RX}, \hat{RY}, \hat{RZ}\)</span></p></li>
</ul>
</div>
</div>
</div>
<div class="toctree-wrapper compound">
<span id="document-book/gradsblock/gradsintro"></span><div class="section" id="gradsintro">
<span id="id1"></span><h3>О блоке<a class="headerlink" href="#gradsintro" title="Permalink to this headline">¶</a></h3>
<p>Этот блок включает в себя обзор способов оценки градиента VQC.</p>
<p>Продвинутые темы блока раскрывают следующие темы:</p>
<ul class="simple">
<li><p>квантовые градиенты старших порядков;</p></li>
<li><p>квантовый натуральный градиент.</p></li>
</ul>
</div>
<span id="document-book/gradsblock/gradients"></span><div class="section" id="gradients">
<span id="id1"></span><h3>Градиенты квантовых схем<a class="headerlink" href="#gradients" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id2">
<h4>Описание лекции<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>В этой лекции мы детально разберем, как можно оптимизировать параметры VQC:</p>
<ul class="simple">
<li><p>Как выглядит цикл обучения квантовой схемы</p></li>
<li><p>Как работает оценка градиента “под капотом”</p>
<ul>
<li><p>Метод конечных отрезков</p></li>
<li><p>Parameter-shift rule</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id3">
<h4>Введение<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>Как мы уже говорили ранее, VQC выступают в роли “черных ящиков”, которые имеют параметры и как-то преобразуют поступающие в них данные. В этом случае сам процесс оптимизации параметров выполняется на классическом компьютере. Одними из самых эффективных на сегодня методов решения задач непрерывной оптимизации являются градиентные методы. Для этих методов разработан широкий арсенал эвристик и приемов, который применяется в обучении классических глубоких нейронных сетей. Очень хочется применить весь этот арсенал и для квантового машинного обучения. Но как же посчитать градиент вариационной квантовой схемы?</p>
</div>
<div class="section" id="id4">
<h4>Задача лекции<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>На этой лекции мы рассмотрим простую задачку по оптимизации параметров квантовой схемы и на ее примере увидим, как работают квантовые градиенты. В качестве задачи возьмем известный набор данных “Two Moon” из библиотеки <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pennylane</span> <span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">pennylane</span> <span class="k">as</span> <span class="nn">qml</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="o">%</span><span class="k">config</span> InlineBackend.figure_format = &#39;retina&#39;
<span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">make_moons</span>

<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_moons</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Для удобства мы сразу переведем метки классов из <span class="math notranslate nohighlight">\(\{0, 1\} \to \{-1, 1\}\)</span>, а признаки <span class="math notranslate nohighlight">\(\mathbf{X}\)</span> переведем в <span class="math notranslate nohighlight">\([0, \pi]\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Переводит значения в интервал от 0 до pi</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">min_</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    <span class="n">max_</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">min_</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">max_</span> <span class="o">-</span> <span class="n">min_</span><span class="p">)</span>

<span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
<span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">cb</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/gradients_3_0.png" src="../_images/gradients_3_0.png" />
</div>
</div>
</div>
<div class="section" id="id5">
<h4>Вариационная схема<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>Перед тем как мы начнем обучение и будем считать градиенты, нам необходимо определиться с тем, как будет выглядеть наша вариационная схема. Мы посвятим кодированию данных, выбору архитектуры схемы, а также измеряемого оператора еще много занятий. Так что пока просто воспользуемся кодированием признаков <span class="math notranslate nohighlight">\(\mathbf{X}\)</span> вращениями, а сверху применим несколько параметризованных слоев вращений.</p>
<div class="section" id="id6">
<h5>Кодирование признаков<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h5>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dev</span> <span class="o">=</span> <span class="n">qml</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">encoding</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">RY</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">RY</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">RZ</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">RZ</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">CZ</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id7">
<h5>Параметризованные слои<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h5>
<p>В качестве одного слоя обучения мы будем использовать параметризованные вращения в связке с двухкубитным гейтом для создания запутанных состояний.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Более детально о запутанных состояниях, а также квантовой энтропии и черных дырах можно посмотреть в продвинутой лекции блока про квантовые вычисления.</p>
</div>
<p>В этой лекции у нас нет цели идеально решить поставленную задачу – на самом деле это чуть сложнее, чем может показаться на первый взгляд. Поэтому пока не будем излишне усложнять нашу <strong>VQC</strong>. Сделаем нашу <strong>VQC</strong> содержащей несколько “слоев” следующего вида:</p>
<ul class="simple">
<li><p>Вращение 1-го кубита <span class="math notranslate nohighlight">\(\hat{Rot}(\theta_1^1, \theta_1^2, \theta_1^3)\)</span></p></li>
<li><p>Вращение 2-го кубита <span class="math notranslate nohighlight">\(\hat{Rot}(\theta_2^1, \theta_2^2, \theta_2^3)\)</span></p></li>
<li><p>“Запутывающий” оператор, который действует на оба кубита сразу – в нашем случае это <span class="math notranslate nohighlight">\(\hat{CZ}\)</span></p></li>
</ul>
<p>Как видно, на каждый “слой” у нас приходится шесть параметров. Реализуем это в коде:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">layer</span><span class="p">(</span><span class="n">theta</span><span class="p">):</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">Rot</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">Rot</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">theta</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">theta</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">wires</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">CZ</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>Здесь у нас вращения каждого из кубитов по сфере Блоха и двухкубитное взаимодействие <span class="math notranslate nohighlight">\(\hat{CZ}\)</span>.</p>
</div>
<div class="section" id="id8">
<h5>Все вместе<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h5>
<p>Теперь давайте объединим все это вместе, добавим пару наблюдаемых и оформим как <code class="docutils literal notranslate"><span class="pre">qml.qnode</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">node</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="n">encoding</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">q_</span> <span class="ow">in</span> <span class="n">q</span><span class="p">:</span>
        <span class="n">layer</span><span class="p">(</span><span class="n">q_</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">qml</span><span class="o">.</span><span class="n">expval</span><span class="p">(</span><span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">@</span> <span class="n">qml</span><span class="o">.</span><span class="n">PauliY</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id9">
<h5>Функция “скоринга”<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h5>
<p>Наша квантовая схема принимает на вход лишь одну точку данных, а у нас их 50. Поэтому удобно сразу написать функцию, которая может работать с массивами <code class="docutils literal notranslate"><span class="pre">NumPy</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">apply_node</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">x_</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
        <span class="n">vqc_output</span> <span class="o">=</span> <span class="n">node</span><span class="p">(</span><span class="n">x_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vqc_output</span> <span class="o">+</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">res</span>
</pre></div>
</div>
</div>
</div>
<p>Может показаться немного запутанно, но так получилось. Дело в том, что параметры схемы это только углы поворотов. Но мы также хотим добавить еще и смещение, поэтому <code class="docutils literal notranslate"><span class="pre">tuple</span></code> параметров у нас содержит два элемента: массив параметров схемы, а также значение смещения. Так как схема у нас принимает на вход лишь одну пару значений <span class="math notranslate nohighlight">\(x_1, x_2\)</span>, то для того, чтобы “проскорить” массив данных мы должны:</p>
<ul class="simple">
<li><p>итерироваться по строкам двумерного массива</p></li>
<li><p>для каждой строки вычислять результат схемы – это функция от <span class="math notranslate nohighlight">\(x_1, x_2, \theta\)</span> – массив параметров <span class="math notranslate nohighlight">\(\theta\)</span> у нас первый элемент <code class="docutils literal notranslate"><span class="pre">tuple</span></code></p></li>
<li><p>добавлять смещение – это второй элемент <code class="docutils literal notranslate"><span class="pre">tuple</span></code></p></li>
<li><p>результат добавлять в итоговый массив</p></li>
</ul>
<p>Именно это и реализовано в коде.</p>
</div>
<div class="section" id="id10">
<h5>Визуализация<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h5>
<p>Давайте инициализируем нашу схему случайными параметрами и посмотрим, как она “сходу” классифицирует данные. Возьмем 4 параметризованных слоя.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="mf">0.0</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">cb</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">apply_node</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/gradients_13_0.png" src="../_images/gradients_13_0.png" />
</div>
</div>
<p>Как видно, результат “не очень” и наша цель – попытаться его улучшить.</p>
</div>
</div>
<div class="section" id="id11">
<h4>Функция потерь<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<p>Прежде чем варьировать параметры схемы, нам для начала необходимо понять, а что именно мы хотим оптимизировать. Для этого нам необходимо выбрать функцию потерь.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Если у Вас трудности с функциями потерь в таком контексте, то рекомендуем вернуться к вводной лекции про классическое машинное обучение, где эта тема раскрыта достаточно подробно.</p>
</div>
<div class="section" id="id12">
<h5>Квадратичное отклонение<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h5>
<p>В качестве функции потерь, которая является дифференцируемой, мы будем использовать наиболее простой вариант – среднеквадратичное отклонения. Это не самый лучший выбор для задач классификации, но зато самый простой. Простой вариант – это именно то, что нам нужно в этой лекции:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cost</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">preds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">apply_node</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">preds</span> <span class="o">-</span> <span class="n">y</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id13">
<h5>Точность классификации<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h5>
<p>В качестве метрики качества среднеквадратичное отклонение вообще не подходит – понять по этой цифре, хорошо или плохо работает модель почти невозможно! Поэтому для оценки модели в целом мы будем использовать точность:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">acc</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">preds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">apply_node</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">p_</span><span class="p">,</span> <span class="n">y_</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">preds</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y_</span> <span class="o">-</span> <span class="n">p_</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">1e-2</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">res</span> <span class="o">/</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="pennylane">
<h4>Решение средствами <code class="docutils literal notranslate"><span class="pre">PennyLane</span></code><a class="headerlink" href="#pennylane" title="Permalink to this headline">¶</a></h4>
<p>Библиотека <code class="docutils literal notranslate"><span class="pre">PennyLane</span></code> может использовать один из нескольких движков для автоматического дифференцирования:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">NumPy</span> <span class="pre">Autograd</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PyTorch</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Tensorflow</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Jax</span></code></p></li>
</ul>
<p>По больше части, на наших занятиях мы будем использовать <code class="docutils literal notranslate"><span class="pre">NumPy</span></code> из-за простоты и привычности. Перед тем как разбираться с тем, как же именно происходит дифференцирование квантовой схемы, давайте посмотрим на весь цикл обучения.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Внимание, процесс обучения на обычном ноутбуке может занять около минуты! Это связано с трудностью симуляции квантового компьютера на классическом.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">opt</span> <span class="o">=</span> <span class="n">qml</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">GradientDescentOptimizer</span><span class="p">(</span><span class="n">stepsize</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
<span class="n">acc_</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">cost_</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">ii</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">75</span><span class="p">):</span>
    <span class="n">batch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,))</span>
    <span class="n">x_batch</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">batch</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">y_batch</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">batch</span><span class="p">]</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="k">lambda</span> <span class="n">q_</span><span class="p">:</span> <span class="n">cost</span><span class="p">(</span><span class="n">q_</span><span class="p">,</span> <span class="n">x_batch</span><span class="p">,</span> <span class="n">y_batch</span><span class="p">),</span> <span class="n">q</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ii</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">acc_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">acc</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
        <span class="n">cost_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>И посмотрим на получившиеся графики точности и функции потерь:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">acc_</span><span class="p">,</span> <span class="s2">&quot;.-&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Accuracy&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">cost_</span><span class="p">,</span> <span class="s2">&quot;.-&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Cost&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/gradients_21_0.png" src="../_images/gradients_21_0.png" />
</div>
</div>
<p>А также на результаты классификации:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">cb</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">apply_node</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/gradients_23_0.png" src="../_images/gradients_23_0.png" />
</div>
</div>
</div>
<div class="section" id="id14">
<h4>А как оно работает?<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h4>
<p>Теперь, когда мы увидели процесс оптимизации квантовой схемы, давайте попробуем подумать, а как оно на самом деле работает?</p>
<div class="section" id="id15">
<h5>Метод конечных отрезков<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h5>
<p>Для начала вспомним то, что является геометрическом (или визуальной) интерпретацией градиента функции. Правильно, градиент в каждой точке – это касательная. А приближенное значение угла наклона любой прямой можно найти, взяв конечные отрезки:</p>
<div class="math notranslate nohighlight">
\[
\frac{df}{dx} \simeq \frac{\Delta f}{\Delta x} = \frac{f(x + \Delta x) - f(x)}{\Delta x}
\]</div>
<p>Давайте попробуем посчитать градиент нашей квантовой схемы. Для этого инициализируем ее заново случайными параметрами, а потом сравним это с тем значением, которое считает <code class="docutils literal notranslate"><span class="pre">Autograd</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="mf">0.0</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">naive_grad</span><span class="p">(</span><span class="n">cost</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">f0</span><span class="p">,</span> <span class="n">delta</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">cost</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">f0</span><span class="p">)</span> <span class="o">/</span> <span class="n">delta</span>

<span class="k">def</span> <span class="nf">grad_i</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">f0</span><span class="p">,</span> <span class="n">cost</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="n">new_params</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">new_params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">0.05</span>

    <span class="k">return</span> <span class="n">naive_grad</span><span class="p">(</span><span class="n">cost</span><span class="p">,</span> <span class="p">(</span><span class="n">new_params</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">f0</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>В качестве эталона возьмем тот градиент, который нам считает <code class="docutils literal notranslate"><span class="pre">Autograd</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">grad</span> <span class="o">=</span> <span class="n">qml</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">cost</span><span class="p">,</span> <span class="n">argnum</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Сравним первые пять значений <code class="docutils literal notranslate"><span class="pre">Autograd</span></code> с нашим наивным алгоритмом, взяв <span class="math notranslate nohighlight">\(\Delta = 0.05\)</span>:</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Осторожно! Так как мы считаем градиенты очень наивно и на всех точках сразу, то следующий блок кода работает долго!</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">autograd</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">f0</span> <span class="o">=</span> <span class="n">cost</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">pretty_print</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">g_i</span> <span class="o">=</span> <span class="n">grad_i</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">f0</span><span class="p">,</span> <span class="n">cost</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="n">pretty_print</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;Naive grad: </span><span class="si">{</span><span class="n">g_i</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="se">\t</span><span class="s2">Autograd result: </span><span class="si">{</span><span class="n">autograd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="n">i</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">pretty_print</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Naive grad: -0.028	Autograd result: -0.029
Naive grad: 0.081	Autograd result: 0.081
Naive grad: 0.025	Autograd result: 0.025
Naive grad: 0.013	Autograd result: 0.008
Naive grad: -0.000	Autograd result: -0.011
Naive grad: 0.009	Autograd result: 0.004
Naive grad: 0.025	Autograd result: 0.025
Naive grad: 0.002	Autograd result: -0.003
Naive grad: -0.068	Autograd result: -0.069
Naive grad: 0.009	Autograd result: 0.004
</pre></div>
</div>
</div>
</div>
<p>Можно заметить, что даже с таким большим значением <span class="math notranslate nohighlight">\(\Delta\)</span> наши оценки получились достаточно близкими к тем, которые получены в <code class="docutils literal notranslate"><span class="pre">Autograd</span></code>. Хотя, конечно, для некоторых значений расхождения заметны и иногда они даже в знаке частной производной.</p>
</div>
<div class="section" id="parameter-shift-rule">
<h5>Parameter-shift rule<a class="headerlink" href="#parameter-shift-rule" title="Permalink to this headline">¶</a></h5>
<p>Более точная оценка может быть получена методом, который называется <strong>Parameter shift</strong>. Он основан на том, что для квантового “черного ящика” <span class="math notranslate nohighlight">\(\hat{U}(\theta)\)</span>, которым является наша схема, частная производная по параметру <span class="math notranslate nohighlight">\(\theta_i\)</span> выражается так:</p>
<div class="math notranslate nohighlight">
\[
\nabla_{\theta_i}\langle \hat{U} \rangle (\mathbf{\theta}) = \frac{1}{2}[\langle \hat{U} \rangle (\mathbf{\theta} + \frac{\pi}{2}\mathbf{e_i}) - \langle \hat{U} \rangle (\mathbf{\theta} - \frac{\pi}{2}\mathbf{e_i})]
\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Более строгую формулировку, а также вывод правила parameter-shift можно посмотреть в продвиной лекции этого блока про производные высших порядков.</p>
</div>
<p>Если по-простому, то оценка частной производной по <span class="math notranslate nohighlight">\(i\)</span>-му параметру может быть получена вычислением сначала ожидаемого значения схемы с параметром <span class="math notranslate nohighlight">\(\theta_i\)</span>, смещенным на <span class="math notranslate nohighlight">\(\frac{\pi}{2}\)</span> в одну сторону, а потом – в другую. Давайте запишем это в коде, но перед этим давайте вспомним, как будет выглядеть производная функции потерь (а именно она нам нужна):</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial L}{\partial \theta_i} = \frac{\partial (\langle \hat{U} \rangle (\theta) - y)^2}{\partial \theta_i} = 2 (\langle \hat{U} \rangle - y) \frac{\partial \langle \hat{U} \rangle}{\partial \theta_i}
\]</div>
<p>Реализуем явно и наивно эту формулу в коде:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">parameter_shift_i</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">cost</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">y_hat</span><span class="p">):</span>
    <span class="n">new_params</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">new_params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="n">forward</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">apply_node</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">new_params</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>

    <span class="n">new_params</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">new_params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="n">backward</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">apply_node</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">new_params</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>

    <span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_hat</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">diff</span> <span class="o">*</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">forward</span> <span class="o">-</span> <span class="n">backward</span><span class="p">)))</span>
</pre></div>
</div>
</div>
</div>
<p>И также проверим на первых 10 точках:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">y_hat</span> <span class="o">=</span> <span class="n">apply_node</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="n">pretty_print</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">g_i</span> <span class="o">=</span> <span class="n">parameter_shift_i</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">cost</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">y_hat</span><span class="p">)</span>
    <span class="n">pretty_print</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;Naive grad: </span><span class="si">{</span><span class="n">g_i</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="se">\t</span><span class="s2">Autograd result: </span><span class="si">{</span><span class="n">autograd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="n">i</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">pretty_print</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Naive grad: -0.029	Autograd result: -0.029
Naive grad: 0.081	Autograd result: 0.081
Naive grad: 0.025	Autograd result: 0.025
Naive grad: 0.008	Autograd result: 0.008
Naive grad: -0.011	Autograd result: -0.011
Naive grad: 0.004	Autograd result: 0.004
Naive grad: 0.025	Autograd result: 0.025
Naive grad: -0.003	Autograd result: -0.003
Naive grad: -0.069	Autograd result: -0.069
Naive grad: 0.004	Autograd result: 0.004
</pre></div>
</div>
</div>
</div>
<p>Как видно, этот результат уже совпадает с тем, что делает “под капотом” <code class="docutils literal notranslate"><span class="pre">PennyLane</span></code> и <code class="docutils literal notranslate"><span class="pre">Autograd</span></code>. На самом деле, правило <strong>parameter-shift</strong> позволяет использовать много интересных хитростей и оптимизаций, но их не получится легко показать без погружения в математические детали метода.</p>
</div>
</div>
<div class="section" id="id16">
<h4>Что мы узнали?<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>Мы попробовали провести полный цикл оптимизации параметров <strong>VQC</strong></p></li>
<li><p>Научились использовать автоматический расчет градиентов в <code class="docutils literal notranslate"><span class="pre">PennyLane</span></code></p></li>
<li><p>Познакомились с двумя способами оценки градиента:</p>
<ul>
<li><p>Метод конечных отрезков</p></li>
<li><p>Parameter-shift rule</p></li>
</ul>
</li>
</ul>
</div>
</div>
<span id="document-book/gradsblock/hogradients"></span><div class="section" id="hogradients">
<span id="id1"></span><h3>Градиенты высших порядков<a class="headerlink" href="#hogradients" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id2">
<h4>План лекции<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>В этой лекции мы посмотрим на ту математику, которая лежит “под капотом” у <em>parameter-shift rule</em>. Мы познакомимся с обобщением <em>parameter shift</em>, а также увидим, как можно оптимизировать этот метод. В конце мы узнаем, как можно посчитать производную второго порядка за минимальное количество обращений к квантовому компьютеру.</p>
<p>Для более детального погружения в вопрос можно сразу рекомендовать статью <span id="id3">[<a class="reference internal" href="book/index.html#id4"><span>MBK21</span></a>]</span>.</p>
</div>
<div class="section" id="id4">
<h4>Важность гейтов вращений<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>Если задуматься, то одним из основных (если не единственных) способов сделать параметризованную квантовую схему является использование гейтов вращений, таких как <span class="math notranslate nohighlight">\(\hat{RX}, \hat{RY}, \hat{RZ}\)</span>. Более формально это можно выразить так, что нас больше всего интересуют операторы вида:</p>
<div class="math notranslate nohighlight">
\[
U(\theta) = e^{-\frac{i}{2}H\theta}
\]</div>
<p>где <span class="math notranslate nohighlight">\(H\)</span> – оператор “вращения”, который удовлетворяет условию <span class="math notranslate nohighlight">\(H^2 = \mathbf{1}\)</span>. Другой возможный вариант записи – представить матрицу <span class="math notranslate nohighlight">\(H\)</span> как линейную комбинацию операторов Паули <span class="math notranslate nohighlight">\(\sigma^x, \sigma^y, \sigma^z\)</span>.</p>
<p>Если представить схему, содержащую множество параметризованных операторов, то итоговая запись имеет вид:</p>
<div class="math notranslate nohighlight">
\[
U_{j...k} = U_j, ..., U_k \ket{\Psi}
\]</div>
</div>
<div class="section" id="id5">
<h4>Производная от измерения<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>Давайте вспомним, как выглядит квантово-классическая схема обучения с <strong>VQC</strong>.</p>
<div class="figure align-default" id="quantclassical">
<a class="reference internal image-reference" href="../_images/diagram.png"><img alt="../_images/diagram.png" src="../_images/diagram.png" style="height: 400px;" /></a>
<p class="caption"><span class="caption-number">Fig. 51 </span><span class="caption-text">Квантово-классическая схема</span><a class="headerlink" href="#quantclassical" title="Permalink to this image">¶</a></p>
</div>
<p>Видно, что мы хотим считать производную не от самой параметризованной схемы <span class="math notranslate nohighlight">\(U_{j...k}\)</span>, а от наблюдаемой. Для тех, кто забыл, что такое <em>наблюдаемая</em>, рекомендуем вернуться к <a class="reference internal" href="book/index.html#qubit"><span class="std std-ref">лекции про кубит</span></a>. Если кратко, то это тот оператор, который мы “измеряем” на нашем квантовом компьютере. Математически производная, которая нам интересна, может быть записана для выбранного параметра <span class="math notranslate nohighlight">\(i\)</span> таким образом:</p>
<div class="math notranslate nohighlight">
\[
G_i = \frac{\partial \bra{U_{j...k}\Psi}\hat{M}\ket{U_{j...k}\Psi}}{\partial \theta_i}
\]</div>
<p>То есть нам важно посчитать производную от результата измерения, так как именно результат измерения у нас будет определять “предсказание” нашей квантовой нейронной сети. Причем нам нужно уметь считать производную от любого параметра <span class="math notranslate nohighlight">\(\theta_i\)</span> в цепочке <span class="math notranslate nohighlight">\(\theta_j, ...\theta_i, ...\theta_k\)</span>.</p>
</div>
<div class="section" id="parameter-shift">
<h4>Parameter-shift для гейтов Паули<a class="headerlink" href="#parameter-shift" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Тут мы для простоты предложим, что <span class="math notranslate nohighlight">\(U_1\)</span> это просто оператор вращения, иначе выкладки станут совсем сложными.</p>
</div>
<p>Тогда сам оператор <span class="math notranslate nohighlight">\(U_i\)</span> может быть также записан так:</p>
<div class="math notranslate nohighlight">
\[
U_i = e^{-\frac{i}{2}P_i\theta_i}
\]</div>
<p>Запишем результат математического ожидания через состояние <span class="math notranslate nohighlight">\(\Psi_i\)</span>, которое пришло на вход <span class="math notranslate nohighlight">\(i\)</span>-го гейта в нашей последовательности:</p>
<div class="math notranslate nohighlight">
\[
\langle M(\theta) \rangle = Tr(M U_{k, ..., 1} \rho_i U_{k, ..., 1}^\dagger)
\]</div>
<p>где <span class="math notranslate nohighlight">\(\rho\)</span> это матрица плотности (<span class="math notranslate nohighlight">\(\ket{\Psi}\bra{\Psi}\)</span>). Подробнее о матрицах плотности можно почитать в ранней продвинутой лекции про смешанные состояния.</p>
<p>Тогда частная производная от математического ожидания по <span class="math notranslate nohighlight">\(i\)</span>-му параметру <span class="math notranslate nohighlight">\(\theta_i\)</span> записывается (подробнее в <span id="id6">[<a class="reference internal" href="book/index.html#id7"><span>MNKF18</span></a>]</span>) через коммутатор исходного состояния <span class="math notranslate nohighlight">\(\rho\)</span>, которое “пришло” на вход гейта <span class="math notranslate nohighlight">\(U_i\)</span> и того оператора Паули <span class="math notranslate nohighlight">\(P_i\)</span>, который мы используем в <span class="math notranslate nohighlight">\(U_i\)</span>:</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial \langle M \rangle}{\partial \theta_i} = -\frac{i}{2}Tr(M U_{k, ..., i}[P_i, U_{i-1, ..., 1}\rho_i U_{i-1, ..., 1}^\dagger]U_{k, ..., i}^\dagger)
\]</div>
<p>Этот коммутатор может быть переписан следующим образом:</p>
<div class="math notranslate nohighlight">
\[
[P_i, \rho] = i[U_i \Bigl( \frac{\pi}{2} \Bigr ) \rho_i U_i^\dagger \Bigl ( \frac{\pi}{2} \Bigr ) - U_i \Bigl( -\frac{\pi}{2} \Bigr ) \rho_i U_i^\dagger \Bigl ( -\frac{\pi}{2} \Bigr )]
\]</div>
<p>Тогда соответствующий градиент <span class="math notranslate nohighlight">\(\frac{\partial}{\partial \theta_i}\)</span> можно записать через смещения на <span class="math notranslate nohighlight">\(\pm\frac{\pi}{2}\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{gathered}
\frac{\partial \langle M \rangle}{\partial \theta_i} = \frac{\langle M_i^+ \rangle - \langle M_i^- \rangle}{2} \\
\langle M_i^{\pm} \rangle = \frac{1}{2} Tr [M U_{k, ..., i+1} U_i(\pm \frac{\pi}{2})\rho_i^` U_i^\dagger (\pm \frac{\pi}{2}) U_{k, ..., i+1}^\dagger] \\
\rho_i^` = U_{j, ..., 1} \rho_i U_{j, ..., 1}^\dagger
\end{gathered}
\end{split}\]</div>
<p>По аналогии с классическими нейронными сетями и <em>backpropagation</em> (для тех, кто забыл это понятие, рекомендуем вернуться к вводным лекциями про классическое машинное обучение) тут явно можно выделить <em>forward</em> проход со смещением <span class="math notranslate nohighlight">\(\theta_i\)</span> на значения <span class="math notranslate nohighlight">\(\frac{\pi}{2}\)</span> и <em>backward</em> со смещением на <span class="math notranslate nohighlight">\(-\frac{\pi}{2}\)</span>.</p>
</div>
<div class="section" id="id7">
<h4>Обобщенный parameter-shift<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<p>Предложенное в <span id="id8">[<a class="reference internal" href="book/index.html#id7"><span>MNKF18</span></a>]</span> выражение может быть на самом деле получено в более общем виде из других соображений. Так, выражение для нашей наблюдаемой <span class="math notranslate nohighlight">\(\langle M \rangle\)</span> может всегда быть представлено <span id="id9">[<a class="reference internal" href="book/index.html#id4"><span>MBK21</span></a>]</span> как сумма вида:</p>
<div class="math notranslate nohighlight">
\[
\bra{U_i(\theta_i)}\hat{M}\ket{U_i(\theta_i)} = \hat{A} + \hat{B}\cos{\theta_i} + \hat{C}\sin{\theta_i}
\]</div>
<p>где <span class="math notranslate nohighlight">\(\hat{A}, \hat{B}, \hat{C}\)</span> – операторы, не зависящие от параметра <span class="math notranslate nohighlight">\(\theta_i\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Действительно, явно выписав выражение для наблюдаемой и вспомнив формулы для косинуса и синуса двойного угла, а также воспользовавшись тем, что <span class="math notranslate nohighlight">\(U(\theta) = e^{-\frac{1}{2}H\theta} = \cos{\frac{\theta}{2}}\mathbf{1} - i\sin{\frac{\theta}{2}}H\)</span>, получаем:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{gathered}
(\cos{\frac{\theta}{2}}\mathbf{1} + i\sin{\frac{\theta}{2}}H)\hat{M}(\cos{\frac{\theta}{2}}\mathbf{1} - i\sin{\frac{\theta}{2}}H) = \\
\cos^2{\frac{\theta}{2}}\hat{M} + i \sin{\frac{\theta}{2}}\cos{\frac{\theta}{2}}H\hat{M} - i \sin {\frac{\theta}{2}}\cos{\frac{\theta}{2}}\hat{M}H + \sin^2{\frac{\theta}{2}}H\hat{M}H = \\
\frac{1}{2} \cos{\theta}\hat{M}+\frac{1}{2}\hat{M}+\frac{i}{2} \sin{\theta}H\hat{M} - \frac{i}{2}\sin{\theta}\hat{M}H + \frac{1}{2}H\hat{M}H - \frac{1}{2}\cos{\theta}H\hat{M}H = \\
\frac{1}{2}(\hat{M} + H\hat{M}H) + \frac{1}{2}(\hat{M} - H\hat{M}H)\cos{\theta} + \frac{i}{2}(H\hat{M} - \hat{M}H)\sin{\theta}
\end{gathered}
\end{split}\]</div>
</div>
<p>Тогда можно воспользоваться правилами тригонометрии, а именно, тем что для любого <span class="math notranslate nohighlight">\(s \neq k\pi, \text{   } k \in {1, 2, ..., }\)</span> справедливо:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{gathered}
\frac{d \cos {\theta}}{d \theta} = \frac{\cos (\theta + s) - \cos (\theta - s)}{2\sin{s}} \\
\frac{d \sin {\theta}}{d \theta} = \frac{\sin (\theta + s) - \sin (\theta - s)}{2\sin{s}} \\
\end{gathered}
\end{split}\]</div>
<p>И подставим это в выражение для <span class="math notranslate nohighlight">\(\frac{\partial \langle M \rangle}{\partial \theta_i}\)</span>:</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial \langle M(\theta_i) \rangle}{\partial \theta_i} = \frac{\langle M(\theta_i + s) \rangle - \langle M(\theta_i - s) \rangle}{2\sin{s}}
\]</div>
<p>Легко заметить, что подстановка сюда <span class="math notranslate nohighlight">\(s = \frac{\pi}{2}\)</span> дает нам классический <em>parameter shift</em>, описанный в <span id="id10">[<a class="reference internal" href="book/index.html#id7"><span>MNKF18</span></a>]</span>.</p>
<p>Наконец, запишем полученное выражение в более удобном виде, который позволит нам более эффективно выписывать производные высших порядков. Для этого введем вектор <span class="math notranslate nohighlight">\(\mathbf{e_i}\)</span> – единичный вектор для <span class="math notranslate nohighlight">\(i\)</span>-го параметра, то есть вектор, где все компоненты кроме <span class="math notranslate nohighlight">\(i\)</span>-й равны нулю, а <span class="math notranslate nohighlight">\(i\)</span>-я равна 1. Тогда наше финальное выражение для обобщенного <em>parameter shift</em> примет следующий вид:</p>
<div class="math notranslate nohighlight">
\[
\boxed{\frac{\partial f(\mathbf{\theta})}{\partial \theta_i} = \frac{f(\mathbf{\theta} + s\mathbf{e_i}) - f(\mathbf{\theta} - s\mathbf{e_i})}{2\sin{s}}}
\]</div>
</div>
<div class="section" id="id11">
<h4>Вторая производная и гессиан<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<p>В классической теории оптимизации, также как и в машинном обучении, очень часто на первый план выходят так называемые методы 2-го порядка. Эти методы похожи на обычный градиентный спуск, но для ускорения сходимости они также используют информацию из матрицы вторых производных, которая называется гессианом. Более подробно про методы 2-го порядка и гессиан можно посмотреть в вводных лекциях курса.</p>
<p>Методы второго порядка требуют больше вызовов, чтобы вычислить гессиан, но взамен они обеспечивают гораздо лучшую сходимость, а также менее склонны “застревать” в локальных минимумах. Это обеспечивает, в итоге, более быстрое обучение. В классических нейронных сетях вычисление гессиана это часто проблема, так как это матрица размерности <span class="math notranslate nohighlight">\(\sim O(N^2)\)</span>, где <span class="math notranslate nohighlight">\(N\)</span> – число весов нейронной сети, и эта матрица получается слишком большой. Но, как мы помним, основная “фича” <strong>VQC</strong> это их экспоненциальная экспрессивность – возможность линейным числом параметров (и гейтов) обеспечить преобразование, эквивалентное экспоненциальному числу весов классической нейронной сети. А значит, для них проблема размерности гессиана не стоит так остро. При этом использование гессиана теоретически позволит в итоге обучить <strong>VQC</strong> за меньшее число вызовов. Именно поэтому методы второго порядка потенциально очень интересны в квантово-классическом обучении. Но для начала нам необходимо разобраться, как именно можно посчитать матрицу вторых производных.</p>
<p>Пользуясь обобщенным правилом <em>parameter shift</em>, можно выписать выражение для второй производной <span id="id12">[<a class="reference internal" href="book/index.html#id4"><span>MBK21</span></a>]</span>:</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial_2 f}{\partial \theta_i \theta_j} = \frac{f(\mathbf{\theta} + s_1\mathbf{e_i} + s_2\mathbf{e_j}) + f(\mathbf{\theta} - s_1\mathbf{e_i} - s_2 \mathbf{e_j}) - f(\mathbf{\theta} + s_1 \mathbf{e_i} - s_2 \mathbf{e_j}) - f(\mathbf{\theta} - s_1 \mathbf{e_i} + s_2 \mathbf{e_j})}{4\sin{s_1}\sin{s_2}}
\]</div>
<p>Взяв <span class="math notranslate nohighlight">\(s_1 = s_2\)</span>, можно упростить это выражение к следующему виду:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{gathered}
\frac{f(\mathbf{\theta} + s\mathbf{a}) + f(\mathbf{\theta} + s\mathbf{b}) - f(\mathbf{\theta} + s\mathbf{c}) - f(\mathbf{\theta} + s\mathbf{d})}{(2\sin{s}) ^2} \\
\mathbf{a} = \mathbf{e_i} + \mathbf{e_j} \\
\mathbf{b} = -\mathbf{e_i} - \mathbf{e_j} \\
\mathbf{c} = \mathbf{e_i} - \mathbf{e_j} \\
\mathbf{d} = -\mathbf{e_i} + \mathbf{e_j}
\end{gathered}
\end{split}\]</div>
<p>Но чаще всего нам необходимо не просто посчитать гессиан, а еще и посчитать градиент, так как в большинстве методов 2-го порядка требуются оба эти значения. В этом случае хочется попробовать подобрать такое значение для <span class="math notranslate nohighlight">\(s_g\)</span> при вычислении вектора градиента, а также такое значение <span class="math notranslate nohighlight">\(s_h\)</span> при вычислении гессиана, чтобы максимально переиспользовать результаты квантовых вызовов и уменьшить их общее количество.</p>
<p>Внимательно взглянув на выражение для 2-х производных, можно заметить, что оптимизация там возможна при расчете диагональных элементов гессиана. Давайте выпишем выражение для диагонального элемента явно:</p>
<div class="math notranslate nohighlight">
\[
\frac{f(\mathbf{\theta} + 2s\mathbf{e_i}) + f(\mathbf{\theta} - 2s\mathbf{e_i}) - 2 f(\mathbf{\theta})}{(2\sin{s})^2}
\]</div>
<p>Можно заметить, что, например, использование <span class="math notranslate nohighlight">\(s = \frac{\pi}{4}\)</span> для гессиана, а также “стандартного” <span class="math notranslate nohighlight">\(s=\frac{\pi}{2}\)</span> для градиента позволит полностью переиспользовать в диагональных элементах гессиана значения, которые мы получили при расчете градиента. А значение <span class="math notranslate nohighlight">\(f(\mathbf{\theta})\)</span> вообще считается один раз для всех диагональных вызовов.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>На самом деле, диагональные элементы гессиана можно использовать и сами по себе, например для квазиньютоновских методов оптимизации, где матрица Гессе аппроксимируется какой-то другой матрицей, чтобы не считать все вторые производные. Например, она может быть аппроксимирована диагональной матрицой, как в работе <span id="id13">[<a class="reference internal" href="book/index.html#id3"><span>And19</span></a>]</span>.</p>
</div>
</div>
<div class="section" id="id14">
<h4>Заключение<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h4>
<p>В этой лекции мы познакомились с классическим <em>parameter shift rule</em>, а также его обобщением. Также мы узнали, как можно посчитать гессиан <strong>VQC</strong>, и даже узнали маленькие хитрости, которые можно применять для уменьшения общего количества вызовов квантовой схемы.</p>
</div>
</div>
</div>
<div class="toctree-wrapper compound">
<span id="document-book/qsvmblock/qsvmintro"></span><div class="section" id="qsvmblock">
<span id="id1"></span><h3>О блоке<a class="headerlink" href="#qsvmblock" title="Permalink to this headline">¶</a></h3>
<p>Этот блок включает в себя:</p>
<ul class="simple">
<li><p>квантово-классический SVM;</p></li>
<li><p>полностью квантовый SVM.</p></li>
</ul>
<p>Продвинутые темы блока дополнительно рассказывают:</p>
<ul class="simple">
<li><p>продвинутую математику SVM;</p></li>
<li><p>интеграцию с алгоритмом Гровера;</p></li>
<li><p>варианты применения HHL-алгоритма.</p></li>
</ul>
</div>
<span id="document-book/qsvmblock/hybridsvm"></span><div class="section" id="svm">
<span id="hybridsvm"></span><h3>Квантово-классический SVM<a class="headerlink" href="#svm" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id1">
<h4>Описание лекции<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>Лекция будет построена следующим образом:</p>
<ul class="simple">
<li><p>Вспомним, что такое классический SVM</p></li>
<li><p>Поговорим о классическом <em>kernel trick</em></p></li>
<li><p>Посмотрим, как можно использовать <strong>VQC</strong> как ядра SVM</p></li>
<li><p>Напишем и применим код обучения смешанного SVM</p></li>
</ul>
</div>
<div class="section" id="id2">
<h4>Классический SVM<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>В данной лекции мы будем много говорить об <strong>SVM</strong> (<em>Support Vector Machine</em>) – алгоритме классического машинного обучения, в основе которого лежит построение оптимальной разделяющей гиперплоскости. Для детального понимания работы этого алгоритма настоятельно рекомендуется вернуться к вводной лекции про SVM.</p>
<p>Давайте кратко вспомним, как устроен этот алгоритм.</p>
<div class="figure align-default" id="classicalsvm">
<a class="reference internal image-reference" href="../_images/Support_vector_machine.jpg"><img alt="../_images/Support_vector_machine.jpg" src="../_images/Support_vector_machine.jpg" style="width: 450px;" /></a>
<p class="caption"><span class="caption-number">Fig. 52 </span><span class="caption-text">Классический SVM</span><a class="headerlink" href="#classicalsvm" title="Permalink to this image">¶</a></p>
</div>
<p>В данном случае алгоритм пытается найти такую разделяющую прямую (в многомерном случае это будет гиперплоскость), чтобы расстояния от этой прямой до точек разных классов были максимальными.</p>
<p>Поскольку обычно нам интересны многомерные пространства, то точки там превращаются в вектора. Также оказывается, что построение такой разделяющей плоскости зависит не от всех точек (векторов), а только от какого-то их подмножества – опорных векторов. Именно поэтому метод и носит название <em>Support Vector Machine</em>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Одним из ключевых авторов алгоритма SVM является Владимир Вапник – советский и американский (с 1991-го года) ученый, который также сделал огромный вклад в теорию классического машинного обучения. Его имя носит один из ключевых теоретических концептов машинного обучения – размерность Вапника-Червоненкиса.</p>
</div>
<div class="section" id="id3">
<h5>Сильные стороны SVM<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h5>
<p>У этого алгоритма есть несколько очень сильных сторон, если сравнивать его, например, с алгоритмом логистической регрессии:</p>
<ul class="simple">
<li><p>В реальности нам интересны не все точки, а лишь те, которые лежат вблизи разделяющей гиперплоскости</p></li>
<li><p>Задача поиска такой прямой может быть сформулирована как задача квадратичного программирования</p></li>
<li><p>Решение задачи квадратичного программирования может быть получено аналитически</p></li>
<li><p>Решение может быть сформулировано с использованием лишь скалярных произведений векторов</p></li>
</ul>
</div>
</div>
<div class="section" id="kernel-trick">
<h4>Kernel-trick<a class="headerlink" href="#kernel-trick" title="Permalink to this headline">¶</a></h4>
<p>Наиболее интересным для нас будет последнее из списка. Ведь в данном случае мы можем искать оптимальные разделяющие гиперплоскости даже в пространстве бесконечной размерности – главное, чтобы в этом пространстве было определено скалярное произведение.</p>
<p>Это используется в расширении SVM, которое называется <strong>ядерный</strong> SVM. В данном случае мы используем <strong>ядро</strong> для вычисления скалярного произведение и строим разделяющую гиперплоскость не в исходном пространстве, где данные, вообще говоря, могут быть неразделимыми, а в новом пространстве. Для этого нам необходимо лишь иметь выражение для скалярного произведения, которое и называется <strong>ядром</strong>. Хорошие примеры ядер для SVM:</p>
<ul class="simple">
<li><p>Полиномиальное ядро</p></li>
<li><p>Радиально-базисная функция (<em>Radial basis function</em>)</p></li>
</ul>
<div class="figure align-default" id="kerneltrick">
<a class="reference internal image-reference" href="../_images/Kernel_trick_idea.svg.png"><img alt="../_images/Kernel_trick_idea.svg.png" src="../_images/Kernel_trick_idea.svg.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">Fig. 53 </span><span class="caption-text">Пример разделимости в новом пространстве</span><a class="headerlink" href="#kerneltrick" title="Permalink to this image">¶</a></p>
</div>
<p>Давайте посмотрим на то, как выглядят популярные ядра.</p>
<div class="section" id="id4">
<h5>Полиномиальное ядро<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h5>
<p>Для степени ядра <span class="math notranslate nohighlight">\(d\)</span> и параметра нормализации <span class="math notranslate nohighlight">\(c\)</span> скалярное произведение двух векторов <span class="math notranslate nohighlight">\(x, y\)</span> определяется так:</p>
<div class="math notranslate nohighlight">
\[
K(x, y) = (x^Ty + c)^d
\]</div>
</div>
<div class="section" id="rbf">
<h5>RBF<a class="headerlink" href="#rbf" title="Permalink to this headline">¶</a></h5>
<p>Для параметра ядра <span class="math notranslate nohighlight">\(\sigma\)</span> формула для скалярного произведения такая:</p>
<div class="math notranslate nohighlight">
\[
K(x, y) = e^{-\frac{||x - y||^2}{\sigma}}
\]</div>
</div>
<div class="section" id="id5">
<h5>Проблемы с ядрами<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h5>
<p>Несмотря на огромный потенциал, у ядерного SVM есть большая проблема – масштабируемость. Вычислять ядра иногда может быть проблематично, из-за этого на действительно больших данных на первое место в последние годы вышли нейронные сети.</p>
<p>А теперь давайте посмотрим, что квантовые компьютеры могут дать классическому SVM!</p>
</div>
</div>
<div class="section" id="vqc">
<h4>VQC как ядерная функция<a class="headerlink" href="#vqc" title="Permalink to this headline">¶</a></h4>
<p>Как мы много говорили в более ранних лекциях, квантовые схемы позволяют нам оперировать в гильбертовых пространствах волновых функций. Эти пространства имеют экспоненциально большую размерность, при этом они параметризуются линейным количеством параметров. А еще в этих пространствах определены скалярные произведения волновых функций, более того, именно результат выборки из скалярного произведения мы чаще всего и получаем как результат измерений!</p>
<p>Давайте попробуем посмотреть, что общего у <strong>VQC</strong> и ядер.</p>
<ul class="simple">
<li><p>Оба оперируют в пространстве большой (или бесконечной размерности)</p></li>
<li><p>И там, и там работа идет в гильбертовом пространстве и определено скалярное произведение</p></li>
<li><p>И там, и там результат вычисляется как скалярное произведение</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Это интересно, что многие специалисты в области <strong>QML</strong> сегодня даже предлагают вместо термина “квантовая нейросеть” использовать термин “квантовое ядро”, так как математически <strong>VQC</strong> гораздо ближе именно к ядрам, чем к слоям современных глубоких сетей. Этой теме у нас даже посвящена одна из более ранних лекций продвинутого уровня, где разбираются доводы из статьи <span id="id6">[<a class="reference internal" href="book/index.html#id12"><span>Sch21</span></a>]</span>.</p>
</div>
<p>Очевидная идея – попробовать как-то воспользоваться квантовой схемой, чтобы реализовать скалярное произведение двух классических векторов. Именно это и сделали авторы работы <span id="id7">[<a class="reference internal" href="book/index.html#id8"><span>HavlivcekCorcolesT+19</span></a>]</span>.</p>
<div class="section" id="id8">
<h5>Преобразование состояния<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h5>
<p>На самом деле, если просто использовать какие-то простые квантовые операции, мы не получим какого-то преимущества над классическим ядерным SVM – ведь все то же самое можно будет сделать и на классическом компьютере.</p>
<p>Чтобы получить реальное преимущество, нам необходимо использовать запутывание и прочие “фишки” квантовых вычислений.</p>
<p>Дальше мы не станем изобретать велосипеды, а вместо этого воспользуемся примерами хороших преобразований из работы <span id="id9">[<a class="reference internal" href="book/index.html#id9"><span>SYG+20</span></a>]</span>. Рассмотрим, что именно там описано.</p>
<div class="section" id="id10">
<h6>Общая схема<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h6>
<p>Для простоты формул мы не будем выписывать обобщенные формулы, а все будем писать для нашего двумерного пространства. Тогда наша схема может быть разделена на несколько частей:</p>
<ul class="simple">
<li><p>гейты Адамара и гейты <span class="math notranslate nohighlight">\(CNOT\)</span></p></li>
<li><p>операции, основанные на элементах входного вектора</p></li>
<li><p>попарные операции над парами элементов вектора</p></li>
</ul>
<p>Мы начинаем с того, что переводим кубиты в состояние суперпозиции, применяя операторы Адамара. Далее мы применяем однокубитные параметризованные операции и снова гейты Адамара. После этого мы применяем связку <span class="math notranslate nohighlight">\(CNOT\)</span> –&gt; параметризованная парой операция –&gt; <span class="math notranslate nohighlight">\(CNOT\)</span>.</p>
</div>
<div class="section" id="id11">
<h6>Выбор операции<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h6>
<p>Следуя идее упомянутой статьи, в качестве что одно-элементной, что двух-элементной операции мы будем использовать гейт <span class="math notranslate nohighlight">\(U_1\)</span>. Разница будет лишь в том, что мы передаем на вход в качестве параметра.</p>
</div>
<div class="section" id="feature-function">
<h6>Feature function<a class="headerlink" href="#feature-function" title="Permalink to this headline">¶</a></h6>
<p>В качестве параметров на входе гейта <span class="math notranslate nohighlight">\(U_1\)</span>, как мы уже говорили, выступают один или два элемента вектора <span class="math notranslate nohighlight">\(x\)</span>. Строго это можно записать как функцию такого вида:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\phi(x_1, x_2) = \begin{cases}
\phi(x),\text{    }x_1 = x_2 \\
\phi(x_1, x_2),\text{    }x_1 \neq x_2
\end{cases}
\end{split}\]</div>
<p>Мы будем называть ее <em>feature function</em>. В некотором смысле можно сказать, что именно эта функция определяет тип ядра по аналогии с классическим SVM. В работе <span id="id12">[<a class="reference internal" href="book/index.html#id9"><span>SYG+20</span></a>]</span> описано много разных вариантов таких <em>feature function</em>, мы будем использовать следующую:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{gathered}
\phi(x) = x \\
\phi(x_1, x_2) = \pi \cos{x_1} \cos{x_2}
\end{gathered}
\end{split}\]</div>
</div>
<div class="section" id="id13">
<h6>Скалярное произведение<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h6>
<p>Все что мы описали выше, обозначим как квантовую схему <span class="math notranslate nohighlight">\(U(x)\)</span>. Она преобразует нам вектор классических данных <span class="math notranslate nohighlight">\(x\)</span> в квантовое состояние <span class="math notranslate nohighlight">\(\ket{\Psi}\)</span>. Но нам то нужно получить скалярное произведение <span class="math notranslate nohighlight">\(\braket{U(x_1)|U(x_2)}\)</span>! Выглядит сложно, но на самом деле существует эффективный способ получить эту величину без необходимости восстанавливать весь вектор состояния. Можно показать, что величина <span class="math notranslate nohighlight">\(\braket{U(x_1)|U(x_2)}\)</span> равна вероятности нулевой битовой строки (<span class="math notranslate nohighlight">\(\ket{0, 0, ...., 0}\)</span>) при измерении другой схемы: <span class="math notranslate nohighlight">\(U(x_1)U(x_2)^\dagger\)</span>.</p>
<p>Все это может казаться сложным и запутанным, но должно стать гораздо понятнее, когда мы посмотрим на пример реализации от начала и до конца.</p>
</div>
</div>
</div>
<div class="section" id="id14">
<h4>Пример реализации<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h4>
<div class="section" id="id15">
<h5>Схема<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h5>
<p>Для начала необходимые импорты.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pennylane</span> <span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">pennylane</span> <span class="k">as</span> <span class="nn">qml</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="o">%</span><span class="k">config</span> InlineBackend.figure_format = &#39;retina&#39;
<span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">make_moons</span>
</pre></div>
</div>
</div>
</div>
<p>Помимо всех привычных, нам еще потребуется классический SVM из <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>
</pre></div>
</div>
</div>
</div>
<p>Мы будем работать с уже привычным нам набором “Tow Moons”. Только в этом случае мы будем использовать чуть-чуть другую нормализацию – для нашего ядра элементы вектора <strong>x</strong> должны быть в интервале <span class="math notranslate nohighlight">\([-1, 1]\)</span>. Сразу переведем наши данные в этот диапазон:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_moons</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Переводит значения в интервал от -1 до 1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">min_</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    <span class="n">max_</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">min_</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">max_</span> <span class="o">-</span> <span class="n">min_</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

<span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
<span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">cb</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/hybridsvm_5_0.png" src="../_images/hybridsvm_5_0.png" />
</div>
</div>
<p>И привычное нам объявление устройства.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dev</span> <span class="o">=</span> <span class="n">qml</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Теперь давайте для начала реализуем наше преобразование над одним из векторов (<span class="math notranslate nohighlight">\(U(x)\)</span>). Поскольку далее нам потребуется еще и <span class="math notranslate nohighlight">\(U(x)^\dagger\)</span>, то мы сразу воспользуемся декоратором <code class="docutils literal notranslate"><span class="pre">&#64;qml.template</span></code>, который позволит нам автоматически получить обратную схему.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@qml</span><span class="o">.</span><span class="n">template</span>
<span class="k">def</span> <span class="nf">var_layer</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">qml</span><span class="o">.</span><span class="n">U1</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">U1</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">wires</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">qml</span><span class="o">.</span><span class="n">CNOT</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">U1</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">wires</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">CNOT</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>А теперь реализуем <span class="math notranslate nohighlight">\(\braket{U(x_1)|U(x_2)} = \bra{U(x_1)U(x_2)^\dagger \Psi} M_0 \ket{U(x_1)U(x_2)^\dagger \Psi}\)</span>. Тут <span class="math notranslate nohighlight">\(M_0\)</span> – это проектор на один из собственных векторов системы кубитов, а именно на “нулевой”: <span class="math notranslate nohighlight">\(M_0 = \ket{0, ..., 0}\bra{0, ..., 0}\)</span>. Проще говоря, мы реализуем схему, которая нам дает вероятности каждой из битовых строк (а дальше мы просто возьмем первую, она и отвечает строке <span class="math notranslate nohighlight">\(0,...0\)</span>):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">dot_prod</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
    <span class="n">var_layer</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">var_layer</span><span class="p">(</span><span class="n">x2</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">qml</span><span class="o">.</span><span class="n">probs</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>Ну и сразу вспомогательную функцию, которая нам считает то, что нам было нужно:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">q_dot_prod</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">dot_prod</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Для самопроверки убедимся в том, что наше “скалярное произведение” симметрично:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">q_dot_prod</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">q_dot_prod</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<p>И сразу посмотрим на то, как выглядит наша схема:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">dot_prod</span><span class="o">.</span><span class="n">draw</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span> 0: ──H──Rϕ(-0.977)──H──╭C────────────╭C──╭C────────────────╭C────H⁻¹──Rϕ(0.311)⁻¹───H⁻¹──╭┤ Probs 
 1: ──H──Rϕ(0.0118)──H──╰X──Rϕ(1.76)──╰X──╰X⁻¹──Rϕ(2.99)⁻¹──╰X⁻¹──H⁻¹──Rϕ(0.0118)⁻¹──H⁻¹──╰┤ Probs 
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id16">
<h5>Гибридный SVM<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h5>
<p>Мы не будем сами с нуля писать решение задачи квадратичного программирования. Мы воспользуемся готовой рутиной из <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code>. Используемая там реализация позволяет вместо ядерной функции передать сразу матрицу Грама (<a class="reference external" href="https://en.wikipedia.org/wiki/Gram_matrix">Gram matrix</a>). На самом деле это просто матрица всех попарных скалярных произведений наших векторов. Вычислим ее, сразу воспользовавшись тем, что <span class="math notranslate nohighlight">\(\braket{U(x)|U(x)} = 1\)</span> и <span class="math notranslate nohighlight">\(\braket{U(x_1)|U(x_2)} = \braket{U(x_2)|U(x_1)}\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gram_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
            <span class="n">gram_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">q_dot_prod</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="n">gram_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
            <span class="n">gram_mat</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
</pre></div>
</div>
</div>
</div>
<p>Обучим нашу модель:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s2">&quot;precomputed&quot;</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">gram_mat</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>SVC(kernel=&#39;precomputed&#39;)
</pre></div>
</div>
</div>
</div>
<p>Посчитаем предсказания и посмотрим на результат:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">preds</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">gram_mat</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">cb</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">preds</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/hybridsvm_23_0.png" src="../_images/hybridsvm_23_0.png" />
</div>
</div>
<p>Результат выглядит неплохо!</p>
</div>
</div>
<div class="section" id="id17">
<h4>Заключение<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h4>
<p>Расчет полной матрицы скалярных произведений дает нам сложность <span class="math notranslate nohighlight">\(O(N^2)\)</span> вызовов. Но основной потенциал гибридного SVM в том, что задачу квадратичной оптимизации на самом деле можно тоже решать на квантовом компьютере, используя алгоритм Гровера (про него рассказано в ранних факультативных лекциях), причем за сложность всего <span class="math notranslate nohighlight">\(O(N)\)</span> и без расчета полной матрицы Грама!</p>
<p>Многие считают, что NISQ квантовые компьютеры могут стать для SVM чем-то типа видеокарт для нейронных сетей и вернуть этот алгоритм на пьедестал лучших алгоритмов машинного обучения!</p>
</div>
</div>
</div>
<div class="toctree-wrapper compound">
<span id="document-book/problemsblock/quantchembasic"></span><div class="section" id="quantchembasic">
<span id="id1"></span><h3>Квантовая химия. Введение.<a class="headerlink" href="#quantchembasic" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id2">
<h4>Описание лекции<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>Из этой лекции мы узнаем:</p>
<ul class="simple">
<li><p>что такое квантовая химия, что с ее помощью можно сделать, а что – нельзя;</p></li>
<li><p>как устроена самая простая теория, описывающая квантовую физику атома</p></li>
<li><p>какие у этой теории есть ограничения</p></li>
</ul>
</div>
<div class="section" id="id3">
<h4>Введение<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>В предыдущих лекциях мы говорили о применении квантовой механики для вычислений и обработки информации. Однако исторически квантовая теория развивалась в первую очередь из-за того, что классическая физика не могла объяснить некоторые наблюдаемые эффекты, такие как дискретный спектр излучения атомов, фотоэффект в металлах, интерференцию частиц на дифракционных щелях.</p>
<p>Считается, что квантовая механика дает полное и точное описание состояния и эволюции любой системы при нерелятивистских условиях — по крайней мере, на сегодняшний день этому нет экспериментальных или теоретических противоречий. Это значит, что в теории возможно для любой системы частиц записать уравнения Шредингера, решить их и предсказать, как себя поведет система. Однако на практике оказывается, что в реальных задачах вроде моделирования лекарств и материалов просто “взять и посчитать” – задача весьма сложная, а иногда – неразрешимая.</p>
<p>Проблемами применения квантовой механики к химии и материаловедению занимается квантовая химия. Она делает это уже около 100 лет, по теме написаны толстые книжки с многоэтажными формулами, так что в лекции будут даны основы и простые примеры без полного вывода. Для желающих в конце приведены ссылки для углубленного изучения.</p>
<p>Предполагается, что читатель знаком с уравнением Шредингера и основными операторами (импульса, эволюции), бра-кет нотацией, а также помнит основы физики и химии на уровне старших классов школы.</p>
</div>
<div class="section" id="id4">
<h4>Атом водорода<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<div class="section" id="id5">
<h5>В чем проблема?<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h5>
<p>Спектр излучения и поглощения атомов — то есть на какой длине волны происходит поглощение и излучение света веществом — был одной из первых “нерешаемых” проблем, приведших в итоге к появлению квантовой физики. Для <a class="reference external" href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%81%D1%82%D1%8B%D0%B5_%D0%B2%D0%B5%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%B0">простых веществ</a> в газообразной форме спектр является дискретным, и для атома водорода спектры поглощения и излучения в видимом диапазоне выглядят так:</p>
<div class="figure align-default" id="hydrogenspectrum">
<img alt="../_images/HydrogenSpectrum.png" src="../_images/HydrogenSpectrum.png" />
<p class="caption"><span class="caption-number">Fig. 54 </span><span class="caption-text">Спектр поглощения и излучения водорода в видимом диапазоне</span><a class="headerlink" href="#hydrogenspectrum" title="Permalink to this image">¶</a></p>
</div>
<p>В конце 19 века было уже известно, что атом водорода состоит из двух заряженных частиц – протона и электрона, но из классической физики следовало, что спектр излучения такой системы должен быть непрерывным, что никак не стыковалось с наблюдениями (дискретные линии на графике). Попробуем вслед за исследователями квантовой физики начала 20 века разобраться с этой проблемой.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Про имена. “Квантовая физика” и “квантовая механика” – связанные понятия, но не тождественные.</p>
<p>Квантовая механика – это теория (а точнее, множество теорий с различающимися терминологиями), в основе которой лежит аксиоматика о том, что сущности описываются волновыми функциями, что они эволюционируют и, что зная эти функции, можно посчитать физические величины — например, энергию.</p>
<p>Квантовая физика – это область физики, исследующая квантовые эффекты, при этом она местами может не иметь строгого обоснования – лишь бы предсказания работали.</p>
<p>С квановой химией тоже есть некоторая путаница – в двадцатом веке под ней имели в виду аналитические и численные методы решения задач квантовой механики применительно к молекулам и кристаллам. Но с развитием квантовых компьютеров эту область стали иногда называть вычислительной химией, а квантовой химией – применение квантовых компьютеров к этой области.</p>
</div>
</div>
<div class="section" id="id6">
<h5>Быстрое и неправильное решение<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h5>
<p>Первой теорией в квантовой физике была <a class="reference external" href="https://ru.wikipedia.org/wiki/%D0%91%D0%BE%D1%80%D0%BE%D0%B2%D1%81%D0%BA%D0%B0%D1%8F_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_%D0%B0%D1%82%D0%BE%D0%BC%D0%B0">“Боровская теория”</a> – почти классическая теория, основанная на постулатах, разрешающих противоречия классической физики с экспериментами на уровне “хардкода”. Главный постулат заключается в том, что импульс может принимать только определенные дискретные значения (кванты), а не произвольные:</p>
<p><span class="math notranslate nohighlight">\( p \cdot 2\pi r = n \cdot h \)</span></p>
<p><span class="math notranslate nohighlight">\( p = \frac{n \cdot \hbar}{ r} \)</span></p>
<p>где p – импульс, r – радиус орбиты электрона, h – константа Планка, n – любое целое число.
Если применить этот постулат к атому водорода – паре из протона и электрона, то получится, что:</p>
<ul class="simple">
<li><p>электрон вокруг протона “летает по орбите”;</p></li>
<li><p>спектр (уровни энергии электрона) – дискретный.</p></li>
</ul>
<p>Можно показать это следующим образом.</p>
<p>Во-первых, поскольку частиц две и протон имеет массу много больше массы электрона, можно перейти в почти инерциальную систему отсчета протона, где он неподвижен, и решить задачу только для электрона.</p>
<p>Из классической механики берем <a class="reference external" href="https://ru.wikipedia.org/wiki/%D0%92%D0%B8%D1%80%D0%B8%D0%B0%D0%BB">теорему о вириале</a> (“для стабильной системы из двух частиц, связанных потенциальными силами, в среднем кинетическая энергия равна половине потенциальной”):</p>
<p><span class="math notranslate nohighlight">\( E_{k} = -E_{p} / 2 \)</span></p>
<p><span class="math notranslate nohighlight">\( E = E_{k} + E_{p} = E_{p} / 2 \)</span></p>
<p>Записываем кинетическую энергию и потенциал Кулона для электрона в поле протона (в СИ):</p>
<p><span class="math notranslate nohighlight">\( \frac{p^2}{2m} = k \frac{e^2}{2 R} \)</span>, где <span class="math notranslate nohighlight">\(k\)</span> – постоянная из закона Кулона</p>
<p>Используем постулат Бора и выразим “радиус” орбиты:</p>
<p><span class="math notranslate nohighlight">\( \frac{n^2 \hbar^2}{2 m R^2} = k \frac{e^2}{2R} \)</span></p>
<p><span class="math notranslate nohighlight">\( R = \frac{n^2 \hbar^2}{k m e ^2}\)</span></p>
<p>Находим полную энергию:</p>
<p><span class="math notranslate nohighlight">\( E = E_{p} / 2 = - \frac{k e^2}{ 2 R} = -\frac{k^2}{n^2} \frac{me^4}{2 \hbar^2} \)</span></p>
<p>Уровни энергии пропорциональны <span class="math notranslate nohighlight">\( \frac{1}{n^2}\)</span> и именно <a class="reference external" href="https://en.wikipedia.org/wiki/Hydrogen_spectral_series">такая зависимость</a> наблюдается в эксперименте.</p>
<p>Посчитаем минимальную энергию (n = 1):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">constants</span> <span class="k">as</span> <span class="n">consts</span>

<span class="n">k</span> <span class="o">=</span> <span class="p">(</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">consts</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">consts</span><span class="o">.</span><span class="n">epsilon_0</span><span class="p">))</span> <span class="c1"># постоянная кулона</span>

<span class="n">E1</span> <span class="o">=</span> <span class="o">-</span> <span class="n">k</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">consts</span><span class="o">.</span><span class="n">m_e</span> <span class="o">*</span> <span class="n">consts</span><span class="o">.</span><span class="n">e</span><span class="o">**</span><span class="mi">4</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">consts</span><span class="o">.</span><span class="n">hbar</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># энергия в Джоулях</span>

<span class="n">E1_ev</span> <span class="o">=</span> <span class="n">E1</span> <span class="o">/</span> <span class="n">consts</span><span class="o">.</span><span class="n">e</span> <span class="c1"># энергия в электрон-вольтах</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Hydrogen Bohr ground state energy: </span><span class="si">{</span><span class="n">E1_ev</span><span class="si">}</span><span class="s2"> eV&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Hydrogen Bohr ground state energy: -13.605693122885837 eV
</pre></div>
</div>
</div>
</div>
<p>Получившийся ответ 13.6 eV в точности совпадает с экспериментальным значением энергии ионизации водорода.</p>
<p>Итого: постулировав несколько очень удачных гипотез (главная – что импульс квантуется, то есть принимает только дискретные значения), удалось разрешить фундаментальную нестыковку между классической теорией и экспериментом: энергия стала дискретной, линии спектра стали обратно пропорциональны  <span class="math notranslate nohighlight">\(n\)</span>, значения энергии ионизации совпадают с реальными измерениями.</p>
<p>Казалось бы, замечательно, проблема решена! Однако теория Бора имеет ряд проблем. Главная из них заключается в том, что теория работает только для “водородоподобных” атомов, то есть состоящих из ядра и одного электрона на внешней оболочке. Уже для атома гелия спектр не согласуется с боровской теорией.</p>
<p>Кроме того, с точки зрения науки теория Бора – это в некоторым смысле “читерство”. Выбрав удачные постулаты и подставив их формулы в классическую физику, мы получили правильный результат. Но будь постулаты другими, результат получился бы тоже другой, так что фактически постулаты Бора – это гениальная догадка, позволившая угадать правильные результаты для некоторых систем.</p>
</div>
</div>
</div>
<span id="document-book/problemsblock/quantchemadvancedscf"></span><div class="section" id="quantchemadvancedscf">
<span id="id1"></span><h3>Квантовая химия. Теория самосогласованного поля.<a class="headerlink" href="#quantchemadvancedscf" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id2">
<h4>Описание лекции<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>Из этой лекции мы узнаем:</p>
<ul class="simple">
<li><p>как с помощью квантовой химии предсказать спектр атома водорода “из первых принципов”;</p></li>
<li><p>как посчитать энергию атома с помощью Python;</p></li>
<li><p>какие бывают волновые функции электронов и как их вычислять методом Self-Consistent Field;</p></li>
<li><p>как посчитать энергию спирта.</p></li>
</ul>
<div class="section" id="id3">
<h5>Введение<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h5>
<p>Боровская теория оказалось недостаточной для описания таких сложных систем, как молекулы или не-водородоподобные атомы. В этой лекции мы разберемся с теорией самосогласованного поля – это один из первых вычислительных методов квантовой химии, пригодный на практике для моделирования разных систем (атомов, молекул, кристаллов).</p>
<p>Несмотря на то, что основа метода была разработана чуть ли не сто лет назад, он активно используется и сегодня, особенно с различными модификациями и дополнениями.</p>
</div>
<div class="section" id="id4">
<h5>Что мы ищем?<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h5>
<p>С точки зрения квантовой химии, чаще всего мы хотим для произвольного набора частиц (атомов для молекулы или кристалла, протонов и электронов для атома) с известным потенциалом взаимодействия предсказывать стационарное состояние, т.е. находить стационарные волновые функции всех частиц системы. Квантовая механика постулирует, что для любой наблюдаемой физической величины существует оператор, которым мы можем подействовать на волновую функцию и получить измеренное значение этой величины.</p>
<p>Например, если мы знаем волновые функции электронов и ядер в кристалле – можно предсказать теплопроводность кристалла. Или электрическую проводимость, или еще что-нибудь – поэтому основной задачей квантовой химии является поиск волновых функций-решений уравнения Шредингера для системы частиц.</p>
</div>
<div class="section" id="id5">
<h5>Долгое и правильное решение, часть 1<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h5>
<p>Начнем с атома водорода и определения его уровней энергии – их можно сравнить с экспериментальными данными, а также результатами Боровской теории. Квантовая механика позволяет решить эту задачу, исходя только из “первых принципов”, то есть аксиоматики квантовой механики. При этом после некоторых усилий решения успешно обобщаются с атома водорода на любой другой.</p>
<p>Давайте опишем атом водорода — систему из электрона и протона — на языке квантовой механики, то есть в виде уравнения Шредингера, и посмотрим, что получится.</p>
<p>Электрон находится в потенциале протона, и его волновая функция должна зависеть от расстояния до протона.</p>
<p>Уравнение Шредингера для электрона будет следующим:</p>
<p><span class="math notranslate nohighlight">\( \dot{\imath} \hbar \frac{d}{dt} {\ket{\Psi(t, \vec{r})}} = (\frac{ \hat{p}^{2} }{2m} + \hat{V}(\vec{r})) {\ket{\Psi (t, \vec{r})}} \)</span></p>
<p>Мы ищем решение, в котором электрон остается в атоме, то есть решаем стационарное уравнение, в котором <span class="math notranslate nohighlight">\(\ket{\Psi}\)</span> не зависит от времени.
Тогда оператор эволюции (в левой части уравнения Шредингера) при применении к <span class="math notranslate nohighlight">\(\ket{\Psi}\)</span> должен вернуть нам тот же вектор <span class="math notranslate nohighlight">\(\ket{\Psi}\)</span>, умноженный на E, где E – это энергия частицы.</p>
<p>С точки зрения математики искомая волновая функция является собственным вектором оператора эволюции, а энергия – собственным значением.</p>
<p>С точки зрения объяснения “на пальцах” оператор эволюции при применении к волновой функции должен вернуть нам новую (эволюционировавшую/изменившуюся во времени) волновую функцию. Если мы ищем стационарную — не меняющуюся во времени — волновую функцию, то при применении к ней оператора эволюции она не должна изменяться, иначе будет уже не стационарной.</p>
<p><span class="math notranslate nohighlight">\(
    \dot{\imath} \hbar \frac{d}{dt} {\ket{\Psi(t, r)}}
    \equiv
    \dot{\imath} \hbar \frac{d}{dt} {\ket{\Psi(r)}}
    \equiv
    E { \ket{\Psi(r)} }
\)</span></p>
<p>Оператор импульса раскрывается через градиент так:
<span class="math notranslate nohighlight">\( \hat{p} =  \dot{\imath} \hbar \nabla \)</span></p>
<p>Потенциал взаимодействия двух частиц с противоположными единичными зарядами раскрывается так:
<span class="math notranslate nohighlight">\( \hat{V}(r) = -\frac{e^2}{r} \)</span></p>
<p>Итого имеем:</p>
<p><span class="math notranslate nohighlight">\((-\frac{\hbar^2}{2m}\nabla^2  - \frac{e^2}{r} ){\ket{\Psi(r)}} = E {\ket{\Psi(r)}}\)</span></p>
<p>Прежде чем погружаться глубже в решение этого уравнения, нам надо разобраться с квантовыми числами.</p>
</div>
<div class="section" id="id6">
<h5>Про квантовые числа<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h5>
<p>Теория Бора базируется на идее квантования импульса, и ее следствием является возникшее в формуле энергии число <span class="math notranslate nohighlight">\(n\)</span>. Каждое число <span class="math notranslate nohighlight">\(n\)</span> соответствует определенному состоянию, в котором может находиться электрон и эти состояния отличаются энергией.</p>
<p>Идея о том, что электрон может находиться в одном состоянии из некоторого конечного набора вариантов, характеризуемого дискретными (квантовыми) числами, оказалась правильной. В в дальнейшем она получила развитие в квантовой механике.</p>
<p>Число <span class="math notranslate nohighlight">\(n\)</span> называется главным <a class="reference external" href="https://en.wikipedia.org/wiki/Quantum_number">квантовым числом</a>, оно определяет энергетический уровень электрона.</p>
<p>Из анализа свойств операторов гамильтониана и момента импульса в квантовой механике выводятся еще три квантовых числа:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\ell\)</span> – орбитальное квантовое число, <span class="math notranslate nohighlight">\(0\leq \ell \leq n-1\)</span>;</p></li>
<li><p><span class="math notranslate nohighlight">\(m\)</span> – магнитное квантовое число,  <span class="math notranslate nohighlight">\(-\ell&lt;=m&lt;=\ell\)</span>;</p></li>
<li><p><span class="math notranslate nohighlight">\(s\)</span> – спиновое квантовое число, <span class="math notranslate nohighlight">\(s = 0|1\)</span> (для атома водорода оно не играет роли, так как электрон только один).</p></li>
</ul>
<p>В химии они <a class="reference external" href="https://en.wikipedia.org/wiki/Electron_configuration">используются</a> в другой форме записи для описания орбиталей электронов в атоме.</p>
<p>Эти числа нам скоро понадобятся, чтобы описывать электрон в атоме.</p>
<p>Любая функция <span class="math notranslate nohighlight">\(\ket{\Psi}\)</span>, для которой уравнение выше верно, описывает электрон, который стабильно находится где-то около ядра и не покидает его, то есть образует с ним атом. При этом функций-решений у уравнения на самом деле много, что физически соответствует тому, что электрон может находиться на разных орбиталях. Каждая орбиталь характеризуется квантовыми числами – <span class="math notranslate nohighlight">\(n\)</span>, <span class="math notranslate nohighlight">\(\ell\)</span>, <span class="math notranslate nohighlight">\(m\)</span> и <span class="math notranslate nohighlight">\(s\)</span>, и обозначается как <span class="math notranslate nohighlight">\(\ket{\Psi_{n\ell m}} \)</span>. <span class="math notranslate nohighlight">\(\ket{\Psi}\)</span> (орбиталь) с минимальной энергией E соответствует основному состоянию (ground state) – она описывает невозбужденный электрон. У водорода только один электрон, поэтому единственная <span class="math notranslate nohighlight">\(\ket{\Psi}\)</span> с минимальной энергией соответствует невозбужденому атому водорода.</p>
<p>В целом основная задача квантовой химии – найти ground state произвольной системы частиц, так как это описывает “обычное” состояние системы, которое встречается чаще всего в реальности. Но если электрону в основном состоянии придать энергии, например, попасть в него другой частицей, то он может перейти на другую орбиталь, при этом оставшись частью атома. Со временем возбужденные атомы рано или поздно переходят в основное состояния, выбрасывая лишнюю энергию в виде фотона, что и дает спектр излучения атома.</p>
<p>Итого:</p>
<p><span class="math notranslate nohighlight">\(\ket{\Psi_{n\ell m}(\vec{r})} \)</span> – это функция, соответствующая какой-то стабильной “траектории” (распределению плотности вероятности) электрона вокруг ядра, она является решением уравнения Шредингера, то есть собственной функцией гамильтониана. Соответствующее ей собственное число – энергия электрона на этой орбитали. Для всех волновых функций с одним n энергия одинакова.</p>
<p>Если электрон описывается такой волновой функцией, то он часть атома, и если какой-либо электрон – часть атома, то он описывается такой волновой функцией. Электрон может переходить между этими волновыми функциями, получая и отдавая энергию, оставаясь при этом частью атома.</p>
<p>Физически электрон водорода обычно в <span class="math notranslate nohighlight">\(\ket{\Psi_{100}}\)</span>, так как такое распределение соответствует минимальной энергии.</p>
</div>
<div class="section" id="id7">
<h5>Долгое и правильное решение, часть 2<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h5>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>А зачем нам вообще сдался спектр и энергии? Вслед за физиками двадцатого века нам приходится продираться через дебри уравнений, абстракций и формул. Дело это непростое и может возникнуть резонный вопрос – а зачем оно все надо?</p>
<p>Помимо фундаментальной ценности в виде лучшего понимания устройства мира, объясняющая спектр теория дает крутую возможность: по измеренному спектру понять, что за вещество перед нами и какие процессы в нем протекают. Например, изучение спектров – один из немногих способов узнать что-то про процессы в звездах или биологических клетках. Для совсем практиков: спектроскопия также используется для детекции взрывчатых и наркотических веществ в малых дозах, а полевые транзисторы (основа большинства современных вычислительные устройства) работают на основе туннельного эффекта – квантового явления. Так что можно сказать, что квантовая механика используется сплошь и рядом!</p>
</div>
<p>Если мы перейдем в уравнении Х в сферические координаты со следующей параметризацией <span class="math notranslate nohighlight">\(\ket{\Psi(\vec{r})} = \frac{\chi(r)}{r} Y(\theta, \phi)\)</span> и воспользуемся несколькими волшебными выводами квантмеха <span id="id8">[<a class="reference internal" href="book/index.html#id6"><span>89</span></a>]</span>, то получим:</p>
<p><span class="math notranslate nohighlight">\(
-\frac{{\hbar}^2}{2 m} \frac{d^2 \chi}{d r^2} +
(-\frac{e^2}{r} + \frac{\hbar^2 \ell (\ell + 1)}{2mr^2} -E) \chi(r) = 0
\)</span></p>
<p>Все константы (массы, заряда, импульса, энергии) можно убрать, если перейти в кулоновские единицы измерений, где они приняты за единицу (то есть 1 единица заряда = заряд электрона, 1 единица массы = масса электрона).</p>
<p><span class="math notranslate nohighlight">\(
-\frac{\chi''(r)}{2} +
(\frac{\ell(\ell+1)}{2r^2} -\frac{1}{r})\chi(r)
= 0
\)</span></p>
<p>Опустим несколько страниц выкладок <span id="id9">[<a class="reference internal" href="book/index.html#id5"><span>15</span></a>]</span>, учтем граничные условия и получим следующее решение:</p>
<p><span class="math notranslate nohighlight">\(
 R_{n\ell}(r) = r^\ell \cdot e^{-r/n} \cdot \sum_{k=0}^{n -\ell -1} \frac{(-2r/n)^k}{ (2\ell + 2 +k)! (n-\ell-k-1)! k!} \cdot C
\)</span></p>
<p><span class="math notranslate nohighlight">\(
\ket{\Psi(r, \theta, \phi)} = R_{n\ell}(r) Y_{\ell m} (\theta, \phi)
\)</span>,</p>
<p>где <span class="math notranslate nohighlight">\(Y_{\ell m}(\theta, \phi)\)</span> – <a class="reference external" href="https://en.wikipedia.org/wiki/Spherical_harmonics">сферические функции</a>.</p>
<p>Если подставить это решение в уравнение Шредингера и найти энергию, то получим:</p>
<p><span class="math notranslate nohighlight">\(
E_{n} = -\frac{1}{n^2} \frac{me^4}{2\hbar^2}
\)</span></p>
<p>То есть получим ту же формулу, что и в теории Бора, и тот же численный результат – 13.6 eV.</p>
<p>Здесь начинает проступать основная проблема квантовой химии – математическая и вычислительная сложность. Пока что проблема только концепутальная (сложно разобраться в формулах и уравнениях), но при росте числа частиц в системе даже отличное владение матаппаратом окажется недостаточным.</p>
</div>
<div class="section" id="id10">
<h5>От теории к практике<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h5>
<p>Вернемся из начала двадцатого века обратно в день сегодняшний. Сто лет назад неберущиеся аналитически интегралы и замороченные дифференциальные уравнения были почти непреодолимыми препятствиями, поэтому поначалу теория квантовой химии развивалась в сторону более хитрых приближений и упрощений, позволяющих решить эти уравнения аналитически.</p>
<p>Сегодня реальные научные задачи решаются численно – и для этого написано множество высокопроизводительных пакетов, позволяющих на основе входных данных и ограничений вычислить определенным методом желаемые характеристики.</p>
<p>Как и в задачах машинного обучения, в первом приближении достаточно подготовить данные, скормить их волшебному комбайну-вычислителю и забрать ответ, но без понимания о происходящем под капотом есть шансы получить что-то неправильное.</p>
<p>В этой лекции мы воспользуемся Python-пакетом <a class="reference external" href="https://psicode.org/posts/psi4education_setup/">psi4</a>. Он реализует многие алгоритмы квантовой химии и имеет неплохое Python API.</p>
<p>Давайте посчитаем c помощью psi4 энергию основного состояния атома водорода. Некоторые параметры сейчас придется использовать, “поверив на слово”. Их смысл будет объяснен в дальнейшем.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">psi4</span>

<span class="n">h_atom</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">geometry</span><span class="p">(</span><span class="s2">&quot;H&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Мы задали атом водорода, по умолчанию атом помещается в начало координат.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi4</span><span class="o">.</span><span class="n">set_options</span><span class="p">({</span>
  <span class="s1">&#39;basis&#39;</span><span class="p">:</span> <span class="s1">&#39;STO-3G&#39;</span><span class="p">,</span>
  <span class="s1">&#39;reference&#39;</span><span class="p">:</span> <span class="s1">&#39;rohf&#39;</span><span class="p">,</span>
<span class="p">})</span>
</pre></div>
</div>
</div>
</div>
<p>Тут уже поинтереснее – объяснение этих параметров пока отложим и вернемся после объяснения теории. В целом они определяют, каким именно методом и в каком базисе нужно численно решить уравнение Шредингера.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.constants</span> <span class="kn">import</span> <span class="n">physical_constants</span>

<span class="n">h2ev</span> <span class="o">=</span> <span class="n">physical_constants</span><span class="p">[</span><span class="s1">&#39;hartree-electron volt relationship&#39;</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">e_in_ev</span><span class="p">(</span><span class="n">energy_in_ht</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">energy_in_ht</span> <span class="o">*</span> <span class="n">h2ev</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="n">e_in_ht</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">energy</span><span class="p">(</span><span class="s1">&#39;scf&#39;</span><span class="p">)</span> <span class="c1"># энергия в единицах Hartree</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Hydrogen ground state energy: </span><span class="si">{</span><span class="n">e_in_ev</span><span class="p">(</span><span class="n">e_in_ht</span><span class="p">)</span><span class="si">}</span><span class="s2"> eV&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Здесь мы посчитали энергию в единицах Хартри – специальной физической системе единиц, где истинная энергия атома водорода равна 1/2, и перевели ее в электрон-вольты.</p>
<p>Результат не очень точный (правильный, как мы помним, равен 13.6 eV) и мы его улучшим после того как разберемся с тем, что и как мы только что посчитали. Разобраться будет удобнее на примере атома гелия, потому что в атоме водорода есть только один электрон, а в любой реальной системе – больше одного.</p>
</div>
</div>
<div class="section" id="id11">
<h4>Теория самосогласованного поля<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<div class="section" id="id12">
<h5>Атом гелия<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h5>
<p>Следующим “по простоте” после атома водорода идет атом гелия – как говорит нам школьная химия, это атом из двух протонов, двух нейтронов и двух электронов. Протоны и нейтроны находятся близко друг к другу в ядре и имеют почти одинаковую массу, так что можно просто считать, что есть ядро с зарядом +2 и массой 4. А вот с электронами все сложнее: с одной стороны, это независимые частицы, а с другой – они взаимодействуют друг с другом по закону Кулона, так как оба имеют отрицательный заряд.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Для гравитационного взаимодействия “<a class="reference external" href="https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0_%D1%82%D1%80%D1%91%D1%85_%D1%82%D0%B5%D0%BB">проблема трех тел</a>” не имеет известного аналитического решения. Это означает, что если мы знаем, что где-то в глубоком космосе вдалеке от остального мира есть три объекта с известными массами, импульсами и координатами, то, увы, в общем случае не сможем предсказать их движение аналитически (хотя сможем предсказать численно, либо найти приближенное аналитическое решение, если масса одного объекта много больше других, например).</p>
<p>Для трех классических тел с кулоновским потенциалом все тоже сложно – можно посмотреть <a class="reference external" href="https://www.wolframcloud.com/objects/demonstrations/ThreeBodyCoulombProblem-source.nb">тут</a>, как поведет себя система трех тел с различными зарядами.</p>
</div>
<p>Попробуем записать уравнение Шредингера для системы из ядра и двух электронов:</p>
<div class="math notranslate nohighlight">
\[
 \dot{\imath} \hbar \frac{d}{dt} {\ket{\Psi(t, \vec{r_A}, \vec{r_B})}} = (
  \frac{ \hat{p_A}^{2} }{2m} - \frac{2e \cdot e}{r_A} +
  \frac{ \hat{p_B}^{2} }{2m} - \frac{2e \cdot e}{r_B} +
  \frac{e \cdot e}{|r_A - r_B|}
  ) {\ket{\Psi(t, \vec{r_A}, \vec{r_B})}}
\]</div>
<p>Оно состоит из кинетической и потенциальной энергии двух электронов в поле ядра и (последнее слагаемое) потенциала взаимодействия двух электронов.
Учитывая, что уравнение примерно такое же, как у водорода, только еще более сложное, решение стоит искать численно и с использованием приближений, а не аналитически.</p>
<p>Если бы не последний член гамильтониана, то можно было бы разбить все выражение на две независимых части – с переменными электрона А и с переменными электрона B. Так как это дифференциальное уравнение, можно было бы воспользоваться разделением переменных и найти отдельные решения для двух электронов – задача аналогична атому водорода, а ее мы уже решили.</p>
<p>Но из-за потенциала взаимодействия решение существенно усложняется, поскольку электроны влияют друг на друга. Придется прибегнуть к упрощениям – и одним из наиболее популярных подходов является <em>теория самосогласованного поля</em> (Self-Consistent Field).</p>
</div>
<div class="section" id="id13">
<h5>Теория самосогласованного поля<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h5>
<p>Теория самосогласованного поля (self-consistent field theory) – это подход итеративного решения уравнения Шредингера для многочастичной системы, на основе которого построено много квантово-химических методов, наиболее известный из которых – метод Хартри-Фока. В сниппете выше строчка <code class="docutils literal notranslate"><span class="pre">psi4.energy('scf')</span></code> означает, что энергия посчитана этим методом.</p>
<p>Основная идея теории заключается в следующем.</p>
<p>У нас есть несколько частиц, которые взаимодействуют между собой и найти цельное решение уравнения Шредингера для всех сразу не получается. Тогда вместо этого будем рассматривать частицы по очереди и считать, что все остальные действуют “в среднем” на выбранную частицу. То есть будем считать усредненный по пространству потенциал вместо точного.</p>
<p>Для электрона А в атоме гелия нам нужно учесть усредненное влияние электрона B. Можем для электрона B взять волновую функцию от атома водорода, посчитать на ее основе усредненное влияние на электрон А:</p>
<p><span class="math notranslate nohighlight">\( (h_A + \hat{V}_{eff}) \ket{\psi_A}  =  (h_A +  \bra{\psi_B} \frac{e^2}{r_{AB}} \ket{\psi_B}) \ket{\psi_A}  = \epsilon_A \ket{\psi_A}\)</span></p>
<p>Здесь <span class="math notranslate nohighlight">\(h_A\)</span> – это кинетическая энергия и потенциал ядра для электрона A, а <span class="math notranslate nohighlight">\(V_{eff}\)</span> – влияние электрона B на электрон А. <span class="math notranslate nohighlight">\(V_{eff}\)</span> вычисляется как влияние усредненной электронной плотности, распределенной в соответствии с <span class="math notranslate nohighlight">\(\psi_B\)</span>.</p>
<p>На этом шаге мы считаем, что <span class="math notranslate nohighlight">\(\psi_B\)</span> – фиксированная волновая функция и мы находим “переменную” <span class="math notranslate nohighlight">\(\psi_A\)</span>. Однако <span class="math notranslate nohighlight">\(\psi_A\)</span> тоже будет влиять на <span class="math notranslate nohighlight">\(\psi_B\)</span> и, записав аналогичное уравнение для частицы B, мы следующим шагом найдем новую <span class="math notranslate nohighlight">\(\psi_B\)</span>.</p>
<p>После изменения волновых функций каждого электрона мы можем заново записать их уравнения с новыми волновыми функциями и так по кругу, пока волновые функции и их энергии не сойдутся к какому-то стабильному (самосогласованному) решению.</p>
<p>Все вместе это создает итеративную процедуру:</p>
<ol class="simple">
<li><p>На основе имеющихся волновых функций посчитать среднее поле, которое создают частицы (например, электрон B для электрона А).</p></li>
<li><p>Решить уравнение Шредингера с потенциалом, учитывающим среднее поле, то есть вычислить энергии и новые волновые функции.</p></li>
<li><p>Вернуться к шагу 1.</p></li>
</ol>
<p>Для инициализации можно взять какие-то приблизительные волновые функции для всех частиц (двух электронов гелия), например, решения из уравнения водорода, то есть водородоподобные волновые функции. Далее итерацию повторяют, пока волновые функции и их энергии не перестанут изменяться, то есть самосогласуются.</p>
<p>Система таких уравнений, записанных для каждого электрона, называется <strong>уравнениями <a class="reference external" href="https://ru.wikipedia.org/wiki/%D0%A5%D0%B0%D1%80%D1%82%D1%80%D0%B8,_%D0%94%D1%83%D0%B3%D0%BB%D0%B0%D1%81_%D0%A0%D0%B5%D0%B9%D0%BD%D0%B5%D1%80">Хартри</a></strong>.
На основе таких волновых функций для отдельных электронов можно собрать общую волновую функцию <span class="math notranslate nohighlight">\(\Psi(r_A, r_B)\)</span>, самый простой вариант – это <span class="math notranslate nohighlight">\(\Psi(r_A, r_B) = \psi_A(r_A) \psi_B(r_B)\)</span>, он и был предложен первоначально. Однако есть проблема: такая <span class="math notranslate nohighlight">\(\Psi\)</span> получается не антисимметричной, а только такие волновые функции для системы электронов являются “физичными”, то есть могут существовать в реальности.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Один из основополагающих принципов квантовой механики – тождественность частиц и их неразличимость. Принцип означает, что все частицы одного типа (например, электроны) одинаковы и характеризуются только своим состоянием. Например, если мы “переставим местами” два электрона в атоме (не только пространственно, но и в смысле их состояния и энергий), то получившийся атом будет неотличим от исходного.</p>
<p>Из принципа тождественности следует, что при перестановке не должна меняться плотность вероятности:</p>
<p><span class="math notranslate nohighlight">\( | {\Psi}(X_A, X_B) |^2 = | {\Psi}(X_B, X_A) |^2 \)</span></p>
<p>Кроме того, представим что мы обменяли частицы дважды: A с B и обратно. Никакие физические свойства системы из-за этого измениться не должны. В общем случае, из этого не следует что волновая функция не изменилась – например, так как глобальная фаза волновой функции неизмерима, то мы могли получить <span class="math notranslate nohighlight">\(\Psi' = e^{2 i \pi \theta} \Psi\)</span>.</p>
<p>Но, если мы работаем больше чем в двух пространственных измерениях, то такой двойной обмен эквивалентен отсутсвию обмена. Для начала представим что мы обмениваем частицы медленно описывая полукруг частицей A вокруг частицы B и потом сдвигая обе частицы. Тогда двойной обмен значит, что частица A описывает полный круг вокруг частицы B. Также, если мы непрерывно изменим ее маршрут не приближая ее к частице B, то мы ожидаем получить тот же результат.</p>
<p>Итак, какие замкнутые маршруты мы можен получить непрерывно деформируя маршрут в евклидовом пространстве без точки (B)? Ответ для любого измерения больше 2 – <a class="reference external" href="https://en.wikipedia.org/wiki/Homotopy_groups_of_spheres">любые</a>. Следовательно двойной обмен должен давать такой же результат как и если бы мы просто оставили частицу А на месте <span id="id14">[<a class="reference internal" href="book/index.html#id11"><span>NSS+08</span></a>]</span>.</p>
<p>У этого ограничения есть два решения: либо <span class="math notranslate nohighlight">\( {\Psi}(X_A, X_B) = {\Psi}(X_B, X_A) \)</span> (симметричность), либо <span class="math notranslate nohighlight">\( \Psi(X_A, X_B) = -\Psi(X_B, X_A) \)</span> (антисимметричность).
У антисимметричных функций есть интересное свойство: если функция <span class="math notranslate nohighlight">\(f(x_1, x_2)\)</span> антисимметрична, то <span class="math notranslate nohighlight">\(f(x_1=X, x_2=X)=0\)</span>, то есть антисимметричная функция равна нулю, если ее аргументы одинаковы. В этом легко убедиться на примере <span class="math notranslate nohighlight">\( f = x_1 - x_2 \)</span>.</p>
<p>Для антисимметричной волновой функции это означает, что две частицы не могут иметь полностью одинаковое состояние – волновая функциия (и вероятность) такой конфигурации равна нулю.</p>
<p>В эксперименте это строго выполняется для всех частиц с полуцелым спином (фермионов), к которым относятся электроны, а частицы с целым спином (бозоны), например, фотоны, имеют симметричную волновую функцию и могут иметь одинаковые состояния.</p>
<p>Для квантовой химии это все имеет одно важное следствие: электроны – это фермионы и волновая функция, описывающая всю систему электронов целиком, должна быть антисимметрична относительно перестановки (замены пары индексов). Любое не антисимметричное решение не физично, поскольку допускает существование электронов в одинаковом состоянии, а такого не бывает. В химии этот вывод называется <a class="reference external" href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D0%9F%D0%B0%D1%83%D0%BB%D0%B8">принцип запрета Паули</a>.</p>
</div>
<p>Чтобы сделать волновую функцию системы из двух электронов антисимметричной, используется такой приём:</p>
<p><span class="math notranslate nohighlight">\(\Psi(X_A, X_B) = \psi_A(X_A) \psi_B(X_B) - \psi_B(X_A) \psi_A(X_B) \)</span></p>
<p>Во-первых, легко проверить, что если поменять местами <span class="math notranslate nohighlight">\(X_A\)</span> и <span class="math notranslate nohighlight">\(X_B\)</span>, то вся функция просто изменит знак.
Во-вторых, можно заметить, что формулу можно записать как определитель матрицы:
<span class="math notranslate nohighlight">\( \Psi(X_A, X_B) =
\begin{vmatrix}
\psi_A(X_A)&amp; \psi_B(X_A)\\\
\psi_A(X_B)&amp; \psi_B(X_B)
\end{vmatrix}
\)</span></p>
<p>Из курса линейной алгебры можно вспомнить, что определитель меняет знак при перестановке двух столбцов или двух строк – это свойство позволяет делать антисимметричные волновые функции систем из N волновых функций отдельных электронов, если использовать метод Хартри не для атома гелия, а для системы с бОльшим числом электронов. Для этого составляется определитель <span class="math notranslate nohighlight">\(N \times N\)</span> по аналогии с формулой выше: элемент в строке i, столбце j – это i-я волновая функция с параметрами j-го электрона в качестве аргумента.</p>
<p>Такой вариант сборки волновой функции системы частиц называется “определитель <a class="reference external" href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BB%D0%B5%D0%B9%D1%82%D0%B5%D1%80,_%D0%94%D0%B6%D0%BE%D0%BD_%D0%9A%D0%BB%D0%B0%D1%80%D0%BA">Слэтера</a>”.
Так как весь подход является аппроксимацией, не любая система может быть точно представлена таким детерминантом, но он является очень распространенным методом “сборки” волновой функции системы электронов в квантовой химии. Его использование также немного меняет вид одноэлектронных уравнений: чтобы корректно учесть антисимметрию, в эффективный потенциал добавляется так называемое “обменное взаимодействие”.</p>
<p>Все вместе составляет метод Хартри-<a class="reference external" href="https://ru.wikipedia.org/wiki/%D0%A4%D0%BE%D0%BA,_%D0%92%D0%BB%D0%B0%D0%B4%D0%B8%D0%BC%D0%B8%D1%80_%D0%90%D0%BB%D0%B5%D0%BA%D1%81%D0%B0%D0%BD%D0%B4%D1%80%D0%BE%D0%B2%D0%B8%D1%87">Фока</a>:</p>
<ul class="simple">
<li><p>итеративная процедура самосогласованного поля;</p></li>
<li><p>усредненное действие электронов друг на друга, учет обменного взаимодействия;</p></li>
<li><p>детерминант Слетера.</p></li>
</ul>
</div>
<div class="section" id="scf-psi4">
<h5>SCF в psi4<a class="headerlink" href="#scf-psi4" title="Permalink to this headline">¶</a></h5>
<p>Теперь можно вернуться к коду и взглянуть на него чуть более осмысленно.
При вычислении энергии мы явно передаем, что хотим посчитать ее методом Self-Consistent Field:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">e_in_ht</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">energy</span><span class="p">(</span><span class="s1">&#39;scf&#39;</span><span class="p">)</span>

</pre></div>
</div>
<p>Но что происходит в настройках, пока по-прежнему неясно:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">psi4</span><span class="o">.</span><span class="n">set_options</span><span class="p">({</span>
  <span class="s1">&#39;basis&#39;</span><span class="p">:</span> <span class="s1">&#39;STO-3G&#39;</span><span class="p">,</span>
  <span class="s1">&#39;reference&#39;</span><span class="p">:</span> <span class="s1">&#39;rohf&#39;</span><span class="p">,</span>
<span class="p">})</span>
</pre></div>
</div>
<p>Начнем с параметра <code class="docutils literal notranslate"><span class="pre">basis</span></code>. <a class="reference external" href="https://en.wikipedia.org/wiki/STO-nG_basis_sets"><code class="docutils literal notranslate"><span class="pre">STO-3G</span></code></a> – не стандарт связи, а <strong>S</strong>later <strong>T</strong>ype <strong>O</strong>rbital с <strong>3</strong> <strong>Г</strong>ауссианами в базисном наборе, то есть базис на основе детерминанта Слетера. В описании метода SCF мы собирались начинать итерации с водородоподобных волновых функций, но так как весь метод является аппроксимирующим, нам никто не мешает выбрать другие волновые функции, если результаты лучше согласуются с экспериментом. Выбор базиса может существенно влиять на результат вычислений и современные базисы сложнее, чем Слетеровский детерминант – он просто один из первых и наиболее популярных.</p>
<p>Параметр <code class="docutils literal notranslate"><span class="pre">reference</span></code> означает, какие предположения о волновой функции мы делаем, в данном случае используется <a class="reference external" href="https://en.wikipedia.org/wiki/Restricted_open-shell_Hartree%E2%80%93Fock">Restricted Open Shell Hartree-Fock</a>, так как у атома водорода только один электрон и его оболочка не заполнена (на уровне энергии n=1 для этого нужно 2 электрона).</p>
<p>Давайте повторим вычисления с более “современными” опциями.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">clean</span><span class="p">()</span>

<span class="n">h_atom</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">geometry</span><span class="p">(</span><span class="s2">&quot;H&quot;</span><span class="p">)</span>

<span class="n">psi4</span><span class="o">.</span><span class="n">set_options</span><span class="p">({</span>
  <span class="s1">&#39;basis&#39;</span><span class="p">:</span> <span class="s1">&#39;d-aug-cc-pv5z&#39;</span><span class="p">,</span> <span class="c1"># разбор этого базиса выходит за рамки этого интро</span>
  <span class="s1">&#39;scf_type&#39;</span><span class="p">:</span> <span class="s1">&#39;pk&#39;</span><span class="p">,</span>
  <span class="s1">&#39;reference&#39;</span><span class="p">:</span> <span class="s1">&#39;rohf&#39;</span>
<span class="p">})</span>

<span class="n">e_in_ht</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">energy</span><span class="p">(</span><span class="s1">&#39;scf&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Better hydrogen ground state energy: </span><span class="si">{</span><span class="n">e_in_ev</span><span class="p">(</span><span class="n">e_in_ht</span><span class="p">)</span><span class="si">}</span><span class="s2"> eV&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Та-дам! Используя более прокачанные базисы, мы получили правильный ответ.</p>
<p>Давайте посмотрим, что еще можно сделать с помощью self-consistent field.</p>
</div>
<div class="section" id="id15">
<h5>Атом Гелия (численно)<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h5>
<p>Раз мы разобрали SCF на примере атома гелия, то наверняка можно посчитать его энергию в psi4.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">clean</span><span class="p">()</span>

<span class="n">he_atom</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">geometry</span><span class="p">(</span><span class="s2">&quot;He&quot;</span><span class="p">)</span>

<span class="n">psi4</span><span class="o">.</span><span class="n">set_options</span><span class="p">({</span>
  <span class="s1">&#39;basis&#39;</span><span class="p">:</span> <span class="s1">&#39;STO-3G&#39;</span><span class="p">,</span>
  <span class="s1">&#39;reference&#39;</span><span class="p">:</span> <span class="s1">&#39;rohf&#39;</span><span class="p">,</span>
<span class="p">})</span>

<span class="n">e_in_ht</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">energy</span><span class="p">(</span><span class="s1">&#39;scf&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Helium ground state energy: </span><span class="si">{</span><span class="n">e_in_ev</span><span class="p">(</span><span class="n">e_in_ht</span><span class="p">)</span><span class="si">}</span><span class="s2"> eV&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Экспериментальное значение энергии атома гелия <a class="reference external" href="https://en.wikipedia.org/wiki/Helium_atom#Experimental_value_of_ionization_energy">равно</a> -79.0 eV.</p>
</div>
<div class="section" id="id16">
<h5>Молекула водорода<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h5>
<p>Пока мы рассматривали только атомы, но SCF можно использовать и для молекул – потенциалы становятся сложнее, электронов больше, но общая логика не меняется.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">clean</span><span class="p">()</span>

<span class="n">h_mol</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">geometry</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">H 0 0 0</span>
<span class="s2">H 0 0 0.74</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span> <span class="c1"># задали 2 атома водорода с явными координатами</span>

<span class="n">psi4</span><span class="o">.</span><span class="n">set_options</span><span class="p">({</span>
  <span class="s1">&#39;basis&#39;</span><span class="p">:</span> <span class="s1">&#39;STO-3G&#39;</span><span class="p">,</span>
  <span class="s1">&#39;reference&#39;</span><span class="p">:</span> <span class="s1">&#39;rohf&#39;</span><span class="p">,</span>
<span class="p">})</span>

<span class="n">e_in_ht_h</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">energy</span><span class="p">(</span><span class="s1">&#39;scf&#39;</span><span class="p">,</span> <span class="n">molecule</span><span class="o">=</span><span class="n">h_mol</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Hydrogen ground state energy: </span><span class="si">{</span><span class="n">e_in_ev</span><span class="p">(</span><span class="n">e_in_ht_h</span><span class="p">)</span><span class="si">}</span><span class="s2"> eV&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Здесь мы задали явно координаты обоих атомов водорода в молекуле и энергия электронов была высчитана в предположении, что ядра водородов неподвижны. Здесь расстояние в 0.74 Ангстрема взято из <a class="reference external" href="https://cccbdb.nist.gov/exp2x.asp?casno=1333740&amp;charge=0">экспериментальных данных</a>. Если бы мы зададим неправильные координаты, то рассчитанная энергия окажется неверной. Точнее, она соответствовала бы нефизичной ситуации, когда неведомая сила “удерживает” ядра водорода на месте.</p>
<p>В psi4 есть метод для оптимизации геометрии молекулы <code class="docutils literal notranslate"><span class="pre">psi4.optimize</span></code>. Он не фиксирует положение ядер и возвращает минимальную возможную энергию с учетом вариации положения атомов.</p>
<p>Вычисления с оптимизацией геометрии занимают значительно больше времени.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">clean</span><span class="p">()</span>

<span class="n">h_mol_bad</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">geometry</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">H 0 0 0</span>
<span class="s2">H 0 0 1.5</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span> <span class="c1"># неверное расстояние в ангстремах</span>


<span class="n">psi4</span><span class="o">.</span><span class="n">set_options</span><span class="p">({</span>
  <span class="s1">&#39;basis&#39;</span><span class="p">:</span> <span class="s1">&#39;STO-3G&#39;</span><span class="p">,</span>
  <span class="s1">&#39;reference&#39;</span><span class="p">:</span> <span class="s1">&#39;rohf&#39;</span><span class="p">,</span>
<span class="p">})</span>

<span class="c1"># рассчитываем энергию &quot;в точке&quot; с неправильной геометрией</span>
<span class="n">e_in_ht_h_bad</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">energy</span><span class="p">(</span><span class="s1">&#39;scf&#39;</span><span class="p">,</span> <span class="n">molecule</span><span class="o">=</span><span class="n">h_mol_bad</span><span class="p">)</span>

<span class="c1"># рассчитываем энергию, оптимизируя по ходу геометрию</span>
<span class="n">e_in_ht_h_optimized</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="s1">&#39;scf&#39;</span><span class="p">,</span> <span class="n">molecule</span><span class="o">=</span><span class="n">h_mol_bad</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Hydrogen molecule, incorrect ground state energy: </span><span class="si">{</span><span class="n">e_in_ev</span><span class="p">(</span><span class="n">e_in_ht_h_bad</span><span class="p">)</span><span class="si">}</span><span class="s2"> eV&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Hydrogen molecule, optimized ground state energy: </span><span class="si">{</span><span class="n">e_in_ev</span><span class="p">(</span><span class="n">e_in_ht_h_optimized</span><span class="p">)</span><span class="si">}</span><span class="s2"> eV&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Для некорректной геометрии получилась завышенная энергия, а после оптимизации – почти что такая же энергию, как при вычислении с фиксированным расстоянием 0.74. В оптимальном состоянии энергия системы должна быть минимальна, так что результаты вполне разумны.</p>
<p>Подобный метод можно использовать и для поиска геометрии куда более сложных молекул.</p>
</div>
<div class="section" id="id17">
<h5>Молекула этилового спирта<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h5>
<p>Молекула водорода – это все еще почти игрушечный пример. Давайте попробуем обсчитать молекулу этанола.</p>
<p>Задавать руками геометрию молекулы <span class="math notranslate nohighlight">\(C_2H_5OH\)</span> можно, но будет явно сложнее, чем для молекулы водорода. К счастью, это необязательно: psi4 умеет скачивать геометрию из базы данных <a class="reference external" href="https://pubchem.ncbi.nlm.nih.gov/">PubChem</a> по номенклатурному имени либо уникальному ChemId.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi4</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">clean</span><span class="p">()</span>

<span class="n">eth</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">geometry</span><span class="p">(</span><span class="s2">&quot;pubchem:ethanol&quot;</span><span class="p">)</span>

<span class="n">psi4</span><span class="o">.</span><span class="n">set_options</span><span class="p">({</span>
  <span class="s1">&#39;basis&#39;</span><span class="p">:</span> <span class="s1">&#39;STO-3G&#39;</span><span class="p">,</span>
  <span class="s1">&#39;reference&#39;</span><span class="p">:</span> <span class="s1">&#39;rohf&#39;</span><span class="p">,</span>
<span class="p">})</span>

<span class="n">e_in_ht_eth</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">energy</span><span class="p">(</span><span class="s1">&#39;scf&#39;</span><span class="p">,</span> <span class="n">molecule</span><span class="o">=</span><span class="n">eth</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Ethanol ground state energy: </span><span class="si">{</span><span class="n">e_in_ev</span><span class="p">(</span><span class="n">e_in_ht_eth</span><span class="p">)</span><span class="si">}</span><span class="s2"> eV&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="id18">
<h4>Итоги<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h4>
<p>Мы разобрались с базовой теорией квантовой химии:</p>
<ul class="simple">
<li><p>как записать уравнение Шредингера для атома;</p></li>
<li><p>какое получается аналитическое решение для атома водорода;</p></li>
<li><p>как устроен метод Self-Consistent Field для вычисления волновых функций и энергии для задачи многих тел;</p></li>
<li><p>как пользоваться SCF в python пакете psi4.</p></li>
</ul>
<p>В примерах мы везде вычисляли ground state энергию, но, конечно, зная волновые функции, можно посчитать много чего еще. Например, можно вычислить спектр поглощения и энергию ионизации (энергии возбужденных состояний), моделировать взаимодействие молекул (найти равновесное состояние для двух систем), с помощью плагинов можно смоделировать рассеяния рентгена на молекуле… Квантовая механика постулирует, что любая измеримая величина является усреднением определенного оператора по волновой функции, поэтому возможности ограничены в основном вычислительной сложностью, а не теорией.</p>
<p>Для более глубокого погружения в практику квантовой химии можно пройти лабораторные работы psi4: <a class="reference external" href="https://psicode.netlify.app/posts/psi4education/">раз</a>, <a class="reference external" href="http://education.molssi.org/qm-tools/">два</a>.</p>
</div>
</div>
</div>
<div class="toctree-wrapper compound">
<span id="document-book/bibliography"></span><div class="section" id="id1">
<h3>Список литературы<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p id="id2"><dl class="citation">
<dt class="label" id="id3"><span class="brackets">And19</span></dt>
<dd><p>Neculai Andrei. A diagonal quasi-newton updating method for unconstrained optimization. <em>Numerical Algorithms</em>, 81(2):575–590, 2019. <a class="reference external" href="https://doi.org/https://doi.org/10.1007/s11075-018-0562-7">doi:https://doi.org/10.1007/s11075-018-0562-7</a>.</p>
</dd>
<dt class="label" id="id10"><span class="brackets">AAB+19</span></dt>
<dd><p>Frank Arute, Kunal Arya, Ryan Babbush, Dave Bacon, Joseph C Bardin, Rami Barends, Rupak Biswas, Sergio Boixo, Fernando GSL Brandao, David A Buell, and others. Quantum supremacy using a programmable superconducting processor. <em>Nature</em>, 574(7779):505–510, 2019. <a class="reference external" href="https://doi.org/https://doi.org/10.1038/s41586-019-1666-5">doi:https://doi.org/10.1038/s41586-019-1666-5</a>.</p>
</dd>
<dt class="label" id="id8"><span class="brackets">HavlivcekCorcolesT+19</span></dt>
<dd><p>Vojtěch Havlíček, Antonio D Córcoles, Kristan Temme, Aram W Harrow, Abhinav Kandala, Jerry M Chow, and Jay M Gambetta. Supervised learning with quantum-enhanced feature spaces. <em>Nature</em>, 567(7747):209–212, Mar 2019. URL: <a class="reference external" href="https://arxiv.org/abs/1804.11326">https://arxiv.org/abs/1804.11326</a>, <a class="reference external" href="https://doi.org/10.1038/s41586-019-0980-2">doi:10.1038/s41586-019-0980-2</a>.</p>
</dd>
<dt class="label" id="id4"><span class="brackets">MBK21</span></dt>
<dd><p>Andrea Mari, Thomas R. Bromley, and Nathan Killoran. Estimating the gradient and higher-order derivatives on quantum hardware. <em>Physical Review A</em>, 103(1):012405, Jan 2021. URL: <a class="reference external" href="https://arxiv.org/abs/2008.06517">https://arxiv.org/abs/2008.06517</a>, <a class="reference external" href="https://doi.org/10.1103/physreva.103.012405">doi:10.1103/physreva.103.012405</a>.</p>
</dd>
<dt class="label" id="id7"><span class="brackets">MNKF18</span></dt>
<dd><p>Kosuke Mitarai, Makoto Negoro, Masahiro Kitagawa, and Keisuke Fujii. Quantum circuit learning. <em>Physical Review A</em>, 98(3):032309, Sep 2018. URL: <a class="reference external" href="https://arxiv.org/abs/1803.00745">https://arxiv.org/abs/1803.00745</a>, <a class="reference external" href="https://doi.org/10.1103/PhysRevA.98.032309">doi:10.1103/PhysRevA.98.032309</a>.</p>
</dd>
<dt class="label" id="id11"><span class="brackets">NSS+08</span></dt>
<dd><p>Chetan Nayak, Steven H. Simon, Ady Stern, Michael Freedman, and Sankar Das Sarma. Non-abelian anyons and topological quantum computation. <em>Reviews of Modern Physics</em>, 80(3):1083–1159, Sep 2008. URL: <a class="reference external" href="http://dx.doi.org/10.1103/RevModPhys.80.1083">http://dx.doi.org/10.1103/RevModPhys.80.1083</a>, <a class="reference external" href="https://doi.org/10.1103/revmodphys.80.1083">doi:10.1103/revmodphys.80.1083</a>.</p>
</dd>
<dt class="label" id="id12"><span class="brackets">Sch21</span></dt>
<dd><p>Maria Schuld. Quantum machine learning models are kernel methods. <em>arXiv e-prints</em>, pages 26 pages, 2021. URL: <a class="reference external" href="https://arxiv.org/abs/2101.11020">https://arxiv.org/abs/2101.11020</a>, <a class="reference external" href="https://arxiv.org/abs/2101.11020">arXiv:2101.11020</a>.</p>
</dd>
<dt class="label" id="id9"><span class="brackets">SYG+20</span></dt>
<dd><p>Yudai Suzuki, Hiroshi Yano, Qi Gao, Shumpei Uno, Tomoki Tanaka, Manato Akiyama, and Naoki Yamamoto. Analysis and synthesis of feature map for kernel-based quantum classifier. <em>Quantum Machine Intelligence</em>, 2(1):1–9, Jul 2020. URL: <a class="reference external" href="https://arxiv.org/abs/1906.10467">https://arxiv.org/abs/1906.10467</a>, <a class="reference external" href="https://doi.org/10.1007/s42484-020-00020-y">doi:10.1007/s42484-020-00020-y</a>.</p>
</dd>
<dt class="label" id="id6"><span class="brackets">89</span></dt>
<dd><p>Лифшиц Е. М. Ландау Л. Д. <em>Квантовая механика: Нерелятивистская теория.</em> Наука, 1989. URL: <a class="reference external" href="https://www.math.purdue.edu/~eremenko/dvi/LL.pdf">https://www.math.purdue.edu/~eremenko/dvi/LL.pdf</a>.</p>
</dd>
<dt class="label" id="id5"><span class="brackets">15</span></dt>
<dd><p>Иванов М.Г. <em>Как понимать квантовую механику.</em> Регулярная и хаотическая динамика, 2015. URL: <a class="reference external" href="https://mipt.ru/upload/medialibrary/533/quant-2.pdf">https://mipt.ru/upload/medialibrary/533/quant-2.pdf</a>.</p>
</dd>
</dl>
</p>
</div>
<span id="document-book/authors"></span><div class="section" id="authors">
<span id="id1"></span><h3>Список авторов курса<a class="headerlink" href="#authors" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id2">
<h4>Создатели курса<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<ol class="simple">
<li><p><a class="reference external" href="https://github.com/SemyonSinchenko">Семен Синченко</a></p></li>
<li><p><a class="reference external" href="https://github.com/Yorko">Юрий Кашницкий</a></p></li>
<li><p><a class="reference external" href="https://github.com/vtrokhymenko">Виктор Трохименко</a></p></li>
</ol>
</div>
<div class="section" id="id3">
<h4>Основные авторы<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<ol class="simple">
<li><p><a class="reference external" href="https://github.com/SemyonSinchenko">Семен Синченко</a></p></li>
<li><p><a class="reference external" href="https://github.com/ooovector">Илья Беседин</a></p></li>
<li><p><a class="reference external" href="https://github.com/doktrster">Сергей Ширкин</a></p></li>
<li><p><a class="reference external" href="https://github.com/meandmytram">Александр Березутский</a></p></li>
</ol>
</div>
<div class="section" id="id4">
<h4>Основные ревьюеры<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<ol class="simple">
<li><p><a class="reference external" href="https://github.com/Yorko">Юрий Кашницкий</a></p></li>
<li><p><a class="reference external" href="https://github.com/vtrokhymenko">Виктор Трохименко</a></p></li>
<li><p><a class="reference external" href="https://github.com/zimka">Борис Зимка</a></p></li>
<li><p><a class="reference external" href="https://github.com/karelin">Николай Карелин</a></p></li>
<li><p><a class="reference external" href="https://github.com/Randl">Евгений Желтоножский</a></p></li>
</ol>
</div>
<div class="section" id="id5">
<h4>Редакторы<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<ol class="simple">
<li><p><a class="reference external" href="https://github.com/nsmarkova">Наталья Маркова</a></p></li>
</ol>
</div>
<div class="section" id="id6">
<h4>Техническая поддержка<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<ol class="simple">
<li><p><a class="reference external" href="https://github.com/dkorzhov">Дмитрий Коржов</a></p></li>
</ol>
</div>
<div class="section" id="id7">
<h4>Полный список авторов<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
<strong>А</strong><div class="summary-down docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="summary-up docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="summary-content card-body docutils">
</div>
</details><details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
<strong>Б</strong><div class="summary-down docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="summary-up docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="summary-content card-body docutils">
<p class="card-text"><a class="reference external" href="https://github.com/meandmytram">Березуцкий Александр</a></p>
</div>
</details><details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
<strong>В</strong><div class="summary-down docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="summary-up docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="summary-content card-body docutils">
</div>
</details><details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
<strong>Г</strong><div class="summary-down docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="summary-up docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="summary-content card-body docutils">
</div>
</details><details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
<strong>Д</strong><div class="summary-down docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="summary-up docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="summary-content card-body docutils">
</div>
</details><details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
<strong>Е</strong><div class="summary-down docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="summary-up docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="summary-content card-body docutils">
<p class="card-text"><a class="reference external" href="https://github.com/Randl">Евгений Желтоножский</a></p>
</div>
</details><details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
<strong>Ж</strong><div class="summary-down docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="summary-up docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="summary-content card-body docutils">
</div>
</details><details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
<strong>З</strong><div class="summary-down docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="summary-up docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="summary-content card-body docutils">
<p class="card-text"><a class="reference external" href="https://github.com/zimka">Зимка Борис</a></p>
</div>
</details><details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
<strong>И</strong><div class="summary-down docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="summary-up docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="summary-content card-body docutils">
</div>
</details><details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
<strong>К</strong><div class="summary-down docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="summary-up docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="summary-content card-body docutils">
<p class="card-text"><a class="reference external" href="https://github.com/karelin">Карелин Николай</a></p>
<p class="card-text"><a class="reference external" href="https://github.com/Yorko">Кашницкий Юрий</a></p>
</div>
</details><details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
<strong>Л</strong><div class="summary-down docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="summary-up docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="summary-content card-body docutils">
</div>
</details><details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
<strong>М</strong><div class="summary-down docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="summary-up docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="summary-content card-body docutils">
<p class="card-text"><a class="reference external" href="https://github.com/nsmarkova">Маркова Наталья</a></p>
</div>
</details><details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
<strong>Н</strong><div class="summary-down docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="summary-up docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="summary-content card-body docutils">
</div>
</details><details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
<strong>О</strong><div class="summary-down docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="summary-up docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="summary-content card-body docutils">
</div>
</details><details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
<strong>П</strong><div class="summary-down docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="summary-up docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="summary-content card-body docutils">
</div>
</details><details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
<strong>Р</strong><div class="summary-down docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="summary-up docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="summary-content card-body docutils">
</div>
</details><details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
<strong>С</strong><div class="summary-down docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="summary-up docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="summary-content card-body docutils">
<p class="card-text"><a class="reference external" href="https://github.com/SemyonSinchenko">Синченко Семен</a></p>
</div>
</details><details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
<strong>Т</strong><div class="summary-down docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="summary-up docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="summary-content card-body docutils">
<p class="card-text"><a class="reference external" href="https://github.com/vtrokhymenko">Трохименко Виктор</a></p>
</div>
</details><details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
<strong>У</strong><div class="summary-down docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="summary-up docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="summary-content card-body docutils">
</div>
</details><details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
<strong>Ф</strong><div class="summary-down docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="summary-up docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="summary-content card-body docutils">
</div>
</details><details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
<strong>Х</strong><div class="summary-down docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="summary-up docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="summary-content card-body docutils">
</div>
</details><details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
<strong>Ц</strong><div class="summary-down docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="summary-up docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="summary-content card-body docutils">
</div>
</details><details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
<strong>Ш</strong><div class="summary-down docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="summary-up docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="summary-content card-body docutils">
<p class="card-text"><a class="reference external" href="https://github.com/doktrster">Ширкин Сергей</a></p>
</div>
</details><details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
<strong>Э</strong><div class="summary-down docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="summary-up docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="summary-content card-body docutils">
</div>
</details><details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
<strong>Ю</strong><div class="summary-down docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="summary-up docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="summary-content card-body docutils">
</div>
</details><details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
<strong>Я</strong><div class="summary-down docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="summary-up docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="summary-content card-body docutils">
</div>
</details></div>
</div>
<span id="document-book/acknowledgments"></span><div class="section" id="acknowledgments">
<span id="id1"></span><h3>Благодарности<a class="headerlink" href="#acknowledgments" title="Permalink to this headline">¶</a></h3>
<p>Команда курса выражает благодарность:</p>
<ul class="simple">
<li><p>сообществу <a class="reference external" href="https://ods.ai">Open Data Science</a> за предоставление платформы для размещения курса и техническую поддержку;</p></li>
</ul>
</div>
<span id="document-book/glossary"></span><div class="section" id="glossary">
<span id="id1"></span><h3>Глоссарий<a class="headerlink" href="#glossary" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id2">
<h4>А<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<dl class="glossary simple">
<dt id="term-0">Алгоритм Гровера<a class="headerlink" href="#term-0" title="Permalink to this term">¶</a></dt><dd><p>Англ. Grover’s algorithm</p>
</dd>
<dt id="term-1">Алгоритм квантового приближения для задачи оптимизации<a class="headerlink" href="#term-1" title="Permalink to this term">¶</a></dt><dd><p>(QAOA, quantum approximate optimization algorithm), <a class="reference external" href="https://www.osp.ru/os/2019/03/13055118">https://www.osp.ru/os/2019/03/13055118</a>, <a class="reference external" href="https://habr.com/ru/post/513474/">https://habr.com/ru/post/513474/</a></p>
</dd>
</dl>
</div>
<div class="section" id="id3">
<h4>Б<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<dl class="glossary simple">
<dt id="term-2">Бра-вектор<a class="headerlink" href="#term-2" title="Permalink to this term">¶</a></dt><dd><p>Англ. bra-vector</p>
</dd>
</dl>
</div>
<div class="section" id="id4">
<h4>В<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<dl class="glossary simple">
<dt id="term-3">Вакуумное состояние<a class="headerlink" href="#term-3" title="Permalink to this term">¶</a></dt><dd><p>Англ. Vacuum state, также используется название “основное состояние” (basic state). Так часто называется
квантовое состояние с вектором <span class="math notranslate nohighlight">\(\ket{0}\)</span>. Термин заимствован из квантовой оптики, чаще всего не имеет ничего
общего с “обыденным” понятием “вакуума”.</p>
</dd>
<dt id="term-4">Вариационная квантовая схема<a class="headerlink" href="#term-4" title="Permalink to this term">¶</a></dt><dd><p>Англ. Variational Quantum Circuits (VQC)</p>
</dd>
<dt id="term-5">Вариационное машинное обучение<a class="headerlink" href="#term-5" title="Permalink to this term">¶</a></dt><dd><p>Англ. variational machine learning</p>
</dd>
</dl>
</div>
<div class="section" id="id5">
<h4>Г<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<dl class="glossary simple">
<dt id="term-6">Гейты<a class="headerlink" href="#term-6" title="Permalink to this term">¶</a></dt><dd><p>Англ. Quantum gates</p>
</dd>
<dt id="term-7">Гейт Адамара<a class="headerlink" href="#term-7" title="Permalink to this term">¶</a></dt><dd><p>Англ. Hadamard gate</p>
</dd>
<dt id="term-C-NOT">Гейт C-NOT<a class="headerlink" href="#term-C-NOT" title="Permalink to this term">¶</a></dt><dt id="term-NOT">Гейт NOT<a class="headerlink" href="#term-NOT" title="Permalink to this term">¶</a></dt><dt id="term-T">T-гейт<a class="headerlink" href="#term-T" title="Permalink to this term">¶</a></dt><dt id="term-8">Гейты поворота<a class="headerlink" href="#term-8" title="Permalink to this term">¶</a></dt><dt id="term-Phase-shift">Phase-shift гейт<a class="headerlink" href="#term-Phase-shift" title="Permalink to this term">¶</a></dt><dt id="term-9">Единичный гейт<a class="headerlink" href="#term-9" title="Permalink to this term">¶</a></dt><dt id="term-iSWAP">Гейт iSWAP<a class="headerlink" href="#term-iSWAP" title="Permalink to this term">¶</a></dt><dt id="term-fSim">fSim<a class="headerlink" href="#term-fSim" title="Permalink to this term">¶</a></dt><dd></dd>
</dl>
</div>
<div class="section" id="id6">
<h4>И<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<dl class="glossary simple">
<dt id="term-10">Измерение<a class="headerlink" href="#term-10" title="Permalink to this term">¶</a></dt><dd><p>Англ. Quantum measurement</p>
</dd>
</dl>
</div>
<div class="section" id="id7">
<h4>К<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<dl class="glossary simple">
<dt id="term-11">Квантовая информация<a class="headerlink" href="#term-11" title="Permalink to this term">¶</a></dt><dd><p>Также используется термин “квантовая информатика”, англ. Quantum Information</p>
</dd>
<dt id="term-12">Квантовый оператор<a class="headerlink" href="#term-12" title="Permalink to this term">¶</a></dt><dd><p>Англ. Quantum operator</p>
</dd>
<dt id="term-13">Квантово-классическое обучение<a class="headerlink" href="#term-13" title="Permalink to this term">¶</a></dt><dd><p>Англ. Quantum-classical machine learning</p>
</dd>
<dt id="term-14">Квантовое состояние<a class="headerlink" href="#term-14" title="Permalink to this term">¶</a></dt><dd><p>Англ. Quantum state</p>
</dd>
<dt id="term-15">Кет-вектор<a class="headerlink" href="#term-15" title="Permalink to this term">¶</a></dt><dd><p>Англ. ket-vector</p>
</dd>
<dt id="term-16">Кот Шредингера<a class="headerlink" href="#term-16" title="Permalink to this term">¶</a></dt><dd><p>Англ. Schrödinger’s cat</p>
</dd>
<dt id="term-17"><a class="reference external" href="https://ru.wikipedia.org/wiki/%D0%9A%D1%83%D0%B1%D0%B8%D1%82">Кубит</a><a class="headerlink" href="#term-17" title="Permalink to this term">¶</a></dt><dd><p>Также кюбит или q-бит, англ. Qubit, от quantum bit. Минимальная единица информации на квантовом компьютере.
Как и (классический) бит, кубит допускает два состояния, которые обычно обозначаются кет-векторами <span class="math notranslate nohighlight">\(\ket{0}\)</span> и <span class="math notranslate nohighlight">\(\ket{1}\)</span>,
а на уровне реализации кубит – это двухуровневая квантовая система, такая как две поляризации фотона или спина электрона.</p>
</dd>
</dl>
</div>
<div class="section" id="id8">
<h4>М<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<dl class="glossary simple">
<dt id="term-18">Матрица плотности<a class="headerlink" href="#term-18" title="Permalink to this term">¶</a></dt><dd><p>Также используется термин “оператор плотности”, англ. Density matrix или Density operator</p>
</dd>
<dt id="term-19">Метод квантового локального подбора<a class="headerlink" href="#term-19" title="Permalink to this term">¶</a></dt><dd><p>(QLS, quantum local search), <a class="reference external" href="https://www.osp.ru/os/2019/03/13055118">https://www.osp.ru/os/2019/03/13055118</a></p>
</dd>
<dt id="term-20">Многокубитные гейты<a class="headerlink" href="#term-20" title="Permalink to this term">¶</a></dt><dd><p>Англ. Multiqubit gates</p>
</dd>
</dl>
</div>
<div class="section" id="id9">
<h4>Н<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h4>
<dl class="glossary simple">
<dt id="term-21"><a class="reference external" href="https://ru.wikipedia.org/wiki/%D0%91%D1%80%D0%B0_%D0%B8_%D0%BA%D0%B5%D1%82">Нотация Дирака</a><a class="headerlink" href="#term-21" title="Permalink to this term">¶</a></dt><dd><p>Англ. Dirac notation, формализм (система обозначения) для описания кантовых состояний на основе бра- и кет-векторов
(англ. bra-ket от bracket, скобка). В этой системе обозначений <span class="math notranslate nohighlight">\(\ket{\Psi}\)</span> обозначает вектор состояния,
<span class="math notranslate nohighlight">\(\bra{\Psi}\)</span> – сопряженный вектор состояния, а <span class="math notranslate nohighlight">\(\bra{\Psi} \hat{H} \ket{\Psi}\)</span> – среднее (математическое ожидаемое)
значения наблюдаемой для оператора <span class="math notranslate nohighlight">\(\hat{H}\)</span> в состоянии <span class="math notranslate nohighlight">\(\ket{\Psi}\)</span> (также говорят о свертке оператора <span class="math notranslate nohighlight">\(\hat{H}\)</span> с
бра-вектором <span class="math notranslate nohighlight">\(\bra{\Psi}\)</span> и кет-вектором <span class="math notranslate nohighlight">\(\ket{\Psi}\)</span>).
Система обозначений Дирака позволяет отделить отделить вектора состояния <span class="math notranslate nohighlight">\(\ket{\Psi}\)</span> от самого состояния <span class="math notranslate nohighlight">\(\Psi\)</span> или
конкретного математического описания (в виде волновой функции или вектора).</p>
</dd>
</dl>
</div>
<div class="section" id="id10">
<h4>О<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h4>
<dl class="glossary simple">
<dt id="term-22">Операторы Паули<a class="headerlink" href="#term-22" title="Permalink to this term">¶</a></dt><dd><p>Также используется термин “матрицы Паули”, англ. Pauli operators или Pauli matrices</p>
</dd>
</dl>
</div>
<div class="section" id="id11">
<h4>П<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<dl class="glossary simple">
<dt id="term-23">Правило сдвига параметров<a class="headerlink" href="#term-23" title="Permalink to this term">¶</a></dt><dd><p>(*) Англ. Parameter-shift rule</p>
</dd>
</dl>
</div>
<div class="section" id="id12">
<h4>С<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h4>
<dl class="glossary simple">
<dt id="term-24">Смешанные состояние<a class="headerlink" href="#term-24" title="Permalink to this term">¶</a></dt><dd><p>Англ. Mixed states</p>
</dd>
<dt id="term-25">Собственный вектор<a class="headerlink" href="#term-25" title="Permalink to this term">¶</a></dt><dd><p>Англ. Eigenvector</p>
</dd>
<dt id="term-26">Собственное значение<a class="headerlink" href="#term-26" title="Permalink to this term">¶</a></dt><dd><p>Англ. Eigenvalue</p>
</dd>
<dt id="term-27">Соотношение неопределенности<a class="headerlink" href="#term-27" title="Permalink to this term">¶</a></dt><dd><p>Также используется термин “принцип неопределенности”, англ. Uncertainty relation или Uncertainty principle</p>
</dd>
<dt id="term-28">Суперпозиция<a class="headerlink" href="#term-28" title="Permalink to this term">¶</a></dt><dd><p>Англ. Superposition</p>
</dd>
<dt id="term-29">Сфера Блоха<a class="headerlink" href="#term-29" title="Permalink to this term">¶</a></dt><dd><p>Англ. Bloch sphere</p>
</dd>
</dl>
</div>
<div class="section" id="id13">
<h4>У<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h4>
<dl class="glossary simple">
<dt id="term-30">Унитарный оператор<a class="headerlink" href="#term-30" title="Permalink to this term">¶</a></dt><dd><p>Англ. Unitary operator</p>
</dd>
</dl>
</div>
<div class="section" id="id14">
<h4>Ш<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h4>
<dl class="glossary simple">
<dt id="term-Noisy-intermediate-scale-quantum-NISQ-NISQ-Hardware">«Шумные» квантовые компьютеры промежуточного масштаба (Noisy intermediate-scale quantum, NISQ, NISQ Hardware)<a class="headerlink" href="#term-Noisy-intermediate-scale-quantum-NISQ-NISQ-Hardware" title="Permalink to this term">¶</a></dt><dd><p>Термин введен Прескиллом в работе <a class="reference external" href="https://arxiv.org/abs/1801.00862">https://arxiv.org/abs/1801.00862</a> для описания сегодняшнего состояния квантовых вычислений,
когда “настоящие” квантовые вычисления (на миллионах кубит) еще невозможны, но совеменные квантовые компьютеры уже могут
выполнять вычисления, которые невозможны на обычных, классических компьютерах.
См. также краткое обсуждение в <a class="reference external" href="https://quantumcomputing.stackexchange.com/questions/1885/what-is-meant-by-noisy-intermediate-scale-quantum-nisq-technology">https://quantumcomputing.stackexchange.com/questions/1885/what-is-meant-by-noisy-intermediate-scale-quantum-nisq-technology</a>,
и перевод на термина русский <a class="reference external" href="https://www.osp.ru/os/2019/03/13055130">https://www.osp.ru/os/2019/03/13055130</a></p>
</dd>
</dl>
</div>
<div class="section" id="id15">
<h4>Э<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h4>
<dl class="glossary simple">
<dt id="term-31">Энтропия<a class="headerlink" href="#term-31" title="Permalink to this term">¶</a></dt><dd><p>Англ. Entropy</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./book"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
            



<div class='prev-next-bottom'>
    

</div>
        
        </div>
    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By ODS Quantum Community<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  
<script async="" src="https://www.google-analytics.com/analytics.js"></script>
<script>
                        window.ga = window.ga || function () {
                            (ga.q = ga.q || []).push(arguments) };
                        ga.l = +new Date;
                        ga('create', 'UA-51362752-1', 'auto');
                        ga('set', 'anonymizeIp', true);
                        ga('send', 'pageview');
                    </script>

  </body>
</html>