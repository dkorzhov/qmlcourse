# локально попробуйте поменять значение переменной dates
dates = {"Кунг Фьюри": "1968-09-09", "Наташа Романова": "1985-03-15"}
print(dates)

dates["Кунг Фьюри"]

# пока этого ключа нет в словаре, будет ошибка при обращении
# поэтому используем перехват ошибок
try:
    print(dates["Капитан Ямайка"])

except KeyError as e:
    print(f"Ключа действительно нет: {e}")

# этот ключ уже был в примере
dates["Кунг Фьюри"] = "1960-09-09"

# а такого не было
dates["Капитан Ямайка"] = "1930-10-04"

print(dates)

# еще способ создания: пары можно передавать как аргументы dict через `=`
marks = dict(линал=100, английский=92)

# False
print(f'{"матан" in marks = }')

# True
print(f'{"линал" in marks = }')

if "матан" in marks:
    print(marks["матан"])

else:
    print("Нет оценки по матану :(")

empty_dict = {}

# None
print(empty_dict.get("ключ"))

# теперь будет возвращено значение `-1`
print(empty_dict.get("ключ", -1))

# empty_dict -- пустой словарь, поэтому длина равна 0
print(f"{len(empty_dict) = }")

# а вот словарь marks уже содержит две пары, поэтому длина 2
print(f"{len(marks) = }")

# из словаря dates удаляется ключ "Наташа Романова"
del dates["Наташа Романова"]
print(dates.get("Наташа Романова"))

# еще один способ создания словаря из последовательности пар
holidays = dict([("January", [1, 2, 3, 4]), ("Feburary", [23]), ("March", [8])])

# pop() возвращает значение, соответствующее ключу, значит его можно присвоить
# переменной
january_days = holidays.pop("January")

# напечатается соответствующий массив
print(january_days)

# в результате -- последняя добавленная пара
print(holidays.popitem())

# вернемся к предыдущему примеру
# словарь становится пустой
holidays.clear()

# значит, длина равна 0
print(len(holidays))

# создадим два словаря: в первом уже есть два ключа
quidditch_team = {"Fred Weasley": "3rd year", "George Weasley": "3rd year"}

# во втором -- один ключ
new_members = {"Harry Potter": "1st year"}

# добавим пары из new_members
# метод update() также работает in place, поэтому после выполнения данной
# строки кода, в словаре quidditch_team станет три ключа
quidditch_team.update(new_members)

print(quidditch_team["Harry Potter"])

# данный ключ (то, что записано первым в кортеже) уже есть в quidditch_team
member_update = [("Harry Potter", "2nd year")]

# значение, соответствующее "Harry Potter", будет переписано
quidditch_team.update(new_members)

print(quidditch_team["Harry Potter"])

# словарь в качестве ключей хранит имена игроков
for player in quidditch_team:

    # на каждой итерации будет напечатан ключ и значение
    print(player, quidditch_team[player])

# можно создать переменную со всеми значениями словаря
school_years = quidditch_team.values()

# словарь в качестве значений хранит годы обучения
for year in quidditch_team.values():

    # на каждой итерации будет год обучения игрока
    print(year)

# сразу две переменные: первая последовательно будет ключами,
# вторая -- значениями
for player, year in quidditch_team.items():

    # items() избавляет от необходимости обращаться quidditch_team[player],
    # чтобы получить значение. Оно уже в year
    print(f"Player {player} is in {year}")

# вспомним про рабочие дни, ключи - целые числа по номеру дня недели
week = {7: "weekend", 6: "weekend", 1: "workday"}

# в sorted_week окажутся ключи, отсортированные в порядке возрастания
sorted_week = sorted(week)
print(f"Порядок возрастания: {sorted_week}")

counter = 100

# полученное вами значение адреса может отличаться
print(counter, hex(id(counter)))

counter = 200
print(f"{counter = }, {hex(id(counter)) = }")

# создадим две переменные с одинаковыми значениями в диапазоне от -5 до 256
a = 20
b = 20

# a и b указывают на одно и то же место в памяти
# попробуйте у себя поменять значение a и b на число больше 256 или меньше -5
id(a) == id(b)

# создадим список и напечатаем его адрес
ratings = [1, 2, 3]
print(f"Было: {hex(id(ratings))}")

ratings.append(4)
print(f"Стало: {hex(id(ratings))} - ничего не поменялось!")

# при помощи "литерала" - фигурных скобок {}
flowers = {"roses": "red", "violets": "blue"}

# при помощи вызова
#   dict() и последовательности с парами значений
anime = dict([
              ("Ведьмак", "Кошмар волка"),
              ("Призрак в доспехах", ["Призрак в доспехах", "Синдром одиночки", "Невинность"])
             ])

#   dict() и "ключ=значение"
literature = dict(poem_flowers=flowers)

print(f"{flowers = }\n{anime = }\n{literature = }")

# доступ к элементу, если ключа нет - ошибка
print(f'{flowers["violets"] = }')

# при помощи get()
print(f'{flowers.get("magnolias") = }')

days = ["Пн", "Вт", "Ср", "Чт", "Пт"]

# создадим пустой словарь
numbered_days = {}

# будем добавлять в него элементы в цикле
for num in range(len(days)):
    numbered_days[num] = days[num]

# получим отдельно ключи и значения
# пары из tuple можно сразу получить при помощи метода items()
keys = numbered_days.keys()
values = numbered_days.values()

print(f"Ключи: {keys}\nЗначения: {values}")
